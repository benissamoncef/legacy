/*E*/
/* Fichier : $Id: ITMA_TDO.am,v 1.105 2019/11/12 11:16:01 gesconf Exp $        Release : $Revision: 1.105 $        Date : $Date: 2019/11/12 11:16:01 $
-------------------------------------------------------------------------------
* STERIA *  PROJET MIGRAZUR
-------------------------------------------------------------------------------
* SOUS-SYSTEME  GESIHM
-------------------------------------------------------------------------------
* MODULE ITMA_TDO * FICHIER ITMA_TDO.am
-------------------------------------------------------------------------------
* DESCRIPTION DU MODULE :
*
*   Module de donnees globales a la tache IHM textuelle TITMA
*
*   Cf. DCG 2.4.22
*
-------------------------------------------------------------------------------
* HISTORIQUE :
*
* Lecrivain	25 Aug 1994	: Creation
* Lecrivain	11 Oct 1994	: Init. des mode FMC et FMC ouverte    	V1.24
* Lecrivain     17 Oct 1994	: Ajout types et categories astreintes 	V1.30
* Lecrivain     18 Oct 1994	: Type table familles est (TRUE, FALSE)    V1.32
* Noel		24 Oct 1994	: Ajout de vg_numero_operateur		V1.34
* Guilhou		26 Oct 1994	: 								V1.37
* Noel		03 Nov 1994	: declaration des barrieres de pÅage	V1.38
* Guilhou		09 nov 1994	: declaration tableau pixmaps fav		V1.39
* Lecrivain     15 Nov 1994	: Lecture des donnees en base             V1.41
* Lecrivain     17 Nov 1994	: Decoupage en deux parties               V1.42
* Lecrivain     24 Nov 1994	: Suppression liste des postes            V1.43
* Guilhou		01 dec 1994	: declaration pixmap voies inverses	V1.44
* Guilhou	 	01 dec 1994    : correction init config des voies	V1.45
* Guilhou		05 dec 1994	: chgt libelle point_car null	V1.47
* Lecrivain     22 Fev 1995	: Ajout de nouveaux types d'equipements   V1.53
* Lecrivain     27 Fev 1995	: Tri alphabetique des types d'equipements V1.54
* Lecrivain  	03 Avr 1995 	: Ajout du type equipement Satir           V1.57
* Volcic  	30 Jun 1995 	: Ajout listes cameras et magnetoscopes    V1.58
* Volcic  	07 Jui 1995 	: Ajout listes cameras CI    			V1.59
* Noel		21 Sep 1995	: Ajout du type d'imprimante liée	  V1.60
* Guilhou	27 Sep 1995	: Ajout parametres de connexion par defaut a Sybase	V1.61
* Torregrossa	12 Oct 1995	: Ajout variable globale pour tous les peages (gares+echangeurs)	V1.62
* Torregrossa	01 Dec 1995	: Ajout liste des fax V1.63
* Noel 		19 Fev 1996	: Suppression de l'init de vg_type_imprimante par lecture du fichier	V1.64
*					(DEM 91)
* Torregrossa	04 Mar 1996	: Ordonner alphabetiquement la liste des types d'eqts (1023) V1.65
* Torregrossa	06 Jui 1996	: Changer l'ordre des pixmaps de bau inv. (678) V1.66
* Mismer  	26 Aou 1996 	: Ajout listes type PMV et Picto (DEM/1162)	V1.67
* Guilhou	03 Sep 1996	: transmssion a titbi ou titmo du numero du site V1.68
* Orengo	17 Sep 1996	: Ajout des districts Cannet et St Maximin LTVideo V1.69
* Niepceron	04 Oct 1996	: Ajout de l'init de vg_niv_diff (dem/1248) v1.70
* Torregrossa	14 Nov 1996	: Ajout pixmap bau etroite (1283) V1.71
* Niepceron	25 Nov 1996	: Ajout de l'init de vg_niv_diff (dem/1248) v1.72
* Niepceron	27 Nov 1996	: Lecture des lib eqt en base (dem/1232) v1.73
* Niepceron	12 Dec 1996	: Ajout d'un libelle parametrable associe au niveau TFM (dem/1328) v1.74
* Torregrossa	15 Dec 1997	: Ajout rechercher du type du pc (1531) V1.75
* Guilhou	21 jan 1998	: ajout init vg_requete_xzae148_en_cours 1.76
* Torregrossa	09 Fev 1998	: Ajout vg_info_district_local (1536) V1.77
* Mismer        16 fev 1998 : modif pour video CI  (DEM/1541) V1.78
* Niepceron     08 Sep 1998	: Ajout lecture des fichiers ntfm v1.79
* Niepceron     13 Jan 1999 : modif intergestionnaire v1.80 dem/1723
* JMG		18/10/05	: ajout vg_type_PMVA 1.81
* JPL		08/02/2007	: Ajout vg_autoroutes_district (DEM614) 1.83
* JPL		08/02/2007	: Listes pt car. 'xxx_district' complètes au CI 1.84
* JPL		20/06/2007	: Lecture liste ITPC 'vg_itpc_district' (DEM 647) 1.85
* JPL		20/06/2007	: Lecture liste cantons 'vg_cantons_district' (DEM 657) 1.86
* JMG		10/07/07	: ajout district recouvrement 3 dans XZAO414
* JMG		31/10/07        : ajout site de gestion  1.88
* JPL		20/11/07	: Ajout lecture configuration actions 'coup de poing' (DEM 706) 1.89
* JPL		01/10/10	: Ajout lecture liste des bifurcations d'autoroutes (DEM 930) 1.90
* JPL		22/10/10	: Lecture liste magnetoscopes du site au CI aussi (DEM 949) 1.91
* JMG		15/12/10	: portage linux 1.92
* JPL		17/01/11	: Decoupage avec sous-fonctions pour meilleure gestion memoire  1.93
* JPL		17/01/11	: Format equipements minimisant la memoire; code camera inclus (DEM 949)  1.94
* JPL		02/02/11	: Lecture des cameras en donnees publiques au CI aussi (DEM 949)  1.95
* JPL		18/03/11	: Lecture des cameras par XZAT010 pour avoir le site de gestion  1.96
* LCL		21/03/12	: ajout vg_type_PRV 1.97 (DEM/1016)
* JPL		18/03/11	: Simple renommage de constantes  1.98
* PNI		20/04/15	: Aires supprimées non mémorisées dans la liste DEM1127 1.99
* JMG		07/06/16	: ajout vg_type_SAGA 1.100
* JPL		08/03/18	: Ajout fonctions TDO_Ordre_PR et TDO_Echangeur_En_Sortie  1.101
* JPL		08/03/18	: Ajout TDO_Echangeur_Situe_En; initialisation coup de poing Toulon (DEM 1277)  1.102
* JPL		08/03/18	: Initialisation coup de poing Toulon (DEM 1277)  1.103
* JMG		01/08/18  	: recup nbcar PMV suppression SAGA DEM1306 1.104
* PNI		30/08/19	: SQL_xx explicité dans l'appel du SQL_CONNECT@ 1.105
--------------------------------------------------------------------------------- */

INCLUDE	"dbase_.am"

INCLUDE	"XDMICG/inc/xdc_ax.h"		' Constantes d'init. des tables
INCLUDE	"XDMICG/inc/xzic_ax.h"		' Constantes d'init. des tables

INCLUDE	"GESIHM/inc/ITMA_COM.h"
INCLUDE	"GESIHM/inc/ITMA_TAR.h"
INCLUDE	"GESIHM/inc/ITMA_TDO.h"
INCLUDE	"GESIHM/inc/ITMA_TRG.h"
INCLUDE	"GESIHM/inc/ITMA_TLV.h"			' Pour le mode de la liste FMC
INCLUDE	"GESIHM/inc/ITMA_PMV_format.h"	' Pour le format de la liste de PMV
INCLUDE	"GESIHM/inc/ITMA_TPRV.h"

INCLUDE	"GESIHM/inc/xzao123sp.h"		' Liste des autoroutes
INCLUDE	"GESIHM/inc/xzao150sp.h"		' Liste des bifurcations d'autoroutes
INCLUDE	"GESIHM/inc/xzao220sp.h"		' Liste des ITPC du district
INCLUDE	"GESIHM/inc/xzao223sp.h"		' Liste des autoroutes du district
INCLUDE	"GESIHM/inc/xzao224sp.h"		' Liste des cantons du district
INCLUDE	"GESIHM/inc/xzao30sp.h"			' Liste des districts
INCLUDE	"GESIHM/inc/xzao301sp.h"		' Liste des echangeurs
INCLUDE	"GESIHM/inc/xzao302sp.h"		' Liste des gares de peage
INCLUDE	"GESIHM/inc/xzao303sp.h"		' Liste des aires
INCLUDE	"GESIHM/inc/xzao304sp.h"		' Liste des lits d'arret
INCLUDE	"GESIHM/inc/xzao557sp.h"		' Liste des zones
INCLUDE	"GESIHM/inc/xzao74sp.h"			' Liste des type de PMV
INCLUDE	"GESIHM/inc/xzao781sp.h"			' Liste des type de PMV
INCLUDE	"GESIHM/inc/xzao78sp.h"			' Liste des PMV
INCLUDE	"GESIHM/inc/xzao75sp.h"			' Liste des type de Picto
INCLUDE	"GESIHM/inc/xzao79sp.h"			' Liste des Picto
INCLUDE	"GESIHM/inc/xzao414sp.h"		' info site
INCLUDE	"GESIHM/inc/xzao415sp.h"		' infos sites
INCLUDE	"GESIHM/inc/xzal01sp.h"			' Liste des motifs appel
INCLUDE	"GESIHM/inc/xzae03sp.h"			' Liste des types fmc
INCLUDE	"GESIHM/inc/xzat01sp.h"			' Liste des equipements disponibles
INCLUDE	"GESIHM/inc/xzat010sp.h"		' Liste des equipements disponibles
INCLUDE	"GESIHM/inc/xzao18sp.h"			' Liste des cameras


DEFINE	CM_NUM_AUT_A57		8		' Pour recherche de particularite sur cette autoroute


DEFINE	C_MODULE	"MTDO"			' Nom du module



VAR	FORMAT TDO_Echangeur	tm_echangeurs		' Liste complete des echangeurs, pour recherche



/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*   Initialise les donnees publiques de cette instance de process Applix.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TDO

/*
* ARGUMENTS EN ENTREE : Aucun
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : COM_OK.
*
* CONDITION D'UTILISATION
*   ITMA_TLU_login sur ecran DIAL ou en mono-ecran
*   Sur message ITRE_COM_MSG_NEW_TASK sur ecran MCE en bi-ecran
*
* FONCTION
*   Demande la connexion au SGBD puis lit le contenu d'un certain nombre de
*   tables pour valuer les variables publiques.
*
---------------------------------------------------------------------------- */

ON ERROR {
	ERROR_BOX@
	COM01_Trace (COM_FATAL, COM03_Message_Erreur (C_MODULE))
	RETURN (COM_NOK)
}

/*A
** Initialiser les donnees de base
** -------------------------------
*/

ITMA_TDO1 ()


/*A
** Initialiser les autres donnees publiques
** ----------------------------------------
*/

ITMA_TDO_Reseau ()

ITMA_TDO2 ()

ITMA_TDO_Video ()

ITMA_TDO_MTFM ()


/*A
 * Lire les configurations d'actions "coup de poing"
 * -------------------------------------------------
 */

IF (SYSTEM_VAR@ (vg_site) <> XDC_DP) {
	ITMA_TCP_Coup_De_Poing ("ITMA_TDO")
}

IF (SYSTEM_VAR@ (vg_site) <> XDC_VC) {
	ITMA_TCPT_Coup_De_Poing_Toulon ("ITMA_TDO")
}

RETURN (COM_OK)

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*   Initialise une premiere partie des donnees publiques.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TDO1

/*
* ARGUMENTS EN ENTREE : Aucun
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : COM_OK en cas d'execution correcte, COM_NOK sinon.
*
* CONDITION D'UTILISATION
*   ITMA_TDO
*
* FONCTION
*   - Etablit la connexion au SGBD
*   - Initialise les donnees de base (repertoire de fonctionnement, site local)
*   - Lit en base un certain nombre de tables pour valuer les variables publiques
*      (sites, types ...).
*
---------------------------------------------------------------------------- */

    VAR					vl_canal_SGBD

    VAR    vl_site, vl_code_site

    VAR FORMAT TDO_District		vl_districts

    VAR FORMAT TDO_Type_FMC		vl_les_types_FMC
    VAR FORMAT TDO_Type_Equipement	vl_les_types_equipement
    VAR 				tl_pix_fav, tl_pix_bau

    VAR FORMAT SQL_Procedure_Params@	vl_parametres
    VAR FORMAT SQL_Procedure_Result@	vl_resultats

    VAR    vl_repertoire
    VAR    tl_liste
	VAR vl_tableau, vl_tableau_code
    VAR	 vl_horodate
    VAR    i, vl_indice


/*A
 * Definir le traitement a realiser en cas d'erreur
 * ------------------------------------------------
 */

ON ERROR {
    ERROR_BOX@
    COM01_Trace (COM_FATAL, COM03_Message_Erreur (C_MODULE))
    RETURN (COM_NOK)
}


/*A
 * Determiner le chemin d'acces complet au logiciel
 * ------------------------------------------------
 */

vl_repertoire = CURRENT_DIR@()
tl_liste = ARRAY_FROM_STRING@ (vl_repertoire, "/")
tl_liste = ARRAY_DELETE@ (tl_LISTE, ARRAY_SIZE@ (tl_liste))
vl_repertoire = ARRAY_TO_STRING@ (tl_liste, "/")
SET_SYSTEM_VAR@ (vg_repertoire_migrazur, vl_repertoire ++ "/")

'SET_SYSTEM_VAR@(vg_repertoire_migrazur, XDC_PATH_MIGRAZURHOME ++ "/")
'SET_SYSTEM_VAR@ (vg_requete_en_cours, FALSE)


/*A
 * Ajouter le repertoire des pictogrammes
 * a la liste des repertoires de recherche
 * ---------------------------------------
 */

tl_liste = SYSTEM_VAR@ ("elf_search_list@")
tl_liste[ARRAY_SIZE@(tl_liste)] = SYSTEM_VAR@(vg_repertoire_migrazur) ++ COM_SOUS_REP_PICTOS
SET_SYSTEM_VAR@ ("elf_search_list@", tl_liste)


/*pas d'operateur connecte au depart*/
SET_SYSTEM_VAR@(vg_num_fiche_operateur,null)
SET_SYSTEM_VAR@(vg_cle_fiche_operateur,null)

/*A
 * Lire dans l'environnement le site local
 * ---------------------------------------
 */

vl_code_site = SYSTEM_VAR@ (vg_nom_site)


/*A
 * Etablir une connexion SGBD (s'il n'y en a pas deja une
 * - pour pouvoir reexecuter, en phase de developpement -)
 * -------------------------------------------------------
 */
 COM01_Trace(COM_DEBUG1,"SQL_CONNECT@: "++COM_NOM_SGBD++","++COM_USER++","++COM_MOT_PASSE++","++COM_BASE++","++"SD"++vl_code_site++"1"++","++"SQL_"++vl_code_site)

IF SYSTEM_VAR@ (vg_canal_SGBD) = NULL {
    if (GET_ENV_VAR@("RTARCH")="hp700_hpux")
    	vl_canal_SGBD = SQL_CONNECT@ (COM_NOM_SGBD, COM_USER, COM_MOT_PASSE,
				 COM_BASE, COM_HOTE, COM_SERVEUR ++ vl_code_site)
    else
        vl_canal_SGBD = SQL_CONNECT@ (COM_NOM_SGBD, COM_USER, COM_MOT_PASSE,
	                                COM_BASE,"SD"++vl_code_site++"1","SQL_"++vl_code_site)
    SQL_CHANNEL_MASTER@ (vl_canal_SGBD, 0)
    SET_SYSTEM_VAR@ (vg_canal_SGBD, vl_canal_SGBD)
}

/* parametres de connexion a Sybase*/
SET_SYSTEM_VAR@ ("sql_username@", COM_USER)
SET_SYSTEM_VAR@ ("sql_passwd@", COM_MOT_PASSE)



/*A
 * Lire en base la liste des districts
 * -----------------------------------
 */

vl_parametres = NULL
vl_parametres[0].type = SYB#CHAR_
vl_parametres[0].data = XDC_BASE_CFG
vl_parametres[0].output = FALSE

IF COM05_SQL_Procedure (XZAO415_ListeDistricts ,
			   vl_parametres, vl_resultats, C_MODULE) <> COM_OK
    RETURN (COM_NOK)

vl_indice=0
FOR i=0 TO ARRAY_SIZE@ (vl_resultats.select_results[0]) - 1

	IF vl_resultats.select_results[0][i][TDO_TYPE_DISTRICT] <> 0 {
    		vl_districts[vl_indice] = vl_resultats.select_results[0][i]
		vl_indice = vl_indice+1
	}

NEXT i

SET_SYSTEM_VAR@ (vg_les_districts, vl_districts)



/*A
 * Determiner le numero du site en fonction de son nom
 * ---------------------------------------------------
 */

i = ARRAY_INDEX@ (ARRAY_COLUMN@ (vl_districts, TDO_CODE_DISTRICT), vl_code_site)
vl_site = vl_districts[i].numero

SET_SYSTEM_VAR@ (vg_site, vl_site)



/*A
 * Liste des types de fiches main courante
 * ---------------------------------------
 */

IF COM05_SQL_Procedure (XZAE03_Liste_Types_Evt,
			   NULL, vl_resultats, C_MODULE) <> COM_OK
    RETURN (COM_NOK)

vl_les_types_FMC = vl_resultats.select_results[0]
FOR i = 0  TO ARRAY_SIZE@ (vl_les_types_FMC) - 1
    vl_les_types_FMC[i].supprime = (vl_les_types_FMC[i].supprime = XDC_VRAI)
NEXT i

SET_SYSTEM_VAR@ (vg_les_types_FMC, vl_les_types_FMC)



/*A
 * Liste des motifs d'appel (uniquement sur le site CI)
 * ----------------------------------------------------
 */

IF vl_code_site = XDC_NOM_SITE_CI {
    IF COM05_SQL_Procedure (XZAL01_Liste_Motifs_Appel,
				NULL, vl_resultats, C_MODULE) = COM_OK
    {
	SET_SYSTEM_VAR@ (vg_les_motifs_appel, vl_resultats.select_results[0])
    }
}



/*A
 * Liste des types d'equipements
 * -----------------------------
 */
COM37_Lit_Libelles_Predefinis (XDC_LIB_TYPE_EQUIPEMENT,vl_tableau_code,vl_tableau)

FOR i=0 TO ARRAY_SIZE@(vl_tableau)-1
	vl_les_types_equipement[i].numero = vl_tableau[i][1]
	vl_les_types_equipement[i].nom = vl_tableau[i][3]
NEXT i
	

SET_SYSTEM_VAR@ (vg_les_types_equipement, vl_les_types_equipement)



/*A
 * Listes des types et categories d'astreintes
 * -------------------------------------------
 */

IF (ITMA_TAN_Types_Categ_Astreinte ("MTDO") <> COM_OK)
{
	NOTHING
	'RETURN (COM_NOK)
}



/*A
 * initialisation des pixmaps des fav*/
tl_pix_fav[XDC_VOIE_INCONNUE]=TDO_voie_inconnue
tl_pix_fav[XDC_VOIE_SENS_NORMAL]=TDO_voie_normale
tl_pix_fav[XDC_VOIE_SENS_INVERSE]=TDO_voie_inverse
tl_pix_fav[XDC_VOIE_BLOQUEE]=TDO_voie_bloquee
tl_pix_fav[XDC_VOIE_INEXISTANTE]=TDO_voie_inexistante
tl_pix_fav[XDC_VOIE_NEUTRALISEE]=TDO_voie_neutralisee
tl_pix_fav[XDC_VOIE_BLOQUEE_NEUTRALISEE]=TDO_voie_bloq_neutralisee

SET_SYSTEM_VAR@ (vg_les_pix_fav, tl_pix_fav)


tl_pix_bau[XDC_VOIE_INCONNUE]=TDO_voie_inconnue
tl_pix_bau[XDC_VOIE_SENS_NORMAL]=TDO_voie_normale
tl_pix_bau[XDC_VOIE_SENS_INVERSE]=TDO_voie_inverse
tl_pix_bau[XDC_VOIE_BLOQUEE]=TDO_voie_bloquee
tl_pix_bau[XDC_VOIE_INEXISTANTE]=TDO_voie_inexistante
tl_pix_bau[XDC_VOIE_NEUTRALISEE]=TDO_voie_neutralisee
tl_pix_bau[XDC_VOIE_BLOQUEE_NEUTRALISEE]=TDO_voie_bloq_neutralisee
tl_pix_bau[XDC_VOIE_BAU_NORMALE]=TDO_voie_bau_normale
tl_pix_bau[XDC_VOIE_BAU_ETROITE+XDC_VOIE_INCONNUE]=TDO_voie_inconnue
tl_pix_bau[XDC_VOIE_BAU_ETROITE+XDC_VOIE_SENS_NORMAL]=TDO_voie_etroite_normale
tl_pix_bau[XDC_VOIE_BAU_ETROITE+XDC_VOIE_SENS_INVERSE]=TDO_voie_etroite_inverse
tl_pix_bau[XDC_VOIE_BAU_ETROITE+XDC_VOIE_BLOQUEE]=TDO_voie_etroite_bloquee
tl_pix_bau[XDC_VOIE_BAU_ETROITE+XDC_VOIE_INEXISTANTE]=TDO_voie_inexistante
tl_pix_bau[XDC_VOIE_BAU_ETROITE+XDC_VOIE_NEUTRALISEE]=TDO_voie_etroite_neutralisee
tl_pix_bau[XDC_VOIE_BAU_ETROITE+XDC_VOIE_BLOQUEE_NEUTRALISEE]=TDO_voie_etroite_bloq_neutralisee
tl_pix_bau[XDC_VOIE_BAU_ETROITE+XDC_VOIE_BAU_NORMALE]=TDO_voie_etroite_bau_normale

SET_SYSTEM_VAR@ (vg_les_pix_bau, tl_pix_bau)


/*A
 * initialisation des pixmaps des fav inverses*/
tl_pix_fav[XDC_VOIE_INCONNUE]=TDO_voie_inconnue
tl_pix_fav[XDC_VOIE_SENS_NORMAL]=TDO_voie_normale_s_inv
tl_pix_fav[XDC_VOIE_SENS_INVERSE]=TDO_voie_inverse_s_inv
tl_pix_fav[XDC_VOIE_BLOQUEE]=TDO_voie_bloquee
tl_pix_fav[XDC_VOIE_INEXISTANTE]=TDO_voie_inexistante
tl_pix_fav[XDC_VOIE_NEUTRALISEE]=TDO_voie_neutralisee
tl_pix_fav[XDC_VOIE_BLOQUEE_NEUTRALISEE]=TDO_voie_bloq_neutralisee

SET_SYSTEM_VAR@ (vg_les_pix_fav_inv, tl_pix_fav)


tl_pix_bau[XDC_VOIE_INCONNUE]=TDO_voie_inconnue
tl_pix_bau[XDC_VOIE_SENS_NORMAL]=TDO_voie_normale_s_inv 
tl_pix_bau[XDC_VOIE_SENS_INVERSE]=TDO_voie_inverse_s_inv
tl_pix_bau[XDC_VOIE_BLOQUEE]=TDO_voie_bloquee
tl_pix_bau[XDC_VOIE_INEXISTANTE]=TDO_voie_inexistante
tl_pix_bau[XDC_VOIE_NEUTRALISEE]=TDO_voie_neutralisee
tl_pix_bau[XDC_VOIE_BLOQUEE_NEUTRALISEE]=TDO_voie_bloq_neutralisee
tl_pix_bau[XDC_VOIE_BAU_NORMALE]=TDO_voie_bau_normale
tl_pix_bau[XDC_VOIE_BAU_ETROITE+XDC_VOIE_INCONNUE]=TDO_voie_inconnue
tl_pix_bau[XDC_VOIE_BAU_ETROITE+XDC_VOIE_SENS_NORMAL]=TDO_voie_etroite_normale_s_inv
tl_pix_bau[XDC_VOIE_BAU_ETROITE+XDC_VOIE_SENS_INVERSE]=TDO_voie_etroite_inverse_s_inv
tl_pix_bau[XDC_VOIE_BAU_ETROITE+XDC_VOIE_BLOQUEE]=TDO_voie_etroite_bloquee
tl_pix_bau[XDC_VOIE_BAU_ETROITE+XDC_VOIE_INEXISTANTE]=TDO_voie_inexistante
tl_pix_bau[XDC_VOIE_BAU_ETROITE+XDC_VOIE_NEUTRALISEE]=TDO_voie_etroite_neutralisee
tl_pix_bau[XDC_VOIE_BAU_ETROITE+XDC_VOIE_BLOQUEE_NEUTRALISEE]=TDO_voie_etroite_bloq_neutralisee
tl_pix_bau[XDC_VOIE_BAU_ETROITE+XDC_VOIE_BAU_NORMALE]=TDO_voie_etroite_bau_normale

SET_SYSTEM_VAR@ (vg_les_pix_bau_inv, tl_pix_bau)


/*A
 * Initialiser le fonctionnement de la liste FMC (mode initial "Traiter")
 * ----------------------------------------------------------------------
 */

SET_SYSTEM_VAR@ (vg_mode_liste_fmc, TLVC_TRAITER)


/*A
 * Initialement, aucune fenetre ouverte
 * ------------------------------------
 */

SET_SYSTEM_VAR@ (vg_fmc_ouverte, FALSE)


/*A
 * Siecle par defaut pour saisie de dates
 * --------------------------------------
 */
vl_horodate = DECOMPOSE_TIME@ (CURRENT_TIME@ ())

if (vl_horodate[5]<80) {
	SET_SYSTEM_VAR@ (vg_siecle, 2000)
} else {
	SET_SYSTEM_VAR@ (vg_siecle, 1900)
}


/*A
 * Initialement, IHM non bloquee
 * -----------------------------
 */

SET_SYSTEM_VAR@ (vg_verrou, FALSE)
SET_SYSTEM_VAR@ (vg_requete_xzae148_en_cours,FALSE)

RETURN (COM_OK)

ENDMACRO





/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*   Initialise les donnees publiques relatives au reseau.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TDO_Reseau

/*
* ARGUMENTS EN ENTREE : Aucun
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : COM_OK.
*
* CONDITION D'UTILISATION
*   ITMA_TDO
*
* FONCTION
*   Initialise les variables publiques des donnees reseau en fonction du site.
*
---------------------------------------------------------------------------- */

	VAR FORMAT TDO_Sens_Circulation		vl_les_sens_circulation
	VAR FORMAT TDO_Point_Car		vl_les_points_car

	VAR FORMAT TDO_Autoroute		vl_autoroutes
	VAR FORMAT TDO_Echangeur		vl_echangeurs, vl_echangeurs_district
	VAR FORMAT TDO_Aire			vl_aires, vl_aires_district
	VAR FORMAT TDO_Lit_Arret		vl_lits_arret, vl_lits_arret_district
	VAR FORMAT TDO_Gare			vl_gares, vl_gares_district
	VAR FORMAT TDO_Peage			vl_peages, vl_peages_district
	VAR FORMAT TDO_ITPC			vl_itpc_district
	VAR FORMAT TDO_Canton			vl_cantons_district

	VAR FORMAT SQL_Procedure_Params@	vl_parametres
	VAR FORMAT SQL_Procedure_Result@	vl_resultats

	VAR FORMAT T_zone			vl_zones
	VAR vl_site, tl_data
	VAR i, vl_indice

vl_site = SYSTEM_VAR@ (vg_site)


/*A
 * Liste complete des autoroutes et liste de celles du district local
 * ------------------------------------------------------------------
 */

vl_parametres = NULL
vl_parametres[0].type = SYB#CHAR_
vl_parametres[0].data = XDC_BASE_CFG
vl_parametres[0].output = FALSE

IF COM05_SQL_Procedure (XZAO123_Liste_Autoroutes,
			   vl_parametres, vl_resultats, C_MODULE) <> COM_OK
    RETURN (COM_NOK)

SET_SYSTEM_VAR@ (vg_toutes_les_autoroutes, vl_resultats.select_results[0])


vl_indice=0
FOR i=0 TO ARRAY_SIZE@ (vl_resultats.select_results[0]) - 1

	IF vl_resultats.select_results[0][i][3]=XDC_VRAI {
    		vl_autoroutes[vl_indice] = vl_resultats.select_results[0][i]
		vl_indice=vl_indice+1
	}

NEXT i
SET_SYSTEM_VAR@ (vg_les_autoroutes, vl_autoroutes)


/* Autoroutes du district */
IF vl_site = XDC_CI {
	SET_SYSTEM_VAR@ (vg_autoroutes_district, vl_autoroutes)
} ELSE {
	vl_parametres = NULL
	vl_parametres[0].type = SYB#INT1_
	vl_parametres[0].data = vl_site
	vl_parametres[0].output = FALSE

	IF COM05_SQL_Procedure (XZAO223_Autoroutes_District,
	                           vl_parametres, vl_resultats, C_MODULE) <> COM_OK
		RETURN (COM_NOK)

	SET_SYSTEM_VAR@ (vg_autoroutes_district, vl_resultats.select_results[0])
}



/*A
 * Liste des bifurcations d'autoroutes
 * -----------------------------------
 */

vl_parametres = NULL

IF COM05_SQL_Procedure (XZAO150_Liste_Bifurcations,
			   vl_parametres, vl_resultats, C_MODULE) <> COM_OK
    RETURN (COM_NOK)

SET_SYSTEM_VAR@ (vg_les_bifurcations, vl_resultats.select_results[0])



/*A
 * Definition des sens de circulation
 * ----------------------------------
 */

vl_les_sens_circulation[0].numero = XDC_SENS_INCONNU
vl_les_sens_circulation[0].nom = XDC_LIB_SENS_INCONNU

vl_les_sens_circulation[1].numero = XDC_SENS_NORD
vl_les_sens_circulation[1].nom = XDC_LIB_SENS_NORD

vl_les_sens_circulation[2].numero = XDC_SENS_SUD
vl_les_sens_circulation[2].nom = XDC_LIB_SENS_SUD

vl_les_sens_circulation[3].numero = XDC_SENS_SORTIE_NORD
vl_les_sens_circulation[3].nom = XDC_LIB_SENS_SORTIE_NORD

vl_les_sens_circulation[4].numero = XDC_SENS_SORTIE_SUD
vl_les_sens_circulation[4].nom = XDC_LIB_SENS_SORTIE_SUD

vl_les_sens_circulation[5].numero = XDC_SENS_ENTREE_NORD
vl_les_sens_circulation[5].nom = XDC_LIB_SENS_ENTREE_NORD

vl_les_sens_circulation[6].numero = XDC_SENS_ENTREE_SUD
vl_les_sens_circulation[6].nom = XDC_LIB_SENS_ENTREE_SUD

SET_SYSTEM_VAR@ (vg_les_sens_circulation, vl_les_sens_circulation)



/*A
 * Definition des points caracteristiques
 * --------------------------------------
 */

vl_les_points_car[0].numero=0
vl_les_points_car[0].nom="Section courante"
vl_les_points_car[1].numero=XDC_POINT_CARACT_AIRE
vl_les_points_car[1].nom="Aire"
vl_les_points_car[2].numero=XDC_POINT_CARACT_ECHANGEUR
vl_les_points_car[2].nom="Echangeur"
vl_les_points_car[3].numero=XDC_POINT_CARACT_PEAGE
vl_les_points_car[3].nom="Péage"
vl_les_points_car[4].numero=XDC_POINT_CARACT_LIT_ARRET
vl_les_points_car[4].nom="Lit d'arrêt"

SET_SYSTEM_VAR@ (vg_les_points_car, vl_les_points_car)



/*A
 * Liste complete des echangeurs et liste de ceux du district local
 * ----------------------------------------------------------------
 */

IF COM05_SQL_Procedure (XZAO301_Liste_Echangeurs_Ax,
			   NULL, vl_resultats, C_MODULE) <> COM_OK
    RETURN (COM_NOK)

vl_echangeurs = vl_resultats.select_results[0]

vl_indice = 0
FOR i = 0  TO ARRAY_SIZE@ (vl_echangeurs) - 1
    vl_echangeurs[i].supprime = (vl_echangeurs[i].supprime = XDC_VRAI)

    IF (vl_site = XDC_CI)  OR  (vl_echangeurs[i].district = vl_site) {
	vl_echangeurs_district[vl_indice] = vl_echangeurs[i]
	vl_indice = vl_indice + 1
    }
NEXT i

SET_SYSTEM_VAR@ (vg_les_echangeurs, vl_echangeurs)
SET_SYSTEM_VAR@ (vg_echangeurs_district, vl_echangeurs_district)



/*A
 * Liste complete des peages (y compris sur echangeur)
 *  et liste de ceux du district local
 * ---------------------------------------------------
 */

vl_parametres = NULL
vl_parametres[0].type = SYB#INT2_
vl_parametres[0].data = XDC_VRAI
vl_parametres[0].output = FALSE

IF COM05_SQL_Procedure (XZAO302_Liste_Gares_Peage_Ax,
			vl_parametres, vl_resultats, C_MODULE) <> COM_OK
    RETURN (COM_NOK)

vl_peages = vl_resultats.select_results[0]

vl_indice = 0
FOR i = 0  TO ARRAY_SIZE@ (vl_peages) - 1
    vl_peages[i].supprime = (vl_peages[i].supprime = XDC_VRAI)

    IF (vl_site = XDC_CI)  OR  (vl_peages[i].district = vl_site) {
	vl_peages_district[vl_indice] = vl_peages[i]
	vl_indice = vl_indice + 1
    }
NEXT i

SET_SYSTEM_VAR@ (vg_les_peages, vl_peages)
SET_SYSTEM_VAR@ (vg_peages_district, vl_peages_district)


/*A
 * Liste complete des gares de peage et liste de celles du district local
 * ----------------------------------------------------------------------
 */

IF COM05_SQL_Procedure (XZAO302_Liste_Gares_Peage_Ax,
			   NULL, vl_resultats, C_MODULE) <> COM_OK
    RETURN (COM_NOK)

vl_gares = vl_resultats.select_results[0]

vl_indice = 0
FOR i = 0  TO ARRAY_SIZE@ (vl_gares) - 1
    vl_gares[i].supprime = (vl_gares[i].supprime = XDC_VRAI)

    IF (vl_site = XDC_CI)  OR  (vl_gares[i].district = vl_site) {
	vl_gares_district[vl_indice] = vl_gares[i]
	vl_indice = vl_indice + 1
    }
NEXT i

SET_SYSTEM_VAR@ (vg_les_gares, vl_gares)
SET_SYSTEM_VAR@ (vg_gares_district, vl_gares_district)



/*A
 * Liste complete des aires et liste de celles du district local
 * -------------------------------------------------------------
 */

IF COM05_SQL_Procedure (XZAO303_Liste_Aires_Ax,
			   NULL, vl_resultats, C_MODULE) <> COM_OK
    RETURN (COM_NOK)

vl_aires = vl_resultats.select_results[0]

vl_indice = 0
FOR i = 0  TO ARRAY_SIZE@ (vl_aires) - 1
    vl_aires[i].supprime = (vl_aires[i].supprime = XDC_VRAI)

    IF ((vl_site = XDC_CI)  OR  (vl_aires[i].district = vl_site)) AND (vl_aires[i].supprime =XDC_FAUX) {
	vl_aires_district[vl_indice] = vl_aires[i]
	vl_indice = vl_indice + 1
    }
NEXT i

SET_SYSTEM_VAR@ (vg_les_aires, vl_aires)
SET_SYSTEM_VAR@ (vg_aires_district, vl_aires_district)



/*A
 * Liste complete des lits d'arret et liste de ceux du district local
 * ------------------------------------------------------------------
 */

IF COM05_SQL_Procedure (XZAO304_Liste_Lits_Arret_Ax,
			   NULL, vl_resultats, C_MODULE) <> COM_OK
    RETURN (COM_NOK)

vl_lits_arret = vl_resultats.select_results[0]

vl_indice = 0
FOR i = 0  TO ARRAY_SIZE@ (vl_lits_arret) - 1
    vl_lits_arret[i].supprime = (vl_lits_arret[i].supprime = XDC_VRAI)

    IF (vl_site = XDC_CI)  OR  (vl_lits_arret[i].district = vl_site) {
	vl_lits_arret_district[vl_indice] = vl_lits_arret[i]
	vl_indice = vl_indice + 1
    }
NEXT i

SET_SYSTEM_VAR@ (vg_les_lits_arret, vl_lits_arret)
SET_SYSTEM_VAR@ (vg_lits_arret_district, vl_lits_arret_district)



/*A
 * Liste des Interruptions de Terre-Plein Central du district local
 * ----------------------------------------------------------------
 */

vl_parametres = NULL
vl_parametres[0].type = SYB#INT1_
vl_parametres[0].data = vl_site
vl_parametres[0].output = FALSE

IF COM05_SQL_Procedure (XZAO220_Liste_ITPC_Par_District,
			vl_parametres, vl_resultats, C_MODULE) <> COM_OK
    RETURN (COM_NOK)

vl_itpc_district = vl_resultats.select_results[0]

SET_SYSTEM_VAR@ (vg_itpc_district, vl_itpc_district)



/*A
 * Liste des Cantons du district local
 * -----------------------------------
 */

vl_parametres = NULL
vl_parametres[0].type = SYB#INT1_
vl_parametres[0].data = vl_site
vl_parametres[0].output = FALSE

IF COM05_SQL_Procedure (XZAO224_Liste_Cantons_Par_District,
			vl_parametres, vl_resultats, C_MODULE) <> COM_OK
    RETURN (COM_NOK)

vl_cantons_district = vl_resultats.select_results[0]

SET_SYSTEM_VAR@ (vg_cantons_district, vl_cantons_district)

/*liste des zones de regulation*/
vl_parametres = null
vl_parametres[0].type = SYB#CHAR_
vl_parametres[0].data = XDC_BASE_CFG
vl_parametres[0].output = FALSE
vl_parametres[1].type = SYB#INT4_
vl_parametres[1].data = SYSTEM_VAR@(vg_site)
vl_parametres[1].output = FALSE
IF COM05_SQL_Procedure (XZAO557_Liste_Zones,
           vl_parametres, vl_resultats, C_MODULE) <> COM_OK
                   RETURN (COM_NOK)
vl_zones = vl_resultats.select_results[0]
vl_indice = 0
for i = 0 to ARRAY_SIZE@(vl_zones)-1
        if (vl_zones[i].inhibition = 0) {
                tl_data[vl_indice]=vl_zones[i]
                vl_indice = vl_indice +1
        }
next i
SET_SYSTEM_VAR@(vg_zones,vl_zones)


RETURN (COM_OK)

ENDMACRO





/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*   Initialise une (... deuxieme !) partie des donnees publiques.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TDO2

/*
* ARGUMENTS EN ENTREE : Aucun
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : COM_OK.
*
* CONDITION D'UTILISATION
*   ITMA_TDO
*
* FONCTION
*   Initialise le reste des variables publiques en fonction du site.
*
---------------------------------------------------------------------------- */

    VAR FORMAT TDO_District		vl_les_districts

    VAR FORMAT SQL_Procedure_Params@	vl_parametres
    VAR FORMAT SQL_Procedure_Result@	vl_resultats
    VAR FORMAT SQL_Procedure_Params@	vl_parametres2
    VAR FORMAT SQL_Procedure_Result@	vl_resultats2

    	VAR     i, j
	VAR vl_liste_eqt
	VAR vl_liste_type
	VAR vl_site
	VAR FORMAT Config_PMV vl_type_PMV
	VAR FORMAT Config_PMV vl_type_PMVA
	VAR FORMAT Config_PRV vl_type_PRV
	VAR FORMAT Config_SAGA vl_type_SAGA
	VAR FORMAT COM_Localisation vl_localisation
	VAR vl_type_Picto
	VAR vl_msg

vl_site = SYSTEM_VAR@ (vg_site)

vl_msg=MTAR_MSG_EXEC, 1, MTAR_FCT_NUM_SITE, vl_site
DB_SEND_POKE@ (COM_CANAL_TAR01, vl_msg)


vl_les_districts = SYSTEM_VAR@ (vg_les_districts)

/*A
 * Lire en base les informations du site (district) local
 * ------------------------------------------------------
 */
i = 0
vl_parametres = NULL
vl_parametres[i].type	= SYB#CHAR_
vl_parametres[i].data	= SYSTEM_VAR@ (vg_nom_site)	
vl_parametres[i].output	= FALSE
i = i + 1

vl_parametres[i].type	= SYB#CHAR_			' libelle du site
vl_parametres[i].data	= 0	
vl_parametres[i].output	= TRUE
i = i + 1

vl_parametres[i].type	= SYB#INT4_			' numero
vl_parametres[i].data	= 0	
vl_parametres[i].output	= TRUE
i = i + 1

vl_parametres[i].type	= SYB#INT4_			' type du site
vl_parametres[i].data	= 0	
vl_parametres[i].output	= TRUE
i = i + 1

vl_parametres[i].type	= SYB#CHAR_			' nom du serveur
vl_parametres[i].data	= 0	
vl_parametres[i].output	= TRUE
i = i + 1

vl_parametres[i].type	= SYB#CHAR_			' nom machine serveur
vl_parametres[i].data	= 0	
vl_parametres[i].output	= TRUE
i = i + 1

vl_parametres[i].type	= SYB#INT4_			' numero
vl_parametres[i].data	= 0	
vl_parametres[i].output	= TRUE
i = i + 1

vl_parametres[i].type	= SYB#INT4_			' numero
vl_parametres[i].data	= 0	
vl_parametres[i].output	= TRUE
i = i + 1

vl_parametres[i].type	= SYB#INT4_			' numero
vl_parametres[i].data	= 0	
vl_parametres[i].output	= TRUE
i = i + 1

IF COM05_SQL_Procedure (XZAO414_Info_District, vl_parametres,vl_resultats,C_MODULE) <> COM_OK
	RETURN (COM_NOK)

SET_SYSTEM_VAR@ (vg_type_machine, vl_resultats.return_parameters[2])
SET_SYSTEM_VAR@ (vg_info_district_local, vl_resultats.return_parameters)


/*A
 * Listes des types de PMV
 * -----------------------
 */

/*A MAJ de vl_parametres */
vl_parametres[0].type	= SYB#CHAR_
vl_parametres[0].data	= XDC_BASE_CFG
vl_parametres[0].output	= FALSE

/*A Execution de la procedure XZAO74_Lire_Types_PMV	*/			
IF COM05_SQL_Procedure
	( XZAO74_Lire_Types_PMV, vl_parametres, vl_resultats ,C_MODULE) <> COM_OK
	RETURN (COM_NOK)
vl_liste_type = vl_resultats.select_results[0]
/*A MAJ de vl_parametres */
vl_parametres2[0].type	= SYB#CHAR_
vl_parametres2[0].data	= XDC_BASE_CFG
vl_parametres2[0].output	= FALSE

/*A MAJ de vl_parametres */
vl_parametres2[1].type	= SYB#CHAR_
vl_parametres2[1].data	= XDC_CHAINE_VIDE
vl_parametres2[1].output	= FALSE

/*A Execution de la procedure XZAO78_Lire_Liste_PMV	*/			
IF COM05_SQL_Procedure
	( XZAO78_Lire_Liste_PMV, vl_parametres2, vl_resultats2 ,C_MODULE) <> COM_OK
	RETURN (COM_NOK)
vl_liste_eqt = vl_resultats2.select_results[0]
/*A si le resultat du select n'est pas nul */
if ( ARRAY_SIZE@(vl_liste_type)>0 and ARRAY_SIZE@(vl_liste_eqt)>0 )
{
	/*A pour chaque enregistrement */
	for  i=0 to ARRAY_SIZE@(vl_liste_eqt)-1
		for  j=0 to ARRAY_SIZE@(vl_liste_type)-1
			if (vl_liste_eqt[i,4] = vl_liste_type[j,0])
			{
				/* Mettre a jour le nombre de ligne */
				vl_type_PMV [vl_liste_eqt[i,0]].NbLigne = 	vl_liste_type[j,1]
				vl_type_PMV [vl_liste_eqt[i,0]].NbCaracteres = 	vl_liste_type[j,2]
				vl_type_PMV [vl_liste_eqt[i,0]].Flash = 	vl_liste_type[j,3]
				vl_type_PMV [vl_liste_eqt[i,0]].Picto = 	vl_liste_type[j,5]
			}
		next j
	next i


}
/*A sinon reset de la table liste_PMV */
else 
{
	vl_type_PMV [0,0] = ""
}
/*A
 * Listes des PMV
 * --------------
 */

vl_parametres = NULL
vl_parametres[0].type	= SYB#INT1_
vl_parametres[0].data	= XDC_EQT_PMV	
vl_parametres[0].output	= FALSE
	
vl_parametres[1].type	= SYB#INT1_	
vl_parametres[1].data	= NULL
vl_parametres[1].output	= FALSE

vl_parametres[2].type	= SYB#INT4_			' Conditions
vl_parametres[2].data	= 0
vl_parametres[2].output	= FALSE

vl_parametres[3].type	= SYB#INT4_			' Conditions niees
vl_parametres[3].data	= XDC_EQT_HS
vl_parametres[3].output	= FALSE
	
vl_parametres[4].type	= SYB#INT4_			' Exclusions
vl_parametres[4].data	= 0 
vl_parametres[4].output	= FALSE

vl_parametres[5].type	= SYB#INT4_			' Exclusions niees
vl_parametres[5].data	= 0	
vl_parametres[5].output	= FALSE

IF COM05_SQL_Procedure (XZAT01_Liste_Eqt_Dispo,
						vl_parametres,vl_resultats,C_MODULE) <> COM_OK
RETURN (COM_NOK)

vl_liste_eqt = vl_resultats.select_results[0]
/*A si le resultat du select n'est pas nul */
if ARRAY_SIZE@(vl_liste_eqt)>0 
{
	/*A pour chaque enregistrement */
	for  i=0 to ARRAY_SIZE@(vl_liste_eqt)-1
		vl_localisation.NumAuto 	= vl_liste_eqt[i,3]
		vl_localisation.PR 		= vl_liste_eqt[i,4]
		vl_localisation.sens_circulation = vl_liste_eqt[i,5]

		vl_type_PMV [vl_liste_eqt[i,1]].Identifiant = "PMV" ++ COM10_Localisation(vl_localisation)
		j = ARRAY_INDEX@ (ARRAY_COLUMN@ (vl_les_districts, TDO_NUMERO_DISTRICT),ITMA_COM_Site_PR(vl_localisation.NumAuto,
					vl_localisation.PR,"MTDO"))
		if j >= 0
		{
			vl_type_PMV [vl_liste_eqt[i,1]].NumSite = vl_les_districts[j].numero
			vl_type_PMV [vl_liste_eqt[i,1]].NomSite = vl_les_districts[j].code
		}
		vl_type_PMV [vl_liste_eqt[i,1]].SiteGestion = vl_liste_eqt[i,8]
	next i

}
SET_SYSTEM_VAR@ (vg_type_PMV, vl_type_PMV)


vl_parametres = NULL
vl_parametres[0].type	= SYB#INT1_
vl_parametres[0].data	= XDC_EQT_PMVA
vl_parametres[0].output	= FALSE
	
vl_parametres[1].type	= SYB#INT1_	
vl_parametres[1].data	= NULL
vl_parametres[1].output	= FALSE

vl_parametres[2].type	= SYB#INT4_			' Conditions
vl_parametres[2].data	= 0
vl_parametres[2].output	= FALSE

vl_parametres[3].type	= SYB#INT4_			' Conditions niees
vl_parametres[3].data	= XDC_EQT_HS
vl_parametres[3].output	= FALSE
	
vl_parametres[4].type	= SYB#INT4_			' Exclusions
vl_parametres[4].data	= 0 
vl_parametres[4].output	= FALSE

vl_parametres[5].type	= SYB#INT4_			' Exclusions niees
vl_parametres[5].data	= 0	
vl_parametres[5].output	= FALSE

IF COM05_SQL_Procedure (XZAT01_Liste_Eqt_Dispo,
						vl_parametres,vl_resultats,C_MODULE) <> COM_OK
RETURN (COM_NOK)

vl_liste_eqt = vl_resultats.select_results[0]
/*A si le resultat du select n'est pas nul */
if ARRAY_SIZE@(vl_liste_eqt)>0 
{
	/*A pour chaque enregistrement */
	for  i=0 to ARRAY_SIZE@(vl_liste_eqt)-1
		vl_localisation.NumAuto 	= vl_liste_eqt[i,3]
		vl_localisation.PR 		= vl_liste_eqt[i,4]
		vl_localisation.sens_circulation = vl_liste_eqt[i,5]

		vl_type_PMVA [vl_liste_eqt[i,1]].Identifiant = "PMVA" ++ COM10_Localisation(vl_localisation)
		j = ARRAY_INDEX@ (ARRAY_COLUMN@ (vl_les_districts, TDO_NUMERO_DISTRICT),ITMA_COM_Site_PR(vl_localisation.NumAuto,
					vl_localisation.PR,"MTDO"))
		if j >= 0
		{
			vl_type_PMVA [vl_liste_eqt[i,1]].NumSite = vl_les_districts[j].numero
			vl_type_PMVA [vl_liste_eqt[i,1]].NomSite = vl_les_districts[j].code
		}
		vl_type_PMVA [vl_liste_eqt[i,1]].SiteGestion = vl_liste_eqt[i,8]
	next i

}
SET_SYSTEM_VAR@ (vg_type_PMVA, vl_type_PMVA)

/*A
 * Listes des PRV
 * --------------
 */
vl_parametres = NULL
vl_parametres[0].type	= SYB#INT1_
vl_parametres[0].data	= XDC_EQT_PRV
vl_parametres[0].output	= FALSE
	
vl_parametres[1].type	= SYB#INT1_	
vl_parametres[1].data	= NULL
vl_parametres[1].output	= FALSE

vl_parametres[2].type	= SYB#INT4_			' Conditions
vl_parametres[2].data	= 0
vl_parametres[2].output	= FALSE

vl_parametres[3].type	= SYB#INT4_			' Conditions niees
vl_parametres[3].data	= XDC_EQT_HS
vl_parametres[3].output	= FALSE
	
vl_parametres[4].type	= SYB#INT4_			' Exclusions
vl_parametres[4].data	= 0 
vl_parametres[4].output	= FALSE

vl_parametres[5].type	= SYB#INT4_			' Exclusions niees
vl_parametres[5].data	= 0	
vl_parametres[5].output	= FALSE

IF COM05_SQL_Procedure (XZAT01_Liste_Eqt_Dispo,
						vl_parametres,vl_resultats,C_MODULE) <> COM_OK
	RETURN (COM_NOK)

vl_liste_eqt = vl_resultats.select_results[0]
/*A si le resultat du select n'est pas nul */
if ARRAY_SIZE@(vl_liste_eqt)>0 
{
	/*A pour chaque enregistrement */
	for  i=0 to ARRAY_SIZE@(vl_liste_eqt)-1
		vl_localisation.NumAuto 	= vl_liste_eqt[i,3]
		vl_localisation.PR 		= vl_liste_eqt[i,4]
		vl_localisation.sens_circulation = vl_liste_eqt[i,5]
		vl_type_PRV[vl_liste_eqt[i,1]-1].autoroute= vl_localisation.NumAuto
		vl_type_PRV[vl_liste_eqt[i,1]-1].PR= vl_localisation.PR
		vl_type_PRV[vl_liste_eqt[i,1]-1].sens= vl_localisation.sens_circulation
		vl_type_PRV[vl_liste_eqt[i,1]-1].NumEqt = vl_liste_eqt[i,1]
	
		vl_type_PRV [vl_liste_eqt[i,1]-1].Identifiant = "PRV" ++ COM10_Localisation(vl_localisation)

		j = ARRAY_INDEX@ (ARRAY_COLUMN@ (vl_les_districts, TDO_NUMERO_DISTRICT),ITMA_COM_Site_PR(vl_localisation.NumAuto,
					vl_localisation.PR,"MTDO"))
		if j >= 0
		{
			vl_type_PRV [vl_liste_eqt[i,1]-1].NumSite = vl_les_districts[j].numero
			vl_type_PRV [vl_liste_eqt[i,1]-1].NomSite = vl_les_districts[j].code
		}
		vl_type_PRV [vl_liste_eqt[i,1]-1].SiteGestion = vl_liste_eqt[i,8]

next i
}
SET_SYSTEM_VAR@ (vg_type_PRV, vl_type_PRV)


/*A
 * Listes des eqt SAGA
 * --------------
 */
vl_parametres = NULL
vl_parametres[0].type	= SYB#INT1_
vl_parametres[0].data	= XDC_EQT_SAGA
vl_parametres[0].output	= FALSE
	
vl_parametres[1].type	= SYB#INT1_	
vl_parametres[1].data	= NULL
vl_parametres[1].output	= FALSE

vl_parametres[2].type	= SYB#INT4_			' Conditions
vl_parametres[2].data	= 0
vl_parametres[2].output	= FALSE

vl_parametres[3].type	= SYB#INT4_			' Conditions niees
vl_parametres[3].data	= XDC_EQT_HS
vl_parametres[3].output	= FALSE
	
vl_parametres[4].type	= SYB#INT4_			' Exclusions
vl_parametres[4].data	= 0 
vl_parametres[4].output	= FALSE

vl_parametres[5].type	= SYB#INT4_			' Exclusions niees
vl_parametres[5].data	= 0	
vl_parametres[5].output	= FALSE

IF COM05_SQL_Procedure (XZAT01_Liste_Eqt_Dispo,
						vl_parametres,vl_resultats,C_MODULE) <> COM_OK
	RETURN (COM_NOK)

vl_liste_eqt = vl_resultats.select_results[0]


/*A si le resultat du select n'est pas nul */
if ARRAY_SIZE@(vl_liste_eqt)>0 
{
	/*A pour chaque enregistrement */
	for  i=0 to ARRAY_SIZE@(vl_liste_eqt)-1
		vl_localisation.NumAuto 	= vl_liste_eqt[i,3]
		vl_localisation.PR 		= vl_liste_eqt[i,4]
		vl_localisation.sens_circulation = vl_liste_eqt[i,5]
		vl_type_SAGA[vl_liste_eqt[i,1]-1].autoroute= vl_localisation.NumAuto
		vl_type_SAGA[vl_liste_eqt[i,1]-1].PR= vl_localisation.PR
		vl_type_SAGA[vl_liste_eqt[i,1]-1].sens= vl_localisation.sens_circulation
		vl_type_SAGA[vl_liste_eqt[i,1]-1].NumEqt = vl_liste_eqt[i,1]
	
		/*on recupere en base le sous type d eqt SAGA*/

		vl_type_SAGA [vl_liste_eqt[i,1]-1].Identifiant = "Eqt SAGA" ++ COM10_Localisation(vl_localisation)

		j = ARRAY_INDEX@ (ARRAY_COLUMN@ (vl_les_districts, TDO_NUMERO_DISTRICT),ITMA_COM_Site_PR(vl_localisation.NumAuto,
					vl_localisation.PR,"MTDO"))
		if j >= 0
		{
			vl_type_SAGA [vl_liste_eqt[i,1]-1].NumSite = vl_les_districts[j].numero
			vl_type_SAGA [vl_liste_eqt[i,1]-1].NomSite = vl_les_districts[j].code
		}
		vl_type_SAGA [vl_liste_eqt[i,1]-1].SiteGestion = vl_liste_eqt[i,8]

next i
}

vl_parametres[0].type	= SYB#CHAR_
vl_parametres[0].data	= XDC_BASE_CFG
vl_parametres[0].output	= FALSE

IF COM05_SQL_Procedure
	( XZAO781_Lire_Eqt_SAGA, vl_parametres, vl_resultats ,C_MODULE) <> COM_OK
	RETURN (COM_NOK)
vl_liste_type = vl_resultats.select_results[0]

SET_SYSTEM_VAR@(vg_eqt_SAGA, vl_liste_type)

	/*B Pour chaque eqt SAGA, mettre a jour son sous type saga */
	FOR i = 0  TO (ARRAY_SIZE@ (vl_liste_type) - 1)
		j = COM45_IndexEnColonne (vl_type_SAGA, 0, vl_liste_type[i][0])
		IF (j >= 0) {
			vl_type_SAGA[j].TypeSAGA = vl_liste_type[i][1]	
		}
	NEXT i

SET_SYSTEM_VAR@ (vg_type_SAGA, vl_type_SAGA)

/*A
 * Listes des types de Picto
 * -------------------------
 */

/*A MAJ de vl_parametres */
vl_parametres[0].type	= SYB#CHAR_
vl_parametres[0].data	= XDC_BASE_CFG
vl_parametres[0].output	= FALSE

/*A Execution de la procedure XZAO75_Lire_Types_Picto	*/			
IF COM05_SQL_Procedure
	( XZAO75_Lire_Types_Picto, vl_parametres, vl_resultats ,C_MODULE) <> COM_OK
	RETURN (COM_NOK)
vl_liste_type = vl_resultats.select_results[0]

/*A MAJ de vl_parametres */
vl_parametres2[0].type	= SYB#CHAR_
vl_parametres2[0].data	= XDC_BASE_CFG
vl_parametres2[0].output	= FALSE

/*A MAJ de vl_parametres */
vl_parametres2[1].type	= SYB#CHAR_
vl_parametres2[1].data	= XDC_CHAINE_VIDE
vl_parametres2[1].output	= FALSE

/*A Execution de la procedure XZAO79_Lire_Liste_Picto	*/			
IF COM05_SQL_Procedure
	( XZAO79_Lire_Liste_Picto, vl_parametres2, vl_resultats2 ,C_MODULE) <> COM_OK
	RETURN (COM_NOK)

vl_liste_eqt = vl_resultats2.select_results[0]

/*A si le resultat du select n'est pas nul */
if ( ARRAY_SIZE@(vl_liste_type)>0 and ARRAY_SIZE@(vl_liste_eqt)>0 )
{
	/*A pour chaque enregistrement */
	for  i=0 to ARRAY_SIZE@(vl_liste_eqt)-1

		for  j=0 to ARRAY_SIZE@(vl_liste_type)-1
			if (vl_liste_eqt[i,4] = vl_liste_type[j,0])
			{
				/* Mettre a jour le nombre de ligne */
				vl_type_Picto [vl_liste_eqt[i,0]] = 	vl_liste_type[j,2]
			}
		next j
	next i


}
/*A sinon reset de la table liste_Picto */
else 
{
	vl_type_Picto [0,0] = ""
}
SET_SYSTEM_VAR@ (vg_type_Picto, vl_type_Picto)


RETURN (COM_OK)

ENDMACRO





/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*   Initialise les donnees publiques des equipements video.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TDO_Video
/*
* ARGUMENTS EN ENTREE : Aucun
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : COM_OK.
*
* CONDITION D'UTILISATION
*   ITMA_TDO
*
* FONCTION
*   Initialise les donnees des cameras, des magnetoscopes.
*
--------------------------------------------------------------------------- */

	VAR FORMAT COM_Donnees_Equipements	tl_donnees_eqts
	VAR FORMAT TDO_Equipement		tl_equipements
	VAR					tl_cameras

	VAR FORMAT SQL_Procedure_Params@	vl_parametres
	VAR FORMAT SQL_Procedure_Result@	vl_resultats

	VAR	vl_site, vl_site_tous_eqt

	VAR	vl_cr
	VAR	i, j

vl_site = SYSTEM_VAR@ (vg_site)


	/*A
	** Listes des cameras
	** ------------------
	*/

	vl_site_tous_eqt = vl_site
	IF (vl_site_tous_eqt = XDC_CI) {
		vl_site_tous_eqt = NULL
	}
	vl_parametres = COM15_Parametres_Requete ( {
		{ FALSE,	SYB#INT1_,	XDC_EQT_CAM },		' type d'equipement
		{ FALSE,	SYB#INT1_,	vl_site_tous_eqt },	' site des equipements
		{ FALSE,	SYB#INT4_,	XDC_EQT_HS },		' inclus
		{ FALSE,	SYB#INT4_,	XDC_EQT_NON_HS },	' inclus
		{ FALSE,	SYB#INT4_,	0 },			' exclus
		{ FALSE,	SYB#INT4_,	0 }			' exclus
	} )
	vl_cr = COM05_SQL_Procedure (XZAT010_Liste_Eqt_Dispo, vl_parametres, vl_resultats, C_MODULE)
	tl_donnees_eqts = vl_resultats.select_results[0]

	tl_equipements = { }
	FOR i = 0  TO (ARRAY_SIZE@ (tl_donnees_eqts) - 1)
		tl_equipements[i].numero	= tl_donnees_eqts[i].numero
		tl_equipements[i].nom		= tl_donnees_eqts[i].nom
		tl_equipements[i].autoroute	= tl_donnees_eqts[i].autoroute
		tl_equipements[i].PR		= tl_donnees_eqts[i].PR
		tl_equipements[i].sens		= tl_donnees_eqts[i].sens
		tl_equipements[i].site_gestion	= tl_donnees_eqts[i].sitegestion
		tl_equipements[i].dispo		= tl_donnees_eqts[i].dispo
	NEXT i


	/*B
	** Recherche des codes cameras
	** ---------------------------
	*/

	/* extraire toutes les cameras */
	vl_parametres = COM15_Parametres_Requete ( {
		{ FALSE,	SYB#CHAR_,	XDC_BASE_CFG },		' base CFG
		{ FALSE,	SYB#INT2_,	1 },			' numero min
		{ FALSE,	SYB#INT2_,	NULL },			' numero max
		{ FALSE,	SYB#CHAR_,	XDC_CHAINE_VIDE },	' code camera
		{ FALSE,	SYB#INT1_,	NULL }			' autoroute
	} )

	vl_cr = COM05_SQL_Procedure (XZAO18_Liste_Cameras, vl_parametres, vl_resultats, C_MODULE)
	tl_cameras = vl_resultats.select_results[0]

	/*B Pour chaque camera du secteur, mettre a jour son code */
	FOR i = 0  TO (ARRAY_SIZE@ (tl_equipements) - 1)
		j = COM45_IndexEnColonne (tl_cameras, 0, tl_equipements[i].numero)
		IF (j >= 0) {
			tl_equipements[i].info = tl_cameras[j][1]	' code_camera
		}
	NEXT i


	/*A memorisation des cameras en donnees publiques */
	SET_SYSTEM_VAR@ (vg_les_cameras, tl_equipements)


/*A
** Listes des magnetoscopes DU SITE (au CI aussi)
** ----------------------------------------------
*/

vl_cr = ITMA_COM_Lire_Equipements (XDC_EQT_MAG, vl_site,
				   XDC_EQT_HS, XDC_EQT_NON_HS, 0, 0,
				   tl_donnees_eqts, C_MODULE)
	tl_equipements = { }
	FOR i = 0  TO (ARRAY_SIZE@ (tl_donnees_eqts) - 1)
		tl_equipements[i].numero	= tl_donnees_eqts[i].numero
		tl_equipements[i].nom		= tl_donnees_eqts[i].nom
		tl_equipements[i].autoroute	= tl_donnees_eqts[i].autoroute
		tl_equipements[i].PR		= tl_donnees_eqts[i].PR
		tl_equipements[i].sens		= tl_donnees_eqts[i].sens
		tl_equipements[i].site_gestion	= tl_donnees_eqts[i].sitegestion
		tl_equipements[i].dispo		= tl_donnees_eqts[i].dispo
	NEXT i

/*A memorisation des magnetoscopes en donnees publiques */
SET_SYSTEM_VAR@ (vg_les_magnetoscopes, tl_equipements)

RETURN (COM_OK)

ENDMACRO





/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*   Initialise les donnees publiques pour MTFM.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TDO_MTFM
/*
* ARGUMENTS EN ENTREE : Aucun
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : COM_OK.
*
* CONDITION D'UTILISATION
*   ITMA_TDO
*
* FONCTION
*   Initialise vg_niv_diff contenant les niveaux a proposer.
*
--------------------------------------------------------------------------- */

VAR	i, j, vl_F_tpm, vl_taille, vl_taille2, vl_ligne
VAR	FORMAT TDO_NIV_LIB vl_F_mode 
VAR	vl_indice, vl_chemin

VAR  vl_rgb

VAR	 vl_F_troncon_TFM, vl_F_zone_diff, vl_F_periode_diff, vl_F_periode_diffTA
VAR	vl_couleur


/*A Chargement du fichier de config mode_diffusion
*   ------------------------------------------ */

vl_chemin = SYSTEM_VAR@( vg_repertoire_migrazur ) ++ COM_SOUS_REP_NTFM

vl_F_tpm = NULL
vl_F_tpm = READ_ASCII_FILE@(vl_chemin ++ "/troncon_TFM.txt")
vl_taille = ARRAY_SIZE@(vl_F_tpm) -1
vl_indice=0
for i = 1 to vl_taille
        vl_ligne = ARRAY_FROM_STRING@(vl_F_tpm[i],",")
        vl_taille2 = ARRAY_SIZE@(vl_ligne) -1
        for j = 0 to vl_taille2
                vl_F_troncon_TFM[vl_indice,j]=TRIM@(TABS_TO_SPACES@(vl_ligne[j]))
        next j
	if ( vl_taille2 <> 0 )
		vl_indice=vl_indice+1
next i

SET_SYSTEM_VAR@ (vg_troncon_TFM, vl_F_troncon_TFM)


vl_F_tpm = NULL


vl_F_tpm = READ_ASCII_FILE@(vl_chemin ++ "/zones_diffusion.txt")
vl_taille = ARRAY_SIZE@(vl_F_tpm) -1
vl_indice=0
for i = 1 to vl_taille
        vl_ligne = ARRAY_FROM_STRING@(vl_F_tpm[i],",")
        vl_taille2 = ARRAY_SIZE@(vl_ligne) -1
        for j = 0 to vl_taille2
                vl_F_zone_diff[vl_indice,j]=TRIM@(TABS_TO_SPACES@(vl_ligne[j]))
        next j
	if ( vl_taille2 <> 0 )
		vl_indice=vl_indice+1
next i
SET_SYSTEM_VAR@ (vg_zone_diff, vl_F_zone_diff)

vl_F_tpm = NULL


vl_F_tpm = READ_ASCII_FILE@(vl_chemin ++ "/periode_diffusion.txt")
vl_taille = ARRAY_SIZE@(vl_F_tpm) -1
vl_indice=0
for i = 1 to vl_taille
        vl_ligne = ARRAY_FROM_STRING@(vl_F_tpm[i],",")
        vl_taille2 = ARRAY_SIZE@(vl_ligne) -1
        for j = 0 to vl_taille2
                vl_F_periode_diff[vl_indice,j]=TRIM@(TABS_TO_SPACES@(vl_ligne[j]))
        next j
	if ( vl_taille2 <> 0 )
		vl_indice=vl_indice+1
next i
SET_SYSTEM_VAR@ (vg_periode_diff, vl_F_periode_diff)


vl_F_tpm = NULL

vl_F_tpm = READ_ASCII_FILE@(vl_chemin ++ "/periode_diffusion_TA.txt")
vl_taille = ARRAY_SIZE@(vl_F_tpm) -1
vl_indice=0
for i = 1 to vl_taille
        vl_ligne = ARRAY_FROM_STRING@(vl_F_tpm[i],",")
        vl_taille2 = ARRAY_SIZE@(vl_ligne) -1
        for j = 0 to vl_taille2
                vl_F_periode_diffTA[vl_indice,j]=TRIM@(TABS_TO_SPACES@(vl_ligne[j]))
        next j
	if ( vl_taille2 <> 0 )
		vl_indice=vl_indice+1
next i
SET_SYSTEM_VAR@ (vg_periode_diffTA, vl_F_periode_diffTA)



vl_F_tpm = NULL

/*A Init des couleurs */

vl_rgb=0,0,0
vl_couleur[0]="noir",vl_rgb
vl_rgb=255,0,50
vl_couleur[1]="rouge",vl_rgb
vl_rgb=0,150,0
vl_couleur[2]="vert",vl_rgb
vl_rgb=0,0,255
vl_couleur[3]="bleu",vl_rgb
SET_SYSTEM_VAR@ (vg_couleur,vl_couleur)


/*A Chargement du fichier de config mode_diffusion
*   ------------------------------------------ */
vl_F_tpm = NULL
vl_F_mode[0].niveau=-1
vl_F_mode[0].libelle=""
IF FILE_EXISTS@(vl_chemin ++ "/mode_diffusion.txt" )
 {
/* 	vl_F_tpm = READ_ASCII_FILE@(vl_chemin ++ "/mode_diffusion.txt")
	vl_taille = ARRAY_SIZE@(vl_F_tpm) -1
	vl_indice=1
	FOR i = 1 to vl_taille
        vl_ligne = ARRAY_FROM_STRING@(vl_F_tpm[i],",")
        vl_taille2 = ARRAY_SIZE@(vl_ligne) -1
		if ( vl_taille2 <> 0 )
		{
                vl_F_mode[vl_indice].niveau=TRIM@(TABS_TO_SPACES@(vl_ligne[TDO_NIVEAU_TFM]))+0
		vl_F_mode[vl_indice].libelle=TRIM@(TABS_TO_SPACES@(vl_ligne[TDO_LIB_NIV]))
		vl_indice=vl_indice+1
		}
	NEXT i*/
vl_F_tpm = READ_ASCII_FILE@(vl_chemin ++ "/mode_diffusion.txt")
vl_taille = ARRAY_SIZE@(vl_F_tpm) -1
vl_indice=0
for i = 1 to vl_taille
        vl_ligne = ARRAY_FROM_STRING@(vl_F_tpm[i],",")
        vl_taille2 = ARRAY_SIZE@(vl_ligne) -1
        for j = 0 to vl_taille2
                vl_F_mode[vl_indice,j]=TRIM@(TABS_TO_SPACES@(vl_ligne[j]))
        next j
	if ( vl_taille2 <> 0 )
		vl_indice=vl_indice+1
next i

 }


SET_SYSTEM_VAR@ (vg_niv_diff, vl_F_mode)

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Retourne l'indicateur d'ordre des PR sur une autoroute donnée.
*  L'autoroute peut etre specifiee par son numero ou son nom.
*  Le resultat n'est significatif que si l'autoroute est valide.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION TDO_Ordre_PR (va_autoroute)

/*
* ARGUMENTS EN ENTREE :
*   va_autoroute      : NUMERO OU NOM de l'autoroute dont on recherche l'ordre des PR.
*
* ARGUMENTS EN SORTIE : Aucune
*
*
* VALEUR RETOURNEE    : XDC_PR_NOR ou XDC_PR_INV, sens des PR sur l'autoroute.
*
* CONDITION D'UTILISATION
*   Le parametre doit etre le numero ou le nom valide d'une autoroute.
*
* FONCTION
*
*  Retourne l'ordre "notoire" des PR sur l'autoroute (pour efficacite).
*  En toute rigueur, devrait consulter la table des autoroutes.
*
---------------------------------------------------------------------------- */

IF IS_NUMBER@ (va_autoroute) {
	IF (va_autoroute = CM_NUM_AUT_A57) {
		RETURN (XDC_PR_INV)
	} ELSE {
		RETURN (XDC_PR_NOR)
	}
}

IF IS_STRING@ (va_autoroute) {
	IF (UPPERCASE@ (TRIM@ (va_autoroute)) = "A57") {
		RETURN (XDC_PR_INV)
	} ELSE {
		RETURN (XDC_PR_NOR)
	}
}

RETURN (NULL)

ENDFUNCTION




/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*   Determine le numero d'echangeur correspondant a un identifiant
*   (numero / nom) de sortie d'autoroute sur une autoroute donnee
*   et comportant une bretelle de sortie ou d'entree dans un sens donne.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION TDO_Echangeur_En_Sortie (va_sortie, va_autoroute, va_sens)

/*
* ARGUMENTS EN ENTREE :
*   va_sortie         : identifiant de la sortie d'autoroute
*   va_autoroute      : numero de l'autoroute ou se situe la sortie
*   va_sens           : sens de recherche d'une bretelle d'entree / sortie
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : le numero d'echangeur correspondant, NULL si aucun.
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Recherche dans la table des echangeurs celui qui correspond aux criteres.
*   Si le critere de sens indique une entree, requiert une bretelle d'entree
*   sinon selectionne un echangeur comportant une bretelle de sortie.
*
--------------------------------------------------------------------------- */

VAR	vl_sortie, vl_sens
VAR	i

/*A Si un sens de circulation normal est indique, rechercher une bretelle de sortie */
vl_sens = va_sens
IF (va_sens = XDC_SENS_1) { vl_sens = XDC_SORTIE_SENS_1 }
IF (va_sens = XDC_SENS_2) { vl_sens = XDC_SORTIE_SENS_2 }

vl_sortie = TRIM@ (va_sortie)

IF (va_sortie <> "") {
	/*B Lire dans l'environnement la liste des echangeurs si elle n'est pas disponible */
	IF IS_NULL@ (tm_echangeurs) {
		tm_echangeurs = SYSTEM_VAR@ (vg_les_echangeurs)
	}

	/*A rechercher dans la table des echangeurs */
	FOR i = 0  TO (ARRAY_SIZE@ (tm_echangeurs) - 1)
		/*A celui situe sur l'autoroute indiquee, dont la sortie porte le nom demande */
		IF (tm_echangeurs[i].autoroute = va_autoroute)  AND  (tm_echangeurs[i].sortie = vl_sortie) {
			/*A et comportant une sortie dans le sens indique */
			IF ( (vl_sens = XDC_SORTIE_SENS_1  AND  tm_echangeurs[i].PR_sortie_sens1 > 0)  OR
			     (vl_sens = XDC_SORTIE_SENS_2  AND  tm_echangeurs[i].PR_sortie_sens2 > 0)  OR
			     (vl_sens = XDC_ENTREE_SENS_1  AND  tm_echangeurs[i].PR_entree_sens1 > 0)  OR
			     (vl_sens = XDC_ENTREE_SENS_2  AND  tm_echangeurs[i].PR_entree_sens2 > 0) )
			{
				RETURN (tm_echangeurs[i].numero)
			}
		}
	NEXT i
}

RETURN (NULL)

ENDFUNCTION




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Determine le numero de l'echangeur situe a une localisation donnee,
*  a la condition qu'il comporte un acces du type eventuellement specifie.
*
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION TDO_Echangeur_Situe_En (va_autoroute, va_PR, va_sens, va_acces)

/*
* ARGUMENTS EN ENTREE :
*   va_autoroute      : numero de l'autoroute ou l'echangeur est recherche
*   va_PR             : Pr de localisation
*   va_sens           : contrainte de sens de l'echangeur recherche
*   va_acces          : contrainte d'acces de l'echangeur recherche
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : le numero d'echangeur correspondant, NULL si aucun.
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Recherche dans la table des echangeurs celui qui correspond aux criteres.
*
--------------------------------------------------------------------------- */

	VAR	vl_entree_s1, vl_sortie_s1
	VAR	vl_entree_s2, vl_sortie_s2
	VAR	i

/*B Lire dans l'environnement la liste des echangeurs si elle n'est pas disponible */
IF IS_NULL@ (tm_echangeurs) {
	tm_echangeurs = SYSTEM_VAR@ (vg_les_echangeurs)
}

FOR i = 0  TO (ARRAY_SIZE@ (tm_echangeurs) - 1)
	/*A Si un echangeur est situe sur l'autoroute et a la distance specifiees */
	IF (tm_echangeurs[i].autoroute = va_autoroute)  AND  (tm_echangeurs[i].PR = va_PR)
	{
		vl_entree_s1 = tm_echangeurs[i].PR_entree_sens1
		vl_sortie_s1 = tm_echangeurs[i].PR_sortie_sens1
		vl_entree_s2 = tm_echangeurs[i].PR_entree_sens2
		vl_sortie_s2 = tm_echangeurs[i].PR_sortie_sens2

		/*A Filtrer selon l'acces impose, disqualifiant les entrees ou les sorties */
		IF (va_acces = XDC_ACCES_SORTIE)  OR  (va_sens = XDC_SENS_SORTIE_NORD)  OR  (va_sens = XDC_SENS_SORTIE_SUD)
		{
			vl_entree_s1 = 0
			vl_entree_s2 = 0
		}
		IF (va_acces = XDC_ACCES_ENTREE)  OR  (va_sens = XDC_SENS_ENTREE_NORD)  OR  (va_sens = XDC_SENS_ENTREE_SUD)
		{
			vl_sortie_s1 = 0
			vl_sortie_s2 = 0
		}

		/*A Filtrer selon le sens indique */
		IF (va_sens = XDC_SENS_NORD)  OR  (va_sens = XDC_SENS_SORTIE_NORD)  OR  (va_sens = XDC_SENS_ENTREE_NORD)
		{
			vl_entree_s1 = 0
			vl_sortie_s1 = 0
		}
		IF (va_sens = XDC_SENS_SUD)  OR  (va_sens = XDC_SENS_SORTIE_SUD)  OR  (va_sens = XDC_SENS_ENTREE_SUD)
		{
			vl_entree_s2 = 0
			vl_sortie_s2 = 0
		}

		/*A Si un acces correspond aux criteres imposes alors l'echangeur est eligible */
		IF (vl_entree_s1 + vl_entree_s2 + vl_sortie_s1 + vl_sortie_s2 > 0) {
			RETURN (tm_echangeurs[i].numero)
		}
	}
NEXT i

RETURN (NULL)

ENDFUNCTION
