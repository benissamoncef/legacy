/*E*/
/* Fichier : ITMA_TLT_Liste_FMC_A_Traiter.am
-------------------------------------------------------------------------------
* STERIA *  PROJET MIGRAZUR
-------------------------------------------------------------------------------
* SOUS-SYSTEME  GESIHM
-------------------------------------------------------------------------------
* MODULE ITMA_TLT * FICHIER ITMA_TLT_Liste_FMC_A_Traiter.am
-------------------------------------------------------------------------------
* DESCRIPTION DU MODULE :
*
* Liste des Fiches Main Courante a traiter.
*
*   Cf. DCG 2.4.49
*
-------------------------------------------------------------------------------
* HISTORIQUE :
*
* Lecrivain	07 Oct 1994	: Creation
* Guilhou		13 oct 1994	: inclusion fichiers _ax.h			V1.6
* Lecrivain	17 Oct 1994	: Traiter un "poke_" en verrouillage IHM   V1.7
* Guilhou		23 nov 1994	: ajout mode XDC_FMC_ETA_TRAI 		V1.8
* Noel		06 Dec 1994	: Changement position boite de dialogue 		V1.12
* Guilhou		19 dec 1994	: correction test sur ligne selectionnee   V1.13
* Guilhou		20 dec 1994	: ajout du type dans les parametres du 
*						   poke envoye a ITMA_TLV			V1.14
* Guilhou		21 dec 1994	: modif reception d'un reveil			V1.14
* Lecrivain 23 Dec 1994 : Changt. localisation des fichiers pictogrammes   V1.15
* Guilhou		10 jan 1995	: traitement picto de surcharge		V1.19
* Lecrivain 13 Fev 1995 : Ajout du poke de demande d'ouverture FMC         V1.24
* Torregrossa 26 Jui 1995       : Ajout auto reveils                       V1.26
* Torregrossa 17 Jul 1995       : Suppression test sur -1 auto reveils     V1.28
* Guilhou		04 aou 1995	: modif pokes de surcharge			V1.29
* Torregrossa 12 Oct 1995       : Ajout bouton d'ouverture de fmc a partir 
*                                 de la boite de dialogue d'affichage des reveils
*                                 d'une fmc                                V1.31
* Torregrossa 24 Jan 1996       : Reinit var liste des textes des reveils V1.32
* Torregrossa 25 Jan 1996       : Modif C_LIB_FMC_OUVERTE par COM_LIB_FMC_OUVERTE V1.33
* Noel		06 Mars 1996	: Mise en place d'une reinit du reveil T1 si le 
*					precedent n'a pas ete acquitte. (DEM 743)	V1.34
* Torregrossa 07 Mai 1996       : Correction du declenchemnt du calcul pour fmc en consultation
*                                 (DEM 1103) V1.36
* Niepceron	27 Sep 1996	: Mise en place de l'acquittement sur le poste voisin (dem/424) v1.37
* ???		12 nov 1996	: rien 1.38
* Guilhou	12 nov 1996	: optimisation legere 	1.39
* Torregrossa	29 nov 1996	: tri de la liste des fmc a traiter (680) V1.40-1.41
* Niepceron	24 jun 1997	: Correction acq reveil V1.42 dem/1460
* Guilhou	21 jan 1998	: appel XZAE148 1.43
* Guilhou	21 jan 1998	: verrrou sur utilisation xzae148	1.44
* Torregrossa	25 fev 1998	: recuperation des droits d'enrichir en newtask (1579) 1.45
* Guilhou	27 fev 1998 	: correction appel macro recup droit d'enrichir 1.46
* Torregrossa	05 mar 1998	: Passage par COM43_SQL_CONNECT pour connection sur serveur distant (1581) 1.47
* Niepceron	21 Jan 1999	: decalage vers le bas de la fenetre pour demasquer  les icones (1727) 1.48
* Niepceron     03 mar 1999     : suppression d'un info_message de trace 1.49
* Guilhou	18 fev 2000	: gestion amelioree des clicks 1.50
* Guilhou	21 mar 2000	: FMC operateur dans un bloc a part 1.51
* Guilhou	27 avr 2000	: traitement du reveil vide (SAE 90) 1.52
* Niepceron	14 mar 2005	: Ajout ligne blanche apres FMC evt du site 1.54 DEM426
* Niepceron	6  avr 2005	: Ajout ligne blanche apres FMC evt du site 1.55 DEM426
* Niepceron	7  avr 2005	: Ajout ligne blanche apres FMC evt du site 1.57 DEM426
* Lecrivain	20 Aou 2008	: Reception acquittements: maj icones sans auto-poke v1.58
* Lecrivain	21 Aou 2008	: "Securisation" suppr. reveils; correction test index Fmc sur ouverture v1.59
* Lecrivain	22 Aou 2008	: Envoi acquitt. reveil Fmc � tous les postes operateur du site (DEM 805) 1.60
* Lecrivain	25 Aou 2008	: Eviter raf. liste (fin surcharge,ouvr. fmc); plus de liste de textes reveils 1.61
* Lecrivain	27 Aou 2008	: Inhiber la selection d'une Fmc durant la reinitialisation de la liste (DEM 721) 1.62
* Lecrivain	04 Sep 2008	: Reaffichage liste evenements : sans retour en debut de liste 1.63
* Lecrivain	04 Sep 2008	: Gestion poke VALIDATION_FMC pour futur remplacement MTLT("0|0",evt,cle) 1.64
* Lecrivain	09 Sep 2008	: Annuler toute selection dans la liste durant sa reinitialisation 1.65
* Lecrivain	28 Aou 2008 ...	: Memorisation pokes recus et traitement periodique sauf Fmc urgente (DEM 721) 1.66
* Lecrivain	24 Sep 2008	: Ajout demande de relecture de la liste sur message de rafraichisement 1.67
* Lecrivain	30 Sep 2008	: Retour a une relecture systematique de la liste sur message de rafraichisement 1.68
* Lecrivain	14 Oct 2008	: Correction gestion nouvelles donnees sur selection Fmc et fiche deja ouverte (DEM 820) 1.69
* Lecrivain	15 Oct 2008	: Gestion uniformisee du pictogramme attache a une Fmc 1.70
* Lecrivain	16 Oct 2008	: Suppression de l'emission de son en cas de nouveaux reveils tous acquittes (DEM 820) 1.71
* Lecrivain	16 Oct 2008	: Suppression de l'envoi de l'acquittement des reveils a son propre poste 1.72
* Lecrivain	16 Oct 2008	: Simple renommage et formatage 1.73
* Lecrivain	17 Oct 2008	: Correction gestion des reveils relatifs au droit d'enrichir 1.74
* Lecrivain	17 Oct 2008	: Optimisation gestion donnees precedentes a la relecture de la liste 1.75
* Lecrivain	17 Oct 2008	: Gestion du pictogramme des donnees actuelles a l'acquittement d'un reveil (DEM 820) 1.76
* Lecrivain	20 Oct 2008	: Ajout de traces supplementaires 1.77
* Lecrivain	23 Oct 2008	: Marquage ouverture fiche ASAP; liste relue a la validation plutot qu'a la fermeture 1.78
* Lecrivain	28 Oct 2008	: Gestion complete des droits d'enrichir (entier > 1 pour les bouchons) (DEM 824) 1.79
* Lecrivain	27 Nov 2008	: Gestion de la liste complete des reveils pour visualisation au menu (DEM 847) 1.80
* JPL		02/12/2008	: Tri plus fin de la liste des Fmc: espacement des groupes (DEM 833) 1.81
* JPL		03/12/2008	: Ne plus inserer une ligne separatrice entre les sous-groupes (DEM 833) 1.82
* JPL		21/01/2009	: Mise a jour droit d'enrichir Fmc sur message de reservation / restitution (DEM 848) 1.83
* JPL		17/02/2009	: Version intermediaire, identique a la precedente 1.84
* JPL		18/02/2009	: Conserver et traiter periodiquement les reveils sur Fmc inconnues (DEM 867) 1.85
* JPL		29/06/2009	: FMC 'Veh. Marche Arriere' dans sous-groupe Accident (en local ET distant) (DEM 891) 1.86
* JPL		03/09/2009	: Affichage d'un reveil de couleur differente sur reveil de creation FMC (DEM 903) 1.87
* JPL		04/09/2009	: Filtrage des evenements "double clic" sur la table des FMC 1.88
* JPL		15/09/2009	: Memorisation des noms des postes du site pour acquittement des reveils 1.89
* JPL		23/09/2010	: Placement des nouvelles Fmc "Zone de stockage" dans leur groupe (DEM 942) 1.90
* PNI		07/12/2012	: Modif des tailles des colonnes de la liste 1.91
* AD		10/10/2014	: Sur selection FMC avec reveil, acquittement et ouverture directe FMC (DEM 1101)  1.92
* NDE		23/07/2015	: Pr�sentation sur deux fen�tres pour le CI (DEM 1138) 1.93
* NDE		31/08/2015	: Correction gestion des messages d'erreurs (DEM 1144) 1.94
* JPL		07/09/2015	: Lecture des postes du site au demarrage, pour envoi d'acquittement (DEM 1138 complement) 1.95
* JPL		22/09/2015	: Preciser liste Evt/Opr dans messages reveil On/Off au menu textuel (DEM 1138 complement) 1.96
* PNI		26/01/2017	: Pr�sentation sur deux fen�tres pour tous les sites 1.97 (DEM1150)
* PNI		09/08/17	: Sur selection reveil sur FMC op�rateur, alors affichage de la visu des reveils DEM1235 1.98
* LCL		19/06/2018	: Ajout riveil gris sur nouvelle FMC GABEB DEM1283 1.99 1.100
* JPL		09/04/2019	: Support de trois exemplaires de listes des FMC � traiter (DEM 1325)  1.101
* LCL   22/04/20        : MOVIS Ajout site local pilotage DEM-SAE93
* PNI         26/03/21 : Suppression de l'appel a XZAE148 r�cup�ration des droits d'enrichir au PC 
* JPL		02/07/2021	: Nommage different des fenetres de listes FMC (SAE-310)  (BRANCHE DE DEV 1.103.1, puis 1.104)
--------------------------------------------------------------------------- */

INCLUDE	"dbase_.am"

INCLUDE	"xzic_ax.h"
INCLUDE "xdc_ax.h"
INCLUDE "xzaf01sp.h"
INCLUDE "xzaec_ax.h"

INCLUDE	"ITMA_COM.h"
INCLUDE	"ITMA_TDO.h"

INCLUDE	"ITMA_TLV.h"
INCLUDE	"ITMA_TAR.h"
INCLUDE	"itre_son_ax.h"

INCLUDE	"xzao111sp.h"
INCLUDE	"xzae17sp.h"
INCLUDE	"xzae148sp.h"



DEFINE	C_MODULE	"MTLT"			' Nom du module



DEFINE	CM_PERIODE_TRAIT_MSG	3		' Periode de traitement des messages en attente, en secondes
DEFINE	CM_DELAI_1s		1		' Delai d'inactivite maximale, en secondes



/*A
 * Definition des codes et des libelles
 * d'erreurs specifiques au module
 * ------------------------------------
 */

DEFINE	C_ERR_IHM			1

DEFINE	C_LIB_FMC_INCONNUE	"Cet evenement ne vous est pas destine"


/*A
 * Types d'auto reveils, tels que decrits en fichier de configuration
 * ------------------------------------------------------------------
 */

DEFINE	C_CONFIG_REV_NUM_TYPE	0	' colonne du type en fichier de configuration

DEFINE	C_PAS_REVEIL	0	' aucun reveil sur la Fmc
DEFINE	C_T1		1	' reveil de type T1
DEFINE	C_T2		2	' reveil de type T2
DEFINE	C_T3		3	' reveil de type T3
DEFINE	C_T4		4	' reveil de type T4
DEFINE	C_T5		5	' reveil de type T4 pour differencier message de T4

/*A
 * Types d'evenements entrainant la modification des reveils automatiques
 * ----------------------------------------------------------------------
 */

DEFINE	C_FMC_CREEE		1
DEFINE	C_FMC_VALIDEE		2
DEFINE	C_FMC_OUVERTE		3
DEFINE	C_FMC_ENRICHIE		4
DEFINE	C_FMC_PAS_ENRICHIR	5



/*A
 * Fichier de configuration des auto reveils
 * -----------------------------------------
 */

DEFINE	C_FIC_AUTO_REVEIL	"ITMA_TLT_reveils.syn"


/*A
 * Nombre maximal de textes de reveils memorises pour chaque Fmc
 * -------------------------------------------------------------
 */

DEFINE	C_MAX_REVEILS	5


/*A
 * Noms des images digitalisees particularisant
 *     les caracteristiques d'un evenement
 * --------------------------------------------
 */

DEFINE	C_PICTO_REVEILLE			"pix_reveil"
DEFINE	C_PICTO_REVEIL_NOUVELLE_FMC		"pix_reveil_rouge"
DEFINE	C_PICTO_EN_PREV_ENRICHIR		"pix_crayon_gris"
DEFINE	C_PICTO_EN_COURS_ENRICHIR		"pix_crayon_vert"
DEFINE	C_PICTO_FIN_ENRICHIR			"pix_crayon_rouge"
DEFINE	C_PICTO_EN_PREV_PAR_DEFAUT		"pix_designer_gris"
DEFINE	C_PICTO_EN_COURS_PAR_DEFAUT		"pix_designer_vert"
DEFINE	C_PICTO_FIN_PAR_DEFAUT			"pix_designer_rouge"
DEFINE	C_PICTO_SURCHARGE			"pix_designer"
DEFINE	C_PICTO_DATEX				"pix_designer_datex"
DEFINE	C_PICTO_DATEX_FIN			"pix_designer_datex_fin"
DEFINE	C_PICTO_REVEIL_GRIS			"pix_reveil_gris"



/*A
 * Description du format des donnees affichees
 * -------------------------------------------
 */

FORMAT	TLT_Evenement
	numero,					' Numero evenement
	createur,				' Site createur (3 car)
	type,					' Type evenement (25 car)
	date_debut,				' Date debut (16 car)
	localisation				' Localisation event. (28 car)


/*A
 * Description du format des donnees internes
 * ------------------------------------------
 */

FORMAT	TLT_Info_Evenement
	FORMAT COM_Intitule_FMC info_evt,	' Informations evenement
	enrichir,				' Droits d'enrichir (Fmc, plus tete si bouchon SUR LE SITE)
	enrichisseur,				' Poste qui edite la Fmc a un instant donne
	nb_reveils,				' Nombre de reveils
	reveil_nouvelle_fmc,			' Indicateur de reveil "Nouvelle Fmc"
	type_autoreveil,			' Type d'autoreveil (C_T1, C_T2, C_T3, C_T4)
	date_reveil,				' date de reveil
	heure_debut,				' heure de debut fmc (en nombre de secondes)
	heure_debut_prevu,			' heure de debut prevu fmc (en nombre de secondes)
	heure_fin,				' date de fin fmc (en nombre de secondes)
	heure_fin_prevue,			' date de fin prevue fmc (en nombre de secondes)
	datex					' FMC datex ?


/*A
 * Description du format de la config des reveils
 * ------------------------------------------------
 */

FORMAT	TLT_Config_Reveil
	type_fmc,
	T1,
	T2,
	T3,
	T4


/*A
 * Format des informations de statut de la liste d'evenements
 * ----------------------------------------------------------
 */

FORMAT	TLT_Statut_Liste
	rafraichie,
	reveils



VAR FORMAT TLT_Evenement tm_evts		' Table des evenements affichee
VAR	tm_pictos				' Noms des pictogrammes
VAR	tm_titres				' Titres colonnes de la table

VAR FORMAT TLT_Info_Evenement tm_infos		' Table des infos internes
VAR	tm_reveils				' Listes des textes des reveils visualises, par Fmc

VAR FORMAT TLT_Reveil_Fmc tm_listeReveils	' Liste complete des reveils des Fmc visualisees (pour MTMT)
VAR FORMAT TLT_Reveil_Fmc tm_reveils_sans_fmc	' Liste des reveils recus sur des Fmc non visualisees


VAR	tm_surcharge				' Evenement traite en surcharge par le CI
VAR	vm_mode_formation			' Mode formation

VAR	vm_date_traitt_msg			' Date dernier traitement des messages en attente

VAR	FORMAT TLT_Config_Reveil tm_config_reveils	' Table de configuration des reveils
VAR	FORMAT TDO_Type_FMC	tm_types_FMC

VAR	vm_site						' Le site local
VAR	vm_mon_poste					' Le numero de mon poste operateur
VAR	vm_mon_numero_oper				' Le numero de l'operateur pour la session

VAR	FORMAT TDO_Dictionnaire	tm_postes_du_site	' Table des postes du site local

VAR	vm_fenetre				' La fenetre du module
VAR	vm_numero_liste				' Identifie la liste de FMC courante

VAR FORMAT TLT_Info_Evenement tm_infos_old
VAR	tm_reveils_old


/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Visualisation de la liste des fiches Main Courante a traiter
*     pour le poste operateur.
*  Sur reception d'un signal de modification, rafraichissement de la liste.
*  Sur reception d'un signal de reveil pour une fmc,
*     affichage d'une alarme visuelle et emission d'un son.
*  Sur selection d'une Fmc dans la liste, ouverture de la fiche Main Courante.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TLT_Liste_FMC_A_Traiter (va_appelant,va_horodate,va_numero_liste)

/*
* ARGUMENTS EN ENTREE :
*  va_appelant        : Nom de la macro Applix ayant invoque la presente.
*  va_horodate        : Horodate de l'etape de scenario en formation.
*  va_numero_liste    : Identifiant de la liste present�e � l'�cran.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : Indefini
*
* CONDITION D'UTILISATION
*   Activation par MTMT.
*
* FONCTION
*   Lit en base de donnees puis affiche la liste des fiches Main Courante
*   a traiter associee au poste operateur.
*   Se met en attente d'un signal (message d'une autre tache) de changements
*   et sur occurrence du signal, reinitialise la liste des fiches.
*   Sur reception de messages, edite la liste (ajoute ou supprime une fiche)
*   ou visualise la liste des elements Main Courante.
*   Ne termine que sur reception d'un message de fin.
*
---------------------------------------------------------------------------- */

    VAR     vl_objet_selecte			' L'objet courant de la fenetre
    VAR     vl_evenement			' L'evenement survenu sur l'objet
    VAR     vl_les_messages_acceptes		' Pour reception de signaux
    VAR     vl_la_fenetre_est_active
    VAR     vl_installer_traitement_erreur

    VAR     vl_poke				' Type de message recu d'un autre module
    VAR     vl_params				' Parametres du message
    VAR     vl_args_msg				' Differents elements du message
    VAR     vl_texte				' Texte d'un message recu ou envoye
    VAR     vl_cmd

    VAR     FORMAT TLT_Info_Evenement vl_infos	' Infos de la fmc selectionnee
    VAR     FORMAT COM_Identifiant_FMC vl_fmc	' Identifiant de la fmc selectionnee
    VAR     vl_reveils				' Textes reveils fmc selectionnee

    VAR     vl_mode_FMC				' Le mode actuel
    VAR     vl_date_debut, vl_date_fin
    VAR     vl_maintenant

    VAR     FORMAT TLT_Statut_Liste vl_statut
    VAR     vl_select				' Selection(s) dans la table
    VAR     vl_droits_enrichir
    VAR     vl_ligne_selectionnee
    VAR     i, k, vl_indice

/*A
 * Traitements en cas d'erreur durant l'initialisation :
 * informer l'operateur, tracer l'erreur et abandonner
 * -----------------------------------------------------
 */

ON ERROR {
    ERROR_BOX@
    COM01_Trace (COM_WARNING, COM03_Message_Erreur (C_MODULE))
    RETURN
}

vm_site = SYSTEM_VAR@ (vg_site)
vm_mon_poste = SYSTEM_VAR@ (vg_numero_poste)
vm_mon_numero_oper = SYSTEM_VAR@ (vg_numero_operateur)
vm_numero_liste = va_numero_liste

/*A recupere le mode d'appel*/
IF (SUBSTRING@(va_appelant,6,3)="TSC")
{
	vm_mode_formation=TRUE
}
ELSE
	vm_mode_formation=FALSE

/*A
 * Charger la fenetre "Liste evenements a traiter"
 * -----------------------------------------------
 */

vm_fenetre = DB_LOAD@ ("ITMA_TLT")

DB_WINDOW_REMAIN@ (vm_fenetre, TRUE)

DB_XPOS@ (vm_fenetre, (vm_numero_liste - 1) * 463)
DB_YPOS@ (vm_fenetre, 105)

DB_TITLE@ (vm_fenetre, "Liste FMC " ++ vm_numero_liste)


/*A
 * Mettre en place la reception des messages
 * -----------------------------------------
 */

vl_les_messages_acceptes[0] = COM_CANAL_FIN
vl_les_messages_acceptes[1] = COM_CANAL_MTLT_FIN
vl_les_messages_acceptes[2] = COM_CANAL_MTLT_FMC

IF (vm_mode_formation=FALSE)
{
	vl_les_messages_acceptes[3] = COM_CANAL_MTLT
	vl_les_messages_acceptes[4] = COM_CANAL_MTLT_SURCHARGE
	vl_les_messages_acceptes[5] = COM_CANAL_MTLT_FINSURCHARGE
	vl_les_messages_acceptes[6] = COM_CANAL_MTLT_VALIDATION_FMC
	vl_les_messages_acceptes[7] = COM_CANAL_MTLT_OUVERTURE_FMC
	vl_les_messages_acceptes[8] = COM_CANAL_MTLT_TIMER
	vl_les_messages_acceptes[9] = COM_CANAL_MTLT_ACQT
	vl_les_messages_acceptes[10] = COM_CANAL_MTLT_RAF
}

DB_ACCEPT_POKES@ (vm_fenetre, vl_les_messages_acceptes)

/*A
 * Definir les caracteristiques (initiales) des objets graphiques
 * --------------------------------------------------------------
 */

DB_TABLE_SET_MARKER_WIDTH@ (vm_fenetre, "TA_Evenements", 23)
DB_TABLE_ALLOW_COLUMN_RESIZING@ (vm_fenetre, "TA_Evenements", TRUE)
DB_CTRL_HORIZ_SCROLL@ (vm_fenetre, "TA_Evenements", FALSE)
DB_CTRL_RETURN_ON_CHANGE@ (vm_fenetre, "TA_Evenements", TRUE)


/*A
 * Initialiser la visualisation (liste des evenements)
 * ---------------------------------------------------
 */
IF TLT_Init_Visualisation (vm_fenetre,va_horodate) <> COM_OK
    RETURN


/*A
 * sur PC niveau 2, je recupere le droit d'enrichir de mes FMC
 * -----------------------------------------------------------
 */
/*
if (SYSTEM_VAR@(vg_type_machine) = XDC_TYPEM_PC2) {
	NEW_TASK@( "TLT_Recuperer_Droits" )
}
*/

/*A
 * Fixer le delai d'inactivite pour le traitement des messages en attente
 * ----------------------------------------------------------------------
 */

DB_TIMER@ (vm_fenetre, CM_DELAI_1s)

/* Initialiser la date de traitement des messages memorises */
vm_date_traitt_msg = CURRENT_TIME@ ()


/*A
 * Traitements en cas d'erreur durant la visualisation :
 * informer l'operateur, tracer l'erreur et continuer
 * -----------------------------------------------------
 */

vl_installer_traitement_erreur = TRUE
WHILE vl_installer_traitement_erreur
    vl_installer_traitement_erreur = FALSE

    ON ERROR {
	ERROR_BOX@
	IF ERROR_NUMBER@() <> C_ERR_IHM
	    COM01_Trace (COM_WARNING, COM03_Message_Erreur (C_MODULE))
	vl_installer_traitement_erreur = TRUE
    }
WEND

/*A
 * Visualiser la fenetre tant que la tache
 * n'est pas stoppee par le signal de fin
 * ---------------------------------------
 */

vl_la_fenetre_est_active = TRUE
WHILE vl_la_fenetre_est_active

    /*B afficher la fenetre en autorisant les actions operateur */
    DB_CTRL_PICKABLE@ (vm_fenetre, "TA_Evenements", TRUE)

    DB_DISPLAY_ONLY@ (vm_fenetre, FALSE)
    DB_DISPLAY@ (vm_fenetre)
    DB_DISPLAY_ONLY@ (vm_fenetre, TRUE)

    vl_objet_selecte = DB_EXIT_CTRL@ (vm_fenetre)

    IF vl_objet_selecte <> "poke_"  AND  SYSTEM_VAR@ (vg_verrou)
	vl_objet_selecte = NULL

    CASE OF vl_objet_selecte

    CASE "poke_"
	vl_poke = DB_GET_POKE@ (vm_fenetre)

	CASE OF  vl_poke
	CASE COM_CANAL_FIN, COM_CANAL_MTLT_FIN
		vl_la_fenetre_est_active = FALSE


	CASE COM_CANAL_MTLT_FMC
		/* poke de demande d'ouverture d'une fiche */
		vl_params = DB_GET_POKE_DATA@ (vm_fenetre)

		/* si la fiche n'est pas trouvee dans la liste des fiches a traiter */
		i = TLT_Index_FMC (vl_params[0], vl_params[1], tm_infos)
		IF (i < ARRAY_SIZE@ (tm_infos))
		{
			IF SYSTEM_VAR@ (vg_fmc_ouverte)
			{
				ERROR@ (C_ERR_IHM, COM_LIB_FMC_OUVERTE)
			}
			ELSE
			{
				/*! marquer l'ouverture de fiche au plus tot pour eviter tout interblocage */
				SET_SYSTEM_VAR@ (vg_fmc_ouverte, TRUE)

				vl_droits_enrichir = tm_infos[i].enrichir
				IF (tm_infos[i].enrichisseur <> 0) AND (tm_infos[i].enrichisseur <> vm_mon_poste)
					vl_droits_enrichir = 0

				/*B si je ne suis pas en formation*/
				IF (vm_mode_formation=FALSE)
				{
					NEW_TASK@ ("ITMA_TMC_Fiche_Main_Courante",
						   "ITMA_TLT_Liste_FMC_A_Traiter",
						   tm_infos[i].info_evt,
						   vl_droits_enrichir,
						   XDC_FMC_ETAT_TRAI)
				}
				ELSE
				{
					NEW_TASK@ ("ITMA_TMC_Fiche_Main_Courante",
						   "ITMA_TSC_etape_scenario",
						   tm_infos[i].info_evt,
						   vl_droits_enrichir,
						   XDC_FMC_ETAT_CLOS)
				}
			}
		}


	CASE COM_CANAL_MTLT_OUVERTURE_FMC
		/* poke de calcul de reveil suite a l'ouverture d'une fiche sur le poste local */
		vl_params = DB_GET_POKE_DATA@ (vm_fenetre)

		/*B Si l'evenement existe dans la liste a traiter alors */
		i = TLT_Index_FMC (vl_params[0], vl_params[1], tm_infos)
		IF i < ARRAY_SIZE@ (tm_infos)
		{
			/*B mettre a jour les dates de debut et fin (en nombre de secondes) */
			tm_infos[i].heure_debut = COM35_DateAffichee_En_Secondes (vl_params[2])
			tm_infos[i].heure_debut_prevu = COM35_DateAffichee_En_Secondes (vl_params[3])
			tm_infos[i].heure_fin = COM35_DateAffichee_En_Secondes (vl_params[4])
			tm_infos[i].heure_fin_prevue = COM35_DateAffichee_En_Secondes (vl_params[5])

			/*B et recalculer les reveils automatiques */
			ITMA_TLT_Reveils_Automatiques (C_FMC_OUVERTE, i)
		}


	CASE COM_CANAL_MTLT_VALIDATION_FMC
		/* poke de validation de la Fmc ouverte */
		vl_params = DB_GET_POKE_DATA@ (vm_fenetre)

		vl_date_debut = vl_params[2]
		vl_date_fin = vl_params[4]
		i = TLT_Index_FMC (vl_params[0], vl_params[1], tm_infos)

		/*A si l'evenement est nouveau ou a change d'etat alors relire la liste */
		IF (i >= ARRAY_SIZE@ (tm_infos))  OR
		      (tm_infos[i].heure_debut = NULL  AND  vl_date_debut <> NULL)  OR
		      (tm_infos[i].heure_debut <> NULL  AND  vl_date_debut = NULL)  OR
		      (tm_infos[i].heure_fin = NULL  AND  vl_date_fin <> NULL)  OR
		      (tm_infos[i].heure_fin <> NULL  AND  vl_date_fin = NULL)
		{
			TLT_Init_Liste_FMC (vm_fenetre, NULL)
			/* mettre a jour l'IHM sans emission de son */
			TLT_Mise_A_Jour_IHM (vm_fenetre, XDC_VRAI, XDC_FAUX)
		}
		ELSE
		{
			/* sinon afficher les eventuelles modifications (type, date, localisation ...) */
			tm_evts[i].date_debut = vl_params[2]		' date debut
			IF (tm_evts[i].date_debut = NULL)
				tm_evts[i].date_debut = vl_params[3]	' date debut prevu

			IF (vl_params[6] <> tm_infos[i].info_evt.Numtype)
			{
				vl_indice = COM45_IndexEnColonne (tm_types_FMC, TDO_NUMERO_FMC, vl_params[6])
				IF (vl_indice >= 0)
				{
					tm_infos[i].info_evt.Numtype = vl_params[6]
					tm_evts[i].type = tm_types_FMC[vl_indice].abbrev
				}
			}

			tm_infos[i].info_evt.localisation.NumAuto = vl_params[7]
			tm_infos[i].info_evt.localisation.PR = vl_params[8]
			tm_infos[i].info_evt.localisation.sens_circulation = vl_params[9]
			tm_evts[i].localisation = COM10_Localisation (tm_infos[i].info_evt.localisation)

			/* puis mettre a jour les dates de debut et fin (en nombre de secondes) */
			tm_infos[i].heure_debut = COM35_DateAffichee_En_Secondes (vl_params[2])
			tm_infos[i].heure_debut_prevu = COM35_DateAffichee_En_Secondes (vl_params[3])
			tm_infos[i].heure_fin = COM35_DateAffichee_En_Secondes (vl_params[4])
			tm_infos[i].heure_fin_prevue = COM35_DateAffichee_En_Secondes (vl_params[5])

			/* et recalculer les reveils automatiques */
			ITMA_TLT_Reveils_Automatiques (C_FMC_VALIDEE, i)

			TLT_Attacher_Pictogramme (i)

			/* mettre a jour l'IHM sans emission de son */
			TLT_Mise_A_Jour_IHM (vm_fenetre, XDC_VRAI, XDC_FAUX)
		}


	CASE COM_CANAL_MTLT_FINSURCHARGE
		/* poke de fin de surcharge pour une fiche */
		vl_params = DB_GET_POKE_DATA@ (vm_fenetre)
		'TLT_trace ("POKE COM_CANAL_MTLT_FINSURCHARGE", ARRAY_TO_STRING@(vl_params, "|"))

		/*! je note que la surcharge est terminee*/
		SET_SYSTEM_VAR@ (vg_fiche_surcharge, null)
		tm_surcharge = NULL

		/*A cherche l'evenement en surcharge*/
		i = TLT_Index_FMC (vl_params[0], vl_params[1], tm_infos)

		/*A s'il est dans la liste des fiches a traiter, mettre a jour son pictogramme*/
		IF (i < ARRAY_SIZE@ (tm_infos))
		{
			TLT_Attacher_Pictogramme (i)

			/*A mettre a jour la visualisation, avec un son si aucune fiche n'est ouverte*/
			IF SYSTEM_VAR@ (vg_fmc_ouverte) {
				TLT_Mise_A_Jour_IHM (vm_fenetre, XDC_FAUX, XDC_FAUX)
			} ELSE {
				TLT_Mise_A_Jour_IHM (vm_fenetre, XDC_FAUX, XDC_VRAI)
			}
		}


	CASE COM_CANAL_MTLT_ACQT
		/* poke de reception d'acquittement d'un evt */
		vl_params = DB_GET_POKE_DATA@ (vm_fenetre)
		'TLT_trace ("POKE COM_CANAL_MTLT_ACQT", ARRAY_TO_STRING@(vl_params, "|"))
		TLT_Memoriser_Message (vm_fenetre, vl_poke, vl_params)


	CASE COM_CANAL_MTLT_TIMER
		/* poke de reception du signal periodique de declenchement des reveils */
		'TLT_trace ("Poke COM_CANAL_MTLT_TIMER", null)
		TLT_Memoriser_Message (vm_fenetre, vl_poke, NULL)


	CASE COM_CANAL_MTLT
		/* poke de reception de reveil d'un evenement */
		vl_params = DB_GET_POKE_DATA@ (vm_fenetre)
		IF (IS_ARRAY@ (vl_params)) {
			vl_args_msg = ARRAY_FROM_STRING@ (vl_params[0], COM_SEPAR_CHAMPS)
			'TLT_trace ("Poke COM_CANAL_MTLT", vl_params)
		} ELSE {
			vl_args_msg = ARRAY_FROM_STRING@ (vl_params, COM_SEPAR_CHAMPS)
			'TLT_trace ("Poke COM_CANAL_MTLT", vl_params)
		}

		vl_texte = TRIM@ (vl_args_msg[2])
		IF (vl_args_msg[0] < 0)
		{
			/*B si c'est un message d'avertissement alors l'envoyer a MTAV */
			DB_SEND_POKE@ (COM_CANAL_MTAV, vl_texte)
		}
		ELSE IF (vl_args_msg[0] = 0)  AND  (vl_args_msg[1] = 0)
		{
			/*B sinon si c'est une demande de reinitialisation de la liste alors la memoriser */
			TLT_Memoriser_Message (vm_fenetre, vl_poke, vl_args_msg)
		}
		ELSE IF (SUBSTRING@ (vl_texte, 1, 1) = XDC_REV_MSG)
		{
			/*B sinon si c'est un message et non un reveil alors le traiter */
			vl_cmd = ARRAY_FROM_STRING@ (SUBSTRING@ (vl_texte, 2), XDC_REV_TXT_SEP)
			IF (vl_cmd[0] = XDC_REV_FMC_RESERVEE)
			{
				/* mettre a jour immediatement le poste enrichisseur et le PICTOGRAMME de la Fmc */
				/* mais CONSERVER les droits (pour les bouchons, qui seraient perdus jusqu'a reinit liste) */
				i = TLT_Index_FMC (vl_args_msg[0], vl_args_msg[1], tm_infos)
				IF i < ARRAY_SIZE@ (tm_infos) {
					tm_infos[i].enrichisseur = vl_cmd[1]
					TLT_Attacher_Pictogramme (i)
					TLT_Mise_A_Jour_IHM (vm_fenetre, XDC_FAUX, XDC_FAUX)
				}
			}
		}
		ELSE IF (SUBSTRING@ (vl_texte, 1, 1) = XDC_REV_URGENT)
		{
			/*B sinon si le reveil est qualifie "urgent" alors le traiter immediatement */
			vl_args_msg[2] = SUBSTRING@ (vl_texte, 2)
			vl_statut = TLT_Traiter_Un_Message (vm_fenetre, vl_poke, vl_args_msg, XDC_VRAI)
			TLT_Mise_A_Jour_IHM (vm_fenetre, vl_statut.rafraichie, vl_statut.reveils)
		}
		ELSE
		{
			/*B sinon le memoriser */
			vl_args_msg[2] = vl_texte
			TLT_Memoriser_Message (vm_fenetre, vl_poke, vl_args_msg)
		}


	CASE COM_CANAL_MTLT_RAF
		/* poke de demande de rafaichissement de l'etat de la liste */
		'TLT_trace ("Poke COM_CANAL_MTLT_RAF ...", null)

		vl_statut = TLT_Traiter_Messages_Memorises (vm_fenetre, XDC_FAUX)
		TLT_Mise_A_Jour_IHM (vm_fenetre, vl_statut.rafraichie, vl_statut.reveils)
		'TLT_trace ("	... Fin RAF Liste FMC", null)
	ENDCASE


    /*A
     * Sur selection d'un evenement,
     * -----------------------------
     */

    CASE "TA_Evenements"
	vl_evenement = DB_EXIT_CODE@ (vm_fenetre)

	/* Donnees de l'action (selection, double clic ...) */
	vl_ligne_selectionnee = DB_EXIT_DATA@ (vm_fenetre)

	CASE OF  vl_evenement
	CASE EV_TBL_DBLCLICK_
	CASE EV_TBL_KEYPRESS_
	CASE EV_TBL_COLUMN_RESIZE_
		'TLT_trace (FORMAT@ ("Double clic sur ligne %s", vl_ligne_selectionnee))
		NOTHING

	CASE EV_TBL_SELECTION_CHANGE_
		i = vl_ligne_selectionnee[0]

		vl_infos = tm_infos[i]
		vl_reveils = tm_reveils[i]
		vl_fmc = vl_infos.info_evt.IdFMC

		'TLT_trace (FORMAT@ ("Selection=%s, Fmc %s/%s", i, vl_fmc.numero, vl_fmc.cle))

		/* Les donnees n'ont pas ete relues apres cette selection */
		'tm_infos_old = tm_infos
		'tm_reveils_old = tm_reveils

		/*A
		 * si le mode actuel est "Lien" ou "Courbe",
		 * envoyer dans le canal MTLV l'intitule FMC choisi
		 * ------------------------------------------------
		 */

		vl_mode_FMC = SYSTEM_VAR@ (vg_mode_liste_fmc)
		IF vl_infos = NULL
		{
			/* ligne separatrice s�lectionn�e : rien a faire */
			'TLT_trace ("Select ligne VIDE =" ++ i)
			DB_TABLE_SET_SELECTIONS@ (vm_fenetre,"TA_Evenements",NULL)
		}
		ELSE IF (vl_mode_FMC = TLVC_LIEN)  OR  (vl_mode_FMC = TLVC_COURBE)
		{
			vl_args_msg = {
				vl_fmc.numero,
				vl_fmc.cle,
				COM11_Libelle_FMC (vl_infos.info_evt),
				vl_infos.info_evt.Numtype
			}
			vl_texte = ARRAY_TO_STRING@ (vl_args_msg, COM_SEPAR_CHAMPS)
			DB_SEND_POKE@ (COM_CANAL_MTLV, vl_texte)
		}
		ELSE IF vl_infos.nb_reveils > 0
		{
			/*A
			 * sinon si l'evenement choisi comporte des reveils,
			 * les acquitter sans visualisation (les supprimer) et ouvrir la FMC
			 * -------------------------------------------------
			 */

			vl_droits_enrichir = vl_infos.enrichir
			IF (vl_infos.enrichisseur <> 0) AND (vl_infos.enrichisseur <> vm_mon_poste)
				vl_droits_enrichir = 0
			IF (vl_infos.info_evt.Numtype = XZAEC_FMC_PosteOperateur)
			{
			PEND_FOR_NEW_TASK@ ("ITMA_TLT_Visu_Reveils", vl_reveils,
                                                vl_infos.info_evt, vl_droits_enrichir) 
			}
			ELSE
			/* ouvrir la FMC */
                        NEW_TASK@ ("ITMA_TMC_Fiche_Main_Courante",
			           "ITMA_TLT_Liste_FMC_A_Traiter",
			           vl_infos.info_evt,
			           vl_droits_enrichir,
			           XDC_FMC_ETAT_TRAI)

			/* effacer les reveils de la liste ACTUELLE */
			k = TLT_Index_FMC (vl_fmc.numero, vl_fmc.cle, tm_infos)
			IF k < ARRAY_SIZE@ (tm_infos)
			{
				'TLT_trace (FORMAT@ ("RRR OPER ACQT %s REVEILS Fmc %s_%s au rang %s, PICTO %s",       vl_infos.nb_reveils, vl_fmc.numero, vl_fmc.cle, k, tm_pictos[k][0]))

				ITMA_TLT_Supprimer_Reveils_Fmc (k)

				/* changer le pictogramme attache a la Fmc */
				TLT_Attacher_Pictogramme (k)

				/*! reconstruire la liste complete des reveils pour le menu textuel */
				ITMA_TLT_Liste_Reveils_Fmc ()

				TLT_Mise_A_Jour_IHM (vm_fenetre, XDC_FAUX, XDC_FAUX)

				ITMA_TLT_Envoi_Acqt_Aux_Voisins (k, vl_fmc.numero, vl_fmc.cle)
			}
			ELSE
			{
				NOTHING
				'TLT_trace (FORMAT@ ("RRR OPER ACQT Fmc %s_%s DISPARUE au rang %s", vl_fmc.numero, vl_fmc.cle, i))
			}

		}
		ELSE IF SYSTEM_VAR@ (vg_fmc_ouverte)
		{
			/*A
			 * sinon visualiser la fiche choisie si aucune n'est en cours
			 * ----------------------------------------------------------
			 */
			ERROR@ (C_ERR_IHM, COM_LIB_FMC_OUVERTE)
		}
		ELSE
		{
			vl_droits_enrichir = vl_infos.enrichir
			IF (vl_infos.enrichisseur <> 0) AND (vl_infos.enrichisseur <> vm_mon_poste)
				vl_droits_enrichir = 0

			/*B si je ne suis pas en formation*/
			IF (vm_mode_formation=FALSE) {
				NEW_TASK@ ("ITMA_TMC_Fiche_Main_Courante",
					      "ITMA_TLT_Liste_FMC_A_Traiter",
					      vl_infos.info_evt,
					      vl_droits_enrichir,
					      XDC_FMC_ETAT_TRAI)
			} ELSE {
				NEW_TASK@ ("ITMA_TMC_Fiche_Main_Courante",
					      "ITMA_TSC_etape_scenario",
					      vl_infos.info_evt,
					      vl_droits_enrichir,
					      XDC_FMC_ETAT_CLOS)
			}

			/*B et recalculer les reveils automatiques */
			ITMA_TLT_Reveils_Automatiques (C_FMC_OUVERTE, i)
		}
	ENDCASE


    /*B Periodiquement, debloquer la scrutation d'evenements */
    CASE "timer_"
	/* rien a faire, hormis le traitement eventuel des messages en attente */
	NOTHING

    ENDCASE


    /*A
     * Lors de chaque evenement ainsi que periodiquement,
     * verifier l'echeance de la periode de traitement des messages en attente
     * sauf durant la saisie d'une fiche main courante
     * -----------------------------------------------------------------------
     */

    IF (SYSTEM_VAR@ (vg_fmc_ouverte) = FALSE)
    {
	vl_maintenant = CURRENT_TIME@ ()
	IF (vl_maintenant >= vm_date_traitt_msg + CM_PERIODE_TRAIT_MSG)
	{
		vl_statut = TLT_Traiter_Messages_Memorises (vm_fenetre, XDC_FAUX)
		TLT_Mise_A_Jour_IHM (vm_fenetre, vl_statut.rafraichie, vl_statut.reveils)
	}
    }
WEND

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Met l'IHM a jour par rapport aux donnees Fmc et reveils.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO TLT_Mise_A_Jour_IHM (va_fenetre, va_maj_liste, va_reveils)

/*
* ARGUMENTS EN ENTREE :
*   va_maj_liste      : Indicateur de rafraichissement de la liste des Fmc ;
*   va_reveils        : Indicateur d'apparition de nouveaux reveils.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : Aucun
*
* CONDITION D'UTILISATION
*   Toute macro
*
* FONCTION
*   Effectue les actions d'information operateur sur mise a jour
*   des donnees Fmc affichees et des reveils associes.
*
---------------------------------------------------------------------------- */

VAR	vl_reveils
VAR	vl_cmd

/* si des reveils sont apparus, verifier s'ils n'ont pas tous ete acquittes */
vl_reveils = XDC_FAUX
IF (va_reveils = XDC_VRAI) {
	IF (TLT_Index_FMC_reveillee () >= 0) {
		vl_reveils = XDC_VRAI
	} ELSE {
		'TLT_trace ("RRR TOUS REVEILS DEJA ACQUITTES")
		NOTHING
	}
}


IF (va_maj_liste = XDC_VRAI) {
	DB_TABLE_SET_DATA@ (va_fenetre, "TA_Evenements", tm_evts, tm_titres, tm_pictos)
} ELSE {
	DB_TABLE_MARKER_PIXMAPS@ (va_fenetre, "TA_Evenements", 0, tm_pictos)
}

/* s'il y a de nouvelles donnees ou de nouveaux reveils alors remonter en debut de liste */
IF (va_maj_liste = XDC_VRAI)  OR  (vl_reveils = XDC_VRAI) {
	DB_TABLE_SET_NEW_TOP_ROW@ (va_fenetre, "TA_Evenements", 0)
}

IF (vl_reveils = XDC_VRAI) {
	/*! demande d'emettre le son associe a un reveil */
	vl_cmd = { MTAR_MSG_EXEC, 1, MTAR_FCT_SONALERTE, ITRE_SON_BASE }
	DB_SEND_POKE@ (COM_CANAL_TAR01, vl_cmd)
}

ENDMACRO




/*A
 * Donnees et fonctions de traitement des messages
 * -----------------------------------------------
 */

FORMAT	TLT_Message
	type_msg,				' Type de message (valeur de 'poke')
	donnees					' Donnees du message

VAR	FORMAT TLT_Message tm_messages		' Table des messages recus en attente
VAR	vm_timer_recu				' Indicateur de memorisation de message timer
VAR	vm_reinit_recu				' Indicateur de demande de relecture liste Fmc


/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Memorise un message (poke) recu et ses donnees pour traitement ulterieur.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO TLT_Memoriser_Message (va_fenetre, va_poke, va_params)

/*
* ARGUMENTS EN ENTREE :
*   va_fenetre        : Id. de la fenetre du module ;
*   va_poke           : Le type du message recu ;
*   va_params         : Les donnees du message recu.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : Indefini
*
* CONDITION D'UTILISATION
*   ITMA_TLT_Liste_FMC_A_Traiter
*
* FONCTION
*   Ajoute le message en fin de liste des messages en attente.
*
---------------------------------------------------------------------------- */

IF (va_poke = COM_CANAL_MTLT_TIMER)
{
	vm_timer_recu = XDC_VRAI
}
ELSE IF (va_poke = COM_CANAL_MTLT) AND (va_params[0] = 0) AND (va_params[1] = 0)
{
	vm_reinit_recu = XDC_VRAI
}
ELSE
{
	tm_messages[ARRAY_SIZE@ (tm_messages)] = { va_poke, va_params }
}

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Traite la liste des messages memorises.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO TLT_Traiter_Messages_Memorises (va_fenetre, va_forcer_reinit)

/*
* ARGUMENTS EN ENTREE :
*   va_fenetre        : Id. de la fenetre du module ;
*   va_forcer_reinit  : Indicateur de relecture de la liste des Fmc.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         :
*   vl_statut.rafraichie : Indique si la liste d'evenements a ete relue ;
*   vl_statut.reveils    : Indique si de nouveaux reveils sont apparus.
*
*
* CONDITION D'UTILISATION
*   ITMA_TLT_Liste_FMC_A_Traiter
*
* FONCTION
*   Traite chacun des nouveaux messages memorises et vide leur liste.
*   Traite ensuite chacun des reveils sur des Fmc inconnues precedemment.
*
---------------------------------------------------------------------------- */

	VAR	vl_reinit_liste
	VAR	i
	VAR	FORMAT TLT_Statut_Liste vl_statut, vl_cr

vl_statut.rafraichie = XDC_FAUX
vl_statut.reveils = XDC_FAUX

IF (va_forcer_reinit = XDC_VRAI)  OR  (vm_reinit_recu = XDC_VRAI)
{
	/* Si une reinitialisation est demandee, relire d'abord la liste des Fmc */
	TLT_Init_Liste_FMC (va_fenetre, NULL)
	vl_statut.rafraichie = XDC_VRAI
}


/*B Traiter chronologiquement les reveils conserves sur des Fmc inconnues precedemment */
IF TLT_Traiter_Reveils_Fmc_Inconnues () = XDC_VRAI {
	vl_statut.reveils = XDC_VRAI
}


/*A Traiter la liste des nouveaux messages recus, dans l'ordre de reception */
FOR i = 0  TO ARRAY_SIZE@ (tm_messages) -1
	IF (vl_statut.rafraichie = XDC_VRAI) {
		vl_reinit_liste = XDC_FAUX
	} ELSE {
		vl_reinit_liste = XDC_VRAI
	}

	vl_cr = TLT_Traiter_Un_Message (va_fenetre,
	                                       tm_messages[i].type_msg,
	                                       tm_messages[i].donnees,
	                                       vl_reinit_liste)
	IF (vl_cr.rafraichie = XDC_VRAI)
	{
		vl_statut.rafraichie = XDC_VRAI
	}
	IF (vl_cr.reveils = XDC_VRAI)
	{
		vl_statut.reveils = XDC_VRAI
	}
NEXT i

IF (vm_timer_recu = XDC_VRAI)
{
	vl_cr = TLT_Traiter_Un_Message (va_fenetre, COM_CANAL_MTLT_TIMER, NULL, XDC_FAUX)
	IF (vl_cr.reveils = XDC_VRAI)
	{
		vl_statut.reveils = XDC_VRAI
	}
}

/* Effacer toutes les donnees des messages memorises */
tm_messages = NULL
vm_timer_recu = XDC_FAUX
vm_reinit_recu = XDC_FAUX


/*B Marquer la date de traitement des messages memorises */
vm_date_traitt_msg = CURRENT_TIME@ ()

RETURN (vl_statut)

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Traite un message (poke) recu par le module MTLT.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO TLT_Traiter_Un_Message (va_fenetre, va_poke, ta_params, va_reinit_liste)

/*
* ARGUMENTS EN ENTREE :
*   va_fenetre        : Id. de la fenetre du module ;
*   va_poke           : Le type du message recu ;
*   ta_params         : Les donnees du message recu ;
*   va_reinit_liste   : Indique si le traitement peut relire la liste d'evenements.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         :
*   vl_cr.rafraichie  : Indique en retour si la liste d'evenements a ete relue ;
*   vl_cr.reveils     : Indique si de nouvelles Fmc sont marquees reveillees.
*
*
* CONDITION D'UTILISATION
*   ITMA_TLT_Liste_FMC_A_Traiter
*
* FONCTION
*   .
*
---------------------------------------------------------------------------- */

	VAR	vl_num_evt, vl_cle_evt, vl_texte
	VAR	vl_rang_evt
	VAR	vl_nb_fmc_reveillees
	VAR	FORMAT TLT_Statut_Liste vl_cr
	VAR	i

vl_cr.rafraichie = XDC_FAUX
vl_cr.reveils = XDC_FAUX

CASE OF va_poke
CASE COM_CANAL_MTLT_ACQT
	vl_rang_evt = ta_params[0]
	vl_num_evt = ta_params[1]
	vl_cle_evt = ta_params[2]
	'TLT_trace (FORMAT@ ("Traitement ACQT Fmc %s/%s au rang %s", vl_num_evt, vl_cle_evt, vl_rang_evt))
	IF (ITMA_TLT_Reception_ACQT_VOISIN (vl_rang_evt, vl_num_evt, vl_cle_evt) = COM_SUPPRIME)
	{
		/* la mise a jour des pictogrammes sera faite globalement a toutes les Fmc */
		/*DB_TABLE_MARKER_PIXMAPS@ (va_fenetre, "TA_Evenements", 0, tm_pictos)*/
		NOTHING
	}


CASE COM_CANAL_MTLT
	vl_num_evt = ta_params[0]
	vl_cle_evt = ta_params[1]
	vl_texte = ta_params[2]
	'TLT_trace ("Traitement message " ++ vl_num_evt ++ "/" ++ vl_cle_evt ++ ":" ++ vl_texte)

	IF (vl_num_evt = 0)  AND  (vl_cle_evt = 0)
	{
		/* sur demande de reinitialisation, relire la liste des evenements */
		IF (va_reinit_liste = XDC_VRAI)
		{
			TLT_Init_Liste_FMC (va_fenetre, NULL)
			'TLT_trace ("		==> Fin REINIT_Liste_FMC", null)
			vl_cr.rafraichie = XDC_VRAI
		}
	}
	ELSE /*IF (vl_texte <> "")*/
	{
		/* sur reception d'un reveil d'evenement */
		i = TLT_Index_FMC (vl_num_evt, vl_cle_evt, tm_infos)
		IF (i >= ARRAY_SIZE@ (tm_infos))
		{
			/* si l'evenement n'est pas dans la liste alors la relire si autorise */
			IF (va_reinit_liste = XDC_VRAI)
			{
				TLT_Init_Liste_FMC (va_fenetre, NULL)
				'TLT_trace ("		==> Fin REINIT_Liste_FMC", null)
				vl_cr.rafraichie = XDC_VRAI
				i = TLT_Index_FMC (vl_num_evt, vl_cle_evt, tm_infos)
			}
		}

		/*B si l'evenement est dans la liste a traiter alors lui attacher le texte du reveil */
		IF (i < ARRAY_SIZE@ (tm_infos))
		{
			ITMA_TLT_Ajouter_Reveil_Fmc (i, vl_texte)
			vl_cr.reveils = XDC_VRAI
		} ELSE {
			/* sinon memoriser le reveil sur Fmc inconnue */
			TLT_Ajouter_Reveil_Fmc_Inconnue (vl_num_evt, vl_cle_evt, vl_texte)
			'TLT_trace (FORMAT@ ("RRRX REVEIL SUR Fmc %s_%s INCONNUE: %s", vl_num_evt, vl_cle_evt, vl_texte))
		}
	}


CASE COM_CANAL_MTLT_TIMER
	'TLT_trace ("Declenchement TIMER", null)
	/* declencher les reveils atteints et les recalculer */
	IF (vm_mode_formation=FALSE)
	{
		vl_nb_fmc_reveillees = ITMA_TLT_Declencher_Reveils_Automatiques ()
		IF (vl_nb_fmc_reveillees > 0)
		{
			vl_cr.reveils = XDC_VRAI
			'TLT_trace ("TTT " ++ vl_nb_fmc_reveillees ++ " Fmc reveillees sur timer")
		}
	}
ENDCASE

RETURN (vl_cr)

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Conserve un texte de reveil recu sur une Fmc inconnue du module MTLT.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO TLT_Ajouter_Reveil_Fmc_Inconnue (va_Num_Evt, va_Cle_Evt, va_Texte)

/*
* ARGUMENTS EN ENTREE :
*   va_Num_Evt        : Numero de l'evenement ;
*   va_Cle_Evt        : Cle de l'evenement ;
*   va_Texte          : Le texte du reveil.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : Aucun
*
*
* CONDITION D'UTILISATION
*   TLT_Traiter_Un_Message
*
* FONCTION
*   Insere l'evenement et le texte du reveil dans la liste dediee.
*
---------------------------------------------------------------------------- */

VAR	FORMAT TLT_Reveil_Fmc	vl_reveil

vl_reveil.num_fmc = va_Num_Evt
vl_reveil.cle_fmc = va_Cle_Evt
vl_reveil.texte = va_Texte

tm_reveils_sans_fmc[ARRAY_SIZE@ (tm_reveils_sans_fmc)] = vl_reveil

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Traite les reveils memorises sur des Fmc inconnues du module MTLT.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO TLT_Traiter_Reveils_Fmc_Inconnues ()

/*
* ARGUMENTS EN ENTREE : Aucun
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : Vrai si une Fmc a ete reveillee, faux sinon.
*
*
* CONDITION D'UTILISATION
*   TLT_Traiter_Messages_Memorises
*
* FONCTION
*   Recherche si la Fmc de chaque reveil memorise est apparue
*      dans la liste a traiter.
*   Si c'est le cas lui ajoute le texte du reveil,
*      sinon conserve le reveil dans la liste dediee.
*
---------------------------------------------------------------------------- */

VAR	FORMAT TLT_Reveil_Fmc	tl_reveils
VAR	FORMAT TLT_Reveil_Fmc	vl_reveil
VAR	vl_fmc_reveillee
VAR	r, f

vl_fmc_reveillee = XDC_FAUX

tl_reveils = tm_reveils_sans_fmc
tm_reveils_sans_fmc = { }

/* Pour chaque reveil memorise, */
FOR r = 0  TO ARRAY_SIZE@ (tl_reveils) - 1
	/* rechercher si la Fmc est apparue dans la liste a traiter */
	f = TLT_Index_FMC (tl_reveils[r].num_fmc, tl_reveils[r].cle_fmc, tm_infos)

	IF f < ARRAY_SIZE@ (tm_infos) {
		/* si la Fmc est connue alors lui associer le texte du reveil */
		vl_reveil = tl_reveils[r]
		ITMA_TLT_Ajouter_Reveil_Fmc (f, vl_reveil.texte)
		vl_fmc_reveillee = XDC_VRAI
		'TLT_trace (FORMAT@ ("RRRX REVEIL Fmc %s_%s APPARUE: %s", vl_reveil.num_fmc, vl_reveil.cle_fmc, vl_reveil.texte))
	} ELSE {
		/* sinon conserver le reveil dans la liste */
		tm_reveils_sans_fmc[ARRAY_SIZE@ (tm_reveils_sans_fmc)] = tl_reveils[r]
	}
NEXT r

RETURN (vl_fmc_reveillee)

ENDMACRO




/*A
 * Description du format du fichier de configuration des reveils
 * -------------------------------------------------------------
 */

FORMAT	TLT_Lect_Config_Reveil
	nom_type_fmc,
	T1,
	T2,
	T3,
	T4


/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Initialise la visualisation.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO TLT_Init_Visualisation (va_fenetre,va_horodate)

/*
* ARGUMENTS EN ENTREE :
*   va_fenetre        : Id. de la fenetre a initialiser.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : COM_OK en cas d'execution correcte, COM_NOK sinon.
*
* CONDITION D'UTILISATION
*   ITMA_TLT_Liste_FMC_A_Traiter
*
* FONCTION
*   Initialise les valeurs a afficher et le fonctionnement general du module.
*
---------------------------------------------------------------------------- */

	VAR	FORMAT TLT_Lect_Config_Reveil	tl_cfg_reveils
	VAR	vl_type_fmc
	VAR	vl_fich_cfg_reveils

	VAR	FORMAT SQL_Procedure_Params@	vl_parametres
	VAR	FORMAT SQL_Procedure_Result@	vl_resultats
	VAR	tl_donnees_postes
	VAR	i, vl_index
	VAR	vl_cr


/*A
 * Lire dans l'environnement les listes des types FMC
 * --------------------------------------------------
 */

tm_types_FMC = SYSTEM_VAR@ (vg_les_types_FMC)


/*A
 * Lire en base la liste des postes du site
 * ----------------------------------------
 */

vl_parametres = COM15_Parametres_Requete ( {
	{ FALSE,	SYB#CHAR_,	XDC_BASE_CFG },
	{ FALSE,	SYB#INT1_,	vm_site },
	{ FALSE,	SYB#CHAR_,	"PO" ++ SYSTEM_VAR@ (vg_nom_site) }
} )

vl_resultats.select_results[0] = { }
COM05_SQL_Procedure (XZAO111_Liste_Machines, vl_parametres, vl_resultats, C_MODULE)
tl_donnees_postes = vl_resultats.select_results[0]
FOR i = 0  TO (ARRAY_SIZE@ (tl_donnees_postes) - 1)
	tm_postes_du_site[i].kle	= tl_donnees_postes[i][0]
	tm_postes_du_site[i].valeur	= TRIM@ (tl_donnees_postes[i][1])
NEXT i


/*A
 * initialisation par defaut : pas d'autoreveils sur fmc
 * -----------------------------------------------------
 */

FOR i = 0 TO ARRAY_SIZE@ (tm_types_fmc) - 1
	vl_type_fmc = tm_types_fmc[i].numero
	tm_config_reveils[vl_type_fmc].type_fmc = vl_type_fmc
	tm_config_reveils[vl_type_fmc].T1 = -1
	tm_config_reveils[vl_type_fmc].T2 = -1
	tm_config_reveils[vl_type_fmc].T3 = -1
	tm_config_reveils[vl_type_fmc].T4 = -1
NEXT i


/*A
 * lire les timers par type de fmc
 * -------------------------------
 */

vl_fich_cfg_reveils = SYSTEM_VAR@ (vg_repertoire_migrazur) ++ COM_SOUS_REP_IHM ++ C_FIC_AUTO_REVEIL
tl_cfg_reveils = COM47_LireTable (vl_fich_cfg_reveils, { "#" }, ";")
FOR i = 0 TO ARRAY_SIZE@ (tl_cfg_reveils) -1
	/*B Attacher les durees de reveil au type Fmc si son nom est connu */
	vl_index = COM45_IndexEnColonne (tm_types_fmc, TDO_NOM_FMC, tl_cfg_reveils[i].nom_type_fmc)
	IF (vl_index >= 0) {
		vl_type_fmc = tm_types_fmc[vl_index][TDO_NUMERO_FMC]
		tm_config_reveils[vl_type_fmc][C_T1] = tl_cfg_reveils[i].T1
		tm_config_reveils[vl_type_fmc][C_T2] = tl_cfg_reveils[i].T2
		tm_config_reveils[vl_type_fmc][C_T3] = tl_cfg_reveils[i].T3
		tm_config_reveils[vl_type_fmc][C_T4] = tl_cfg_reveils[i].T4
	}
NEXT i


/*A
 * Definir les titres des colonnes de la table
 * -------------------------------------------
 */

tm_titres = {					' Titre colonne,taille en pixels
	{ "Num�ro",		60 },
	{ "Site",		35 },
	{ "Type",		100 },
	{ "Date de d�but",	117 },
	{ "Localisation",	105 }
}

DB_DISPLAY_ONLY@ (va_fenetre, TRUE)                     ' Pour avoir acces
DB_DISPLAY@ (va_fenetre)                                '  a l'objet table


/*A
 * Valuer ensuite les donnees de la table
 * --------------------------------------
 */

vl_cr = TLT_Init_Liste_FMC (va_fenetre, va_horodate)
IF (vl_cr <> COM_OK) {
	INFO_MESSAGE@ (C_MODULE ++ vm_numero_liste ++ " : erreur � l'initialisation")
	RETURN (COM_NOK)
}

DB_TABLE_SET_DATA@(va_fenetre, "TA_Evenements", tm_evts, tm_titres, tm_pictos)


RETURN (COM_OK)

ENDMACRO




/*A
 * Description du format des donnees lues en base
 * ----------------------------------------------
 */

FORMAT	TLT_Donnees_Evenement
	liste,					' Liste des FMC � laquelle l'�v�nement est destin�
	position,				' Rang de la ligne de l'�v�nement dans la liste
	espace,					' Espacement du bloc � cette position par rapport au pr�c�dent
	cle_evt,				' Cl� de l'�v�nement
	num_evt,				' Numero de l'�v�nement
	type,					' Numero de type de l'�v�nement
	operation,
	site,
	poste_enrichisseur,
	enrichir,				' Droits d'enrichir DU SITE
	autoroute,
	PR,
	sens_circul,
	date,
	date_debut_prevu,
	date_fin_prevue,
	date_debut,
	date_fin


/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  (Re)Initialise la liste des Fmc a traiter.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO TLT_Init_Liste_FMC (va_fenetre, va_horodate)

/*
* ARGUMENTS EN ENTREE :
*   va_fenetre        : Id. de la fenetre contenant les objets a initialiser.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : COM_OK en cas d'execution correcte, COM_NOK sinon.
*
* CONDITION D'UTILISATION
*   TLT_Init_Visualisation	  a l'initialisation ;
*   ITMA_TLT_Liste_FMC_A_Traiter  sur reception d'un signal de modification.
*
* FONCTION
*   (re)initialise les valeurs de la liste des fiches Main Courante.
*
---------------------------------------------------------------------------- */

    VAR FORMAT TLT_Donnees_Evenement	tl_data
    VAR vl_nb_fmc, vl_rang
    VAR vl_groupe_fmc, vl_groupe_precedent
    VAR vl_espace

    VAR FORMAT SQL_Procedure_Params@ vl_parametres
    VAR FORMAT SQL_Procedure_Result@ vl_resultats
    VAR FORMAT COM_Intitule_FMC vl_FMC
    VAR vl_idx_type
    VAR i, j
    VAR vl_cr

/*B
 * Desactiver la selection d'une Fmc dans la liste durant la reinitialisation
 * --------------------------------------------------------------------------
 */

DB_CTRL_PICKABLE@ (va_fenetre, "TA_Evenements", FALSE)
DB_TABLE_SET_SELECTIONS@ (va_fenetre, "TA_Evenements", NULL)
MACRO_WINS_BUSY@ ()


/*A
 * Lire en base de donnees la nouvelle liste d'evenements pour le poste local
 * --------------------------------------------------------------------------
 */

vl_parametres[0].type = COM_Identifiant_Poste_Oper	' Numero du poste local
vl_parametres[0].data = vm_mon_poste
vl_parametres[0].output = FALSE

/*A si je ne suis pas en formation*/
IF (vm_mode_formation=FALSE)
{
	vl_parametres[1].type = COM_Identifiant_Operateur	' Mon numero d'op�rateur
	vl_parametres[1].data = vm_mon_numero_oper
	vl_parametres[1].output = FALSE

	vl_parametres[2].type = SYB#INT1_
	vl_parametres[2].data = vm_numero_liste
	vl_parametres[2].output = FALSE	

	vl_parametres[3].type = SYB#CHAR_                               ' Site local
	vl_parametres[3].data = SYSTEM_VAR@(vg_nom_site)
	vl_parametres[3].output = FALSE

	vl_cr = COM05_SQL_Procedure (XZAE17_Liste_Evt_Traiter,
	                                vl_parametres, vl_resultats, C_MODULE)

	IF (vl_cr <> COM_OK)
		RETURN (COM_NOK)
}
ELSE IF (vm_mode_formation=TRUE)
{
	vl_parametres[1].type = SYB#DATETIME_	
	vl_parametres[1].data = va_horodate
	vl_parametres[1].output = FALSE

	IF COM05_SQL_Procedure (XZAF01_Liste_Evt_Traiter,
			   vl_parametres, vl_resultats, C_MODULE) <> COM_OK
		RETURN (COM_NOK)

}


/*A
** Sauvegarder les precedentes donnees fmc et les textes de reveils,
**  effacer les structures de donnees puis les reinitialiser
** -----------------------------------------------------------------
*/

tm_infos_old = tm_infos
tm_reveils_old = tm_reveils

tm_evts = { }
tm_infos = { }
tm_reveils = { }
tm_pictos = { }

tl_data = vl_resultats.select_results[0]


/*A
** Pour chaque Fmc a traiter lue en base, si elle est dans cette liste
** -------------------------------------------------------------------
*/

vl_nb_fmc = 0
vl_groupe_precedent = NULL

FOR i = 0  TO ARRAY_SIZE@ (tl_data) - 1
	IF (tl_data[i].liste = vm_numero_liste)
	{
		/*A extraire les donnees de la Fmc */
		vl_FMC.IdFMC.numero = tl_data[i].num_evt
		vl_FMC.IdFMC.cle = tl_data[i].cle_evt
		vl_FMC.Numtype = tl_data[i].type
		vl_FMC.localisation.NumAuto = tl_data[i].autoroute
		vl_FMC.localisation.PR = tl_data[i].PR
		vl_FMC.localisation.sens_circulation = tl_data[i].sens_circul
		vl_FMC.date = COM18_Date_SGBD_Formatee (tl_data[i].date)

		/* si le groupe de visualisation de la Fmc est diff�rent de celui de la Fmc pr�c�dente */
		vl_groupe_fmc = tl_data[i].position
		IF (vl_groupe_fmc <> vl_groupe_precedent) {
			/* alors d�terminer l'espacement du groupe par rapport au groupe pr�c�dent */
			vl_espace = tl_data[i].espace

			/* Surcharge : limiter � 1 l'espacement et aucun en t�te de liste */
			IF (vl_espace > 0) {
				vl_espace = 1
				IF (vl_nb_fmc = 0) {
					vl_espace = 0
				} ELSE IF IS_NULL@ (tm_evts[vl_nb_fmc - 1].numero) {
					vl_espace = 0
				}
			}

			vl_nb_fmc = vl_nb_fmc + vl_espace
		}

		/* placer la Fmc � son rang dans la liste */
		vl_rang = vl_nb_fmc
		vl_nb_fmc = vl_nb_fmc + 1
		vl_groupe_precedent = vl_groupe_fmc

		/*A extraire et calculer les donnees internes et les donnees affichees de la Fmc */
		tm_infos[vl_rang].info_evt = vl_FMC
		tm_infos[vl_rang].enrichir = tl_data[i].enrichir
		tm_infos[vl_rang].enrichisseur = tl_data[i].poste_enrichisseur + 0
		'tm_infos[vl_rang].datex = tl_data[i].datex
		tm_infos[vl_rang].heure_debut = COM35_DateAffichee_En_Secondes (COM18_Date_SGBD_Formatee(tl_data[i].date_debut))
		tm_infos[vl_rang].heure_fin = COM35_DateAffichee_En_Secondes (COM18_Date_SGBD_Formatee(tl_data[i].date_fin))
		tm_infos[vl_rang].heure_debut_prevu = COM35_DateAffichee_En_Secondes (COM18_Date_SGBD_Formatee(tl_data[i].date_debut_prevu))
		tm_infos[vl_rang].heure_fin_prevue = COM35_DateAffichee_En_Secondes (COM18_Date_SGBD_Formatee(tl_data[i].date_fin_prevue))

		tm_evts[vl_rang].numero = tl_data[i].num_evt
		tm_evts[vl_rang].createur = tl_data[i].cle_evt
		vl_idx_type = COM45_IndexEnColonne (tm_types_FMC, TDO_NUMERO_FMC, tl_data[i].type)
		IF vl_idx_type >= 0 {
			tm_evts[vl_rang].type = tm_types_FMC[vl_idx_type].abbrev
		}
		tm_evts[vl_rang].date_debut = vl_FMC.date
		tm_evts[vl_rang].localisation = COM10_Localisation (vl_FMC.localisation)


		/*A
		 * si la fmc etait dans la liste precedente, conserver le nombre et
		 * les textes des reveils ; sinon mettre le nombre de reveils a 0
		 * ----------------------------------------------------------------
		 */

		j = TLT_Index_FMC (tl_data[i].num_evt, tl_data[i].cle_evt, tm_infos_old)
		IF j < ARRAY_SIZE@ (tm_infos_old)
		{
			tm_infos[vl_rang].nb_reveils = tm_infos_old[j].nb_reveils
			tm_infos[vl_rang].reveil_nouvelle_fmc = tm_infos_old[j].reveil_nouvelle_fmc
			tm_infos[vl_rang].date_reveil = tm_infos_old[j].date_reveil
			tm_infos[vl_rang].type_autoreveil = tm_infos_old[j].type_autoreveil
			tm_reveils[vl_rang] = tm_reveils_old[j]

			/* si la FMC recoit le droit d'enrichir alors positionner reveil de type T4 */
			IF (tm_infos[vl_rang].enrichir <> 0)  AND  (tm_infos_old[j].enrichir = 0) {
				ITMA_TLT_Reveils_Automatiques (C_FMC_ENRICHIE, vl_rang)
			}
			/* si la FMC perd le droit d'enrichir alors supprimer reveil de type T1,T2,T3 */
			ELSE IF (tm_infos[vl_rang].enrichir = 0)  AND  (tm_infos_old[j].enrichir <> 0) {
				ITMA_TLT_Reveils_Automatiques (C_FMC_PAS_ENRICHIR, vl_rang)
			}
		} 
		ELSE {
			'TLT_trace (FORMAT@ ("FFF LECTURE NOUVELLE Fmc %s_%s au rang %s", tl_data[i].num_evt, tl_data[i].cle_evt, vl_rang))
			ITMA_TLT_Supprimer_Reveils_Fmc (vl_rang)
			tm_infos[vl_rang].date_reveil = NULL
			tm_infos[vl_rang].type_autoreveil = C_PAS_REVEIL
		
			ITMA_TLT_Reveils_Automatiques (C_FMC_CREEE, vl_rang)
		}

		/*A attacher le pictogramme voulu a l'evenement */
		TLT_Attacher_Pictogramme (vl_rang)
	}
NEXT i

/*! reconstruire la liste complete des reveils pour le menu textuel */
ITMA_TLT_Liste_Reveils_Fmc ()

RETURN (COM_OK)

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Definit le pictogramme attache a une fmc donnee de la liste a traiter,
*  en fonction de son etat.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO TLT_Attacher_Pictogramme (va_indice)

/*
* ARGUMENTS EN ENTREE :
*   va_indice         : indice de la fmc dans la liste.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : Aucun
*
* CONDITION D'UTILISATION
*   Toute macro
*
* FONCTION
*   Si l'indice dans la liste n'est pas hors bornes, met a jour
*   le pictogramme associe a la Fmc de ce rang.
*
---------------------------------------------------------------------------- */

IF (va_indice >= 0)  AND  (va_indice < ARRAY_SIZE@ (tm_infos))
{
	IF tm_infos[va_indice].nb_reveils > 0
	{
		IF tm_infos[va_indice].reveil_nouvelle_fmc = -1
			tm_pictos[va_indice] = { C_PICTO_REVEIL_GRIS }
		ELSE IF tm_infos[va_indice].reveil_nouvelle_fmc = XDC_VRAI
			tm_pictos[va_indice] = { C_PICTO_REVEIL_NOUVELLE_FMC }
		ELSE
			tm_pictos[va_indice] = { C_PICTO_REVEILLE }
	}
	ELSE IF (tm_infos[va_indice].info_evt.IdFMC.numero = tm_surcharge[0])  AND
	           (tm_infos[va_indice].info_evt.IdFMC.cle = tm_surcharge[1])
	{
		tm_pictos[va_indice] = { C_PICTO_SURCHARGE }
	}
	ELSE IF tm_infos[va_indice].datex
	{
		IF tm_infos[va_indice].heure_fin <> NULL  AND tm_infos[va_indice].heure_debut <> NULL
			tm_pictos[va_indice] = { C_PICTO_DATEX_FIN }
		ELSE
			tm_pictos[va_indice] = { C_PICTO_DATEX }
	} 
	ELSE
	{
		IF (tm_infos[va_indice].enrichir <> 0  AND  tm_infos[va_indice].enrichisseur = 0) OR
		      (tm_infos[va_indice].enrichisseur = vm_mon_poste)
		{
			IF tm_infos[va_indice].heure_fin <> NULL AND tm_infos[va_indice].heure_debut <> NULL
				tm_pictos[va_indice] = { C_PICTO_FIN_ENRICHIR }
			ELSE IF tm_infos[va_indice].heure_debut <> NULL
				tm_pictos[va_indice] = { C_PICTO_EN_COURS_ENRICHIR }
			ELSE
				tm_pictos[va_indice] = { C_PICTO_EN_PREV_ENRICHIR }
		} 
		ELSE 
		{
			IF tm_infos[va_indice].heure_fin <> NULL AND tm_infos[va_indice].heure_debut <> NULL
				tm_pictos[va_indice] = { C_PICTO_FIN_PAR_DEFAUT }
			ELSE IF tm_infos[va_indice].heure_debut <> NULL
				tm_pictos[va_indice] = { C_PICTO_EN_COURS_PAR_DEFAUT }
			ELSE
				tm_pictos[va_indice] = { C_PICTO_EN_PREV_PAR_DEFAUT }
		}
	}
}
ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Retourne l'index de l'evenement dont le numero et la cle sont indiques
*  dans la table d'informations evenements egalement fournie en arguments.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO TLT_Index_FMC (va_num_evt, va_cle_evt, FORMAT TLT_Info_Evenement ta_evts)

/*
* ARGUMENTS EN ENTREE :
*   va_num_evt        : Numero de l'evenement ;
*   va_cle_evt        : Cle de l'evenement ;
*   ta_evts           : Table dans laquelle rechercher l'evenement.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : L'index de l'element dans la table.
*
* CONDITION D'UTILISATION
*   Toute macro
*
* FONCTION
*   Recherche simplement l'element dans la table et en retourne l'index.
*
---------------------------------------------------------------------------- */

    VAR     i

i = 0
WHILE i < ARRAY_SIZE@ (ta_evts)  AND
	 (ta_evts[i].info_evt.IdFMC.numero <> va_num_evt  OR
	  ta_evts[i].info_evt.IdFMC.cle <> va_cle_evt)
    i = i + 1
WEND

RETURN (i)

ENDMACRO



/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Cherche dans la liste actuelle une Fmc ayant un ou plusieurs reveils.
*  Retourne l'index dans la liste d'une telle Fmc, ou -1 s'il n'y en a aucune.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION TLT_Index_FMC_reveillee ()

/*
* ARGUMENTS EN ENTREE : Aucun
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : L'index d'une Fmc possedant un reveil, ou -1.
*
* CONDITION D'UTILISATION
*   Toute macro
*
* FONCTION
*
---------------------------------------------------------------------------- */

    VAR      i

i = 0
WHILE i < ARRAY_SIZE@ (tm_infos)  AND  tm_infos[i].nb_reveils = 0
	i = i + 1
WEND

IF i >= ARRAY_SIZE@ (tm_infos) {
	i = -1
}

RETURN (i)

ENDFUNCTION


/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Selon le mode :
*     . calculer la date du prochain reveil automatique et armer le reveil ;
*     . annuler tous reveils automatiques de certains types sur une Fmc.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TLT_Reveils_Automatiques (va_Mode, va_Index_FMC)

/*
* ARGUMENTS EN ENTREE :
*  va_Mode            : creation fmc, validation fmc, ouverture fmc,
*                       gain ou perte du droit d'enrichir la fmc ;
*  va_Index_Fmc       : Le rang de la Fmc dans la liste a traiter.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : Aucun
*
*
* CONDITION D'UTILISATION
*   ITMA_TLT_Liste_FMC_A_Traiter
*
* FONCTION
*
---------------------------------------------------------------------------- */

VAR i
VAR vl_index
VAR vl_date_courante

/* date courante sans les secondes */
vl_date_courante = CURRENT_TIME@ ()

i = va_Index_FMC

IF va_Mode = C_FMC_ENRICHIE OR va_Mode = C_FMC_CREEE {
	/*A armer un reveil sur la FMC a heure courante + T4 */
	vl_index = COM45_IndexEnColonne (tm_config_reveils, C_CONFIG_REV_NUM_TYPE, tm_infos[i].info_evt.Numtype)

	/*B calcul la date de reveil */
	IF tm_config_reveils[vl_index].T4 >= 0 {
		IF va_Mode = C_FMC_ENRICHIE {
			tm_infos[i].type_autoreveil = C_T5
		} ELSE {
			tm_infos[i].type_autoreveil = C_T4
		}
		tm_infos[i].date_reveil = vl_date_courante + tm_config_reveils[vl_index].T4 * 60
	}
	ELSE {
		tm_infos[i].date_reveil = NULL
		tm_infos[i].type_autoreveil = C_PAS_REVEIL
	}
}
ELSE IF va_Mode = C_FMC_PAS_ENRICHIR {
	/*A supprimer le reveil de type T1 ou T2 ou T3 sur la FMC */

	IF (tm_infos[i].type_autoreveil = C_T1 OR 
	    tm_infos[i].type_autoreveil = C_T2 OR
	    tm_infos[i].type_autoreveil = C_T3)
	{
		tm_infos[i].date_reveil = NULL
		tm_infos[i].type_autoreveil = C_PAS_REVEIL
	}
}
ELSE IF va_Mode = C_FMC_OUVERTE {
	/*A supprimer le reveil de type T4 sur la FMC */

	IF tm_infos[i].type_autoreveil = C_T4 OR tm_infos[i].type_autoreveil = C_T5 {
		tm_infos[i].date_reveil = NULL
		tm_infos[i].type_autoreveil = C_PAS_REVEIL
	}
}

IF va_Mode = C_FMC_OUVERTE OR va_Mode = C_FMC_VALIDEE {
	TLT_calcul_reveil_fmc_consultee (vl_date_courante, va_Mode, va_Index_FMC)
}

ENDMACRO



/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Declencher les reveils automatiques dont la date d'echeance est atteinte ;
*  recalculer leur date de prochaine echeance et les rearmer.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TLT_Declencher_Reveils_Automatiques ()

/*
* ARGUMENTS EN ENTREE : Aucun
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : Nombre de Fmcs reveillees.
*
* CONDITION D'UTILISATION
*   ITMA_TLT_Liste_FMC_A_Traiter sur top de l'horloge.
*
* FONCTION
*
---------------------------------------------------------------------------- */

VAR i
VAR vl_index
VAR vl_date_courante
VAR vl_type_reveil
VAR vl_nb_fmc_reveillees
VAR vl_message
VAR FORMAT COM_Intitule_FMC vl_FMC

vl_nb_fmc_reveillees = 0

/* date courante sans les secondes */
vl_date_courante = CURRENT_TIME@ ()

/*A Reveiller les fmc et recalculer les reveils */
FOR i = 0 TO ARRAY_SIZE@ (tm_infos) - 1
	IF (NOT IS_NULL@ (tm_infos[i].date_reveil)) AND (tm_infos[i].date_reveil <= vl_date_courante)
	{
		vl_FMC = tm_infos[i].info_evt
		vl_index = COM45_IndexEnColonne (tm_config_reveils, C_CONFIG_REV_NUM_TYPE, vl_FMC.Numtype)

		/*B Reveiller la fmc */
		vl_type_reveil = tm_infos[i].type_autoreveil
		CASE OF vl_type_reveil
		CASE C_T5
			vl_message = XDC_REV_FMC_AUTO_T5
		CASE C_T4
			vl_message = XDC_REV_FMC_AUTO_T4
		CASE C_T3
			vl_message = XDC_REV_FMC_AUTO_T3
		CASE C_T2
			vl_message = XDC_REV_FMC_AUTO_T2
		CASE C_T1
			vl_message = XDC_REV_FMC_AUTO_T1 ++ tm_config_reveils[vl_index].T1 ++" MINUTES"
		DEFAULT
			vl_message = NULL
		ENDCASE
		IF NOT IS_NULL@ (vl_message) {
			ITMA_TLT_Ajouter_Reveil_Fmc (i, vl_message)
			vl_nb_fmc_reveillees = vl_nb_fmc_reveillees + 1
		}

		/*B Recalculer le nouveau reveil */
		IF (vl_type_reveil = C_T4)  OR  (vl_type_reveil = C_T5) {
			tm_infos[i].date_reveil = vl_date_courante + tm_config_reveils[vl_index].T4 * 60
		}
		ELSE
		{
			IF (vl_type_reveil = C_T1) {
				tm_infos[i].date_reveil = vl_date_courante + tm_config_reveils[vl_index].T1 * 60
			} ELSE {
				TLT_calcul_reveil_fmc_consultee (vl_date_courante, C_FMC_VALIDEE, i)
			}
		}
	}
NEXT i

RETURN (vl_nb_fmc_reveillees)

ENDMACRO





/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  calcul de la nouvelle heure de reveil dans le cas de consultation d'une fmc
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO TLT_calcul_reveil_fmc_consultee (va_Date_Courante, va_Mode, va_index_FMC)

/*
* ARGUMENTS EN ENTREE :
*  va_Date_Courante   : La date actuelle en nombre de secondes ;
*  va_Mode            : Ouverture fmc, validation fmc ;
*  va_index_FMC       : Le rang de la fmc dans la liste a traiter.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : Indefini
*
* CONDITION D'UTILISATION
*   Activation par ITMA_TLT_Reveils_Automatiques.
*
* FONCTION
*
---------------------------------------------------------------------------- */

VAR	vl_Debut, vl_Debut_Prevu, vl_Fin, vl_Fin_Prevue
VAR	i, k

	i = va_index_FMC

	IF (va_Mode = C_FMC_OUVERTE)  AND  (tm_infos[i].enrichir = 0) {
		RETURN
	}

	vl_Debut	= tm_infos[i].heure_debut
	vl_Debut_Prevu	= tm_infos[i].heure_debut_prevu
	vl_Fin		= tm_infos[i].heure_fin
	vl_Fin_Prevue	= tm_infos[i].heure_fin_prevue

	k = COM45_IndexEnColonne (tm_config_reveils, C_CONFIG_REV_NUM_TYPE, tm_infos[i].info_evt.Numtype)
	IF NOT IS_NULL@ (vl_Debut_Prevu) AND IS_NULL@ (vl_Debut) {
		/* armer un reveil de type T2 a l'heure de debut prevu ou a la date courante plus T2 */
		IF tm_config_reveils[k].T2 >= 0 {
			tm_infos[i].type_autoreveil = C_T2
			IF vl_Debut_Prevu > va_Date_Courante {
				tm_infos[i].date_reveil = vl_Debut_Prevu
			}
			ELSE {
				tm_infos[i].date_reveil = va_Date_Courante + tm_config_reveils[k].T2 * 60
			}
		}
	}
	ELSE IF NOT IS_NULL@ (vl_Debut) {
		IF NOT IS_NULL@ (vl_Fin_Prevue) AND IS_NULL@ (vl_Fin) {
			IF vl_Fin_Prevue <= va_Date_Courante {
	   		    IF tm_config_reveils[k].T3 >= 0 {
				tm_infos[i].type_autoreveil = C_T3
				tm_infos[i].date_reveil = va_Date_Courante + tm_config_reveils[k].T3 * 60
			    }
			}
			ELSE IF vl_Fin_Prevue <= tm_config_reveils[k].T1 * 60 + va_Date_Courante {
	   		    IF tm_config_reveils[k].T3 >= 0 {
				tm_infos[i].type_autoreveil = C_T3
				tm_infos[i].date_reveil = vl_Fin_Prevue
			    }
			}
			ELSE IF tm_config_reveils[k].T1 >= 0 {
				tm_infos[i].type_autoreveil = C_T1
				tm_infos[i].date_reveil = va_Date_Courante + tm_config_reveils[k].T1 * 60
			}
		}
		ELSE IF (IS_NULL@(vl_Fin_Prevue) OR NOT IS_NULL@(vl_Fin)) AND (tm_config_reveils[k].T1 >= 0) {
			tm_infos[i].type_autoreveil = C_T1
			tm_infos[i].date_reveil = va_Date_Courante + tm_config_reveils[k].T1 * 60
		}
	}
ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Ajouter le texte d'un reveil a ceux attaches a un evenement existant
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TLT_Ajouter_Reveil_Fmc (va_Index_Fmc, va_Message)

/*
* ARGUMENTS EN ENTREE :
*  va_Index_Fmc        : indice de la fmc dans le tableau tm_infos
*  va_Message          : texte du reveil
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : Indefini
*
* CONDITION D'UTILISATION
*  L'indice doit etre valide (celui d'une Fmc existante).
*
* FONCTION
*
---------------------------------------------------------------------------- */

VAR	f

f = va_Index_Fmc

IF tm_infos[f].nb_reveils < C_MAX_REVEILS {
	tm_infos[f].nb_reveils = tm_infos[f].nb_reveils + 1
} ELSE  {
	tm_reveils[f] = ARRAY_DELETE@ (tm_reveils[f], 0)
}

'TLT_trace (FORMAT@ ("RRR AJOUT REVEIL %s a la Fmc %s_%s de type %s au rang %s: %s", tm_infos[f].nb_reveils, tm_infos[f].info_evt.IdFMC.numero, tm_infos[f].info_evt.IdFMC.cle, tm_infos[f].info_evt.Numtype, f, va_Message))

/* Memoriser le texte du reveil et s'il est de type "Nouvelle Fmc" */
tm_reveils[f, tm_infos[f].nb_reveils - 1] = va_Message
IF (STRING_INDEX@ (va_Message, XDC_REV_FMC_CRE) = 1) {
	tm_infos[f].reveil_nouvelle_fmc = XDC_VRAI
}
ELSE IF (STRING_INDEX@ (va_Message, "FMC auto") >0) {
	tm_infos[f].reveil_nouvelle_fmc = -1
}

/* Attacher le pictogramme de reveil adequat a la Fmc */
TLT_Attacher_Pictogramme (f)

/*! reconstruire la liste complete des reveils pour le menu textuel */
ITMA_TLT_Liste_Reveils_Fmc ()

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Supprimer tous les reveils attaches a un evenement existant
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TLT_Supprimer_Reveils_Fmc (va_Index_Fmc)

/*
* ARGUMENTS EN ENTREE :
*  va_Index_Fmc        : indice de la fmc dans le tableau tm_infos
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : Indefini
*
* CONDITION D'UTILISATION
*  L'indice doit etre valide (celui d'une Fmc existante).
*
* FONCTION
*
---------------------------------------------------------------------------- */

tm_reveils[va_Index_Fmc] = NULL

tm_infos[va_Index_Fmc].nb_reveils = 0
tm_infos[va_Index_Fmc].reveil_nouvelle_fmc = XDC_FAUX

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  (Re)construit la liste complete des reveils destinee au menu textuel.
*  Envoie un message au menu indiquant la presence ou absence de reveils.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TLT_Liste_Reveils_Fmc ()

/*
* ARGUMENTS EN ENTREE : Aucun
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : Indefini
*
* CONDITION D'UTILISATION
*
* FONCTION
*
---------------------------------------------------------------------------- */

	VAR	vl_reveil, vl_fmc, vl_texte

tm_listeReveils = { }

/*A Pour chaque Fmc comportant des reveils, les ajouter a la liste complete */
vl_reveil = 0
FOR vl_fmc = 0 TO (ARRAY_SIZE@ (tm_infos) -1)
	IF tm_infos[vl_fmc].nb_reveils <> 0 {
		FOR vl_texte = 0 TO tm_infos[vl_fmc].nb_reveils - 1
			tm_listeReveils[vl_reveil].num_fmc = tm_infos[vl_fmc].info_evt.IdFMC.numero
			tm_listeReveils[vl_reveil].cle_fmc = tm_infos[vl_fmc].info_evt.IdFMC.cle
			tm_listeReveils[vl_reveil].texte = tm_reveils[vl_fmc][vl_texte]
			vl_reveil = vl_reveil + 1
		NEXT vl_texte
	}
NEXT vl_fmc

SET_SYSTEM_VAR@ (vg_liste_reveils ++ "_" ++ vm_numero_liste, tm_listeReveils)

/*A Prevenir le module MTMT de la presence ou absence de reveils */
IF ARRAY_SIZE@ (tm_listeReveils) = 0 {
	DB_SEND_POKE@ (COM_CANAL_MTMT_REVEIL_OFF, vm_numero_liste)
} ELSE {
	DB_SEND_POKE@ (COM_CANAL_MTMT_REVEIL_ON, vm_numero_liste)
}
ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Envoie l'acquittement d'un evenement aux postes voisins
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TLT_Envoi_Acqt_Aux_Voisins (va_indice , va_no_fmc , va_cle_fmc )

/*
* ARGUMENTS EN ENTREE :
*  va_indice          : indice de la fmc dans la liste
*  va_no_fmc          : no de la fmc a acquitter
*  va_no_cle          : cle de la fmc a acquitter
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : COM_OK en cas d'execution correcte, COM_NOK sinon.
*
* CONDITION D'UTILISATION
*
* FONCTION
*
---------------------------------------------------------------------------- */

VAR	vl_NomMachine
VAR	vl_status
VAR	vl_i_poste
VAR	vl_cmd, vl_args

vl_status = COM_OK

FOR vl_i_poste = 0  TO (ARRAY_SIZE@ (tm_postes_du_site) - 1)
	/* Pour chaque poste operateur du site (autre que celui-ci) */
	IF ( tm_postes_du_site[vl_i_poste].kle <> vm_mon_poste )
	{
		vl_NomMachine = tm_postes_du_site[vl_i_poste].valeur

		/* lui envoyer le message d'acquittement de l'evenement */
		vl_args = { vl_NomMachine, va_indice, va_no_fmc, va_cle_fmc }
		vl_args = ARRAY_TO_STRING@ (vl_args, MTAR_CAR_SEPAR)
		vl_cmd = { MTAR_MSG_EXEC, 1, MTAR_FCT_ACQ_VOISIN, vl_args }
		DB_SEND_POKE@ (COM_CANAL_TAR01, vl_cmd)
	}
NEXT vl_i_poste

RETURN (vl_status)

ENDMACRO



/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Reception de l'acquittement d'un reveil evenement d'un poste voisin 
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TLT_Reception_ACQT_VOISIN (va_indice , va_no_fmc , va_cle_fmc )

/*
* ARGUMENTS EN ENTREE :
*  va_indice          : indice de la fmc dans la liste
*  va_no_fmc        	: no de fmc a acquitter
*  va_no_cle          : cle de la fmc a acquitter
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : Indefini
*
* CONDITION D'UTILISATION
*
* FONCTION
*
---------------------------------------------------------------------------- */

VAR	vl_idx_fmc, vl_idx_reveil

	vl_idx_fmc = va_indice
	IF NOT ( va_indice < ARRAY_SIZE@ (tm_infos)  and
		( ( tm_infos[va_indice].info_evt.IdFMC.numero = va_no_fmc ) and
		  ( tm_infos[va_indice].info_evt.IdFMC.cle = va_cle_fmc ) ) )
	{
		vl_idx_fmc = TLT_Index_FMC (va_no_fmc, va_cle_fmc, tm_infos)
		IF vl_idx_fmc >= ARRAY_SIZE@ (tm_infos)
		{
			'TLT_trace (FORMAT@ ("RRR ACQT RECU Fmc %s_%s INCONNUE", va_no_fmc, va_cle_fmc))
			RETURN (COM_NOK)
		}
	}

	'TLT_trace (FORMAT@ ("RRR ACQT RECU %s REVEILS Fmc %s_%s au rang %s, PICTO %s", tm_infos[vl_idx_fmc].nb_reveils, va_no_fmc, va_cle_fmc, vl_idx_fmc, tm_pictos[vl_idx_fmc][0]))

	/* effacer les reveils de la Fmc s'il y en a */
	IF tm_infos[vl_idx_fmc].nb_reveils > 0
	{
		ITMA_TLT_Supprimer_Reveils_Fmc (vl_idx_fmc)

		/* changer le pictogramme attache a la Fmc */
		TLT_Attacher_Pictogramme (vl_idx_fmc)

		/*! reconstruire la liste complete des reveils pour le menu textuel */
		ITMA_TLT_Liste_Reveils_Fmc ()

		/* indiquer en retour la suppression des reveils */
		RETURN (COM_SUPPRIME)
	}

	RETURN (COM_OK)
ENDMACRO






/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Trace locale specifique au module MTLT
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

VAR	vm_fich_trace

MACRO TLT_trace (va_message, va_donnees_msg)
	VAR	vl_message

	IF IS_NULL@ (vm_fich_trace) {					' La 1ere fois
		vm_fich_trace = "/tmp/traceMTLT" ++ SYSTEM_VAR@ ("vg_numero_display")
		OPEN_ASCII_FILE@ (vm_fich_trace, "a")
		WRITE_FILE@ (vm_fich_trace, FORMAT@ ("\n%s - %s", COM09_Date_Courante (TRUE),
		                "=====================================  DEBUT DE SESSION  ====================================="))
		CLOSE_FILE@ (vm_fich_trace)
	}

	IF IS_NULL@ (va_donnees_msg) {
		vl_message = va_message
	} ELSE IF IS_ARRAY@ (va_donnees_msg) {
		vl_message = va_message ++ " ({" ++ ARRAY_TO_STRING@ (va_donnees_msg, ",") ++ "})"
	} ELSE {
		vl_message = va_message ++ " (" ++ va_donnees_msg ++ ")"
	}

	OPEN_ASCII_FILE@ (vm_fich_trace, "a")
	WRITE_FILE@ (vm_fich_trace, FORMAT@ ("L%s %s - %s", vm_numero_liste, COM09_Date_Courante (TRUE), vl_message))
	CLOSE_FILE@ (vm_fich_trace)
ENDMACRO



/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Visualise dans une nouvelle fenetre les textes de reveils indiques.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TLT_Visu_Reveils (va_l_txt_reveils, va_evt, va_droits_enrichir)

/*
* ARGUMENTS EN ENTREE :
*   va_l_txt_reveils  : Liste des textes de reveils a visualiser.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : COM_VALIDE sur acquittement, COM_QUITTE sinon.
*
* CONDITION D'UTILISATION
*   ITMA_TLT_Liste_FMC_A_Traiter
*
* FONCTION
*   Ouvre une nouvelle boite de dialogue et y affiche la liste de textes ;
*   a la fermeture, ouvre la fiche de l'evenement si c'est demande.
*
---------------------------------------------------------------------------- */

    VAR     vl_fenetre_reveils
    VAR     vl_objet_selecte                    ' L'objet courant de la fenetre
    VAR     vl_les_messages_acceptes            ' Pour reception de signaux
    VAR     vl_la_fenetre_est_active

    VAR     vl_status


/*A
 * Charger la fenetre des textes de reveils
 * ----------------------------------------
 */

vl_fenetre_reveils = DB_LOAD@ ("ITMA_TLT_TXT_REVEILS")
DB_XPOS@ (vl_fenetre_reveils, 120)
DB_YPOS@ (vl_fenetre_reveils, 220)


/*A
 * Mettre en place la reception des messages
 * -----------------------------------------
 */

vl_les_messages_acceptes[0] = COM_CANAL_FIN
DB_ACCEPT_POKES@ (vl_fenetre_reveils, vl_les_messages_acceptes)


/*A
 * Visualiser la liste des textes de reveils
 * -----------------------------------------
 */

DB_CTRL_STRINGS@ (vl_fenetre_reveils, "BL_Textes_Reveils", va_l_txt_reveils)
DB_CTRL_VALUE@ (vl_fenetre_reveils, "BL_Textes_Reveils", -1)


vl_la_fenetre_est_active = TRUE
WHILE vl_la_fenetre_est_active

    DB_DISPLAY@ (vl_fenetre_reveils)
    vl_objet_selecte = DB_EXIT_CTRL@ (vl_fenetre_reveils)
    IF vl_objet_selecte <> "poke_"  AND  SYSTEM_VAR@ (vg_verrou)
        vl_objet_selecte = NULL

    CASE OF vl_objet_selecte

    CASE "poke_"
        CASE OF  DB_GET_POKE@ (vl_fenetre_reveils)
        CASE COM_CANAL_FIN
            vl_la_fenetre_est_active = FALSE
            vl_status = COM_QUITTE
        ENDCASE


    CASE "BP_Quitter"
        vl_la_fenetre_est_active = FALSE
        vl_status = COM_QUITTE


    CASE "BP_Acquitter"
        vl_la_fenetre_est_active = FALSE
        vl_status = COM_VALIDE

    CASE "BP_Acquitter_OuvrFMC"
        vl_la_fenetre_est_active = FALSE
        vl_status = COM_VALIDE

        NEW_TASK@ ("ITMA_TMC_Fiche_Main_Courante",
                        "ITMA_TLT_Liste_FMC_A_Traiter",
                         va_evt,
                         va_droits_enrichir,
                        XDC_FMC_ETAT_TRAI)
   ENDCASE
WEND

RETURN (vl_status)

ENDMACRO
