/*E*/
/* Fichier : $Id: ITMA_TEC_pilotage_echangeur.am,v 1.65 2020/11/23 10:02:10 pc2dpdy Exp $      Release : $Revision: 1.65 $        Date : $Date: 2020/11/23 10:02:10 $
-------------------------------------------------------------------------------
* GTIE *  PROJET MIGRAZUR
-------------------------------------------------------------------------------
* SOUS-SYSTEME  GESIHM
-------------------------------------------------------------------------------
* MODULE MTPM * FICHIER ITMA_TEC_pilotage_echangeur.am
-------------------------------------------------------------------------------
* DESCRIPTION DU MODULE :
*
* IHM de Commande des panneaux d'echangeurs.
*
*
-------------------------------------------------------------------------------
* HISTORIQUE :
*
* Cornu 		30 Nov 1994	: Creation					1.1
* Cornu		05 Dec 1994	: Ajout de la gestion du PA		1.2
* Charles		04 Jul 1995	: action qualité				1.31
* Mismer D.	09 Oct 1995	: Correction appel macro Acces_interdit	(v1.32)
* Mismer D.	18 Oct 1995	: Remplacement de manuel par individuel	(v1.33)
* Mismer D.	22 Nov 1995	: Ajout vg_formation & Suppr Lien FMC auto (v1.34)
* Volcic F..	18 Dec 1995	: Modif declare vm_fenetre (v1.35)
* Mismer D.	04 Mar 1996	: Correction formation au CI (DEM/947)	
						  N° panneau zone de message (DEM/1045)	(v1.36)
* Mismer D.	28 Mar 1996	: Correction "quitter" sur appel PA(DEM/1110)
							+ requete invalide (DEM/699) (v1.37)
* Guilhou	17 sep 1996	: modif gestion lien cause pour applix 4.2 (V1.38)
* Mismer D.	28 Jan 1997	: Ajout numero de panneau (DEM/1305) (V1.39)
* Guilhou	03 oct 1997	: liste des FMC cause a le m look que celle des FMC a traiter (ana/65) 1.40
* C.T.	04 Fev 1998	: correction erreur de comil. du a a accent 
*                          (Priorité, fmc_liée dans FORMAT PA_Ech) 1.41
* cluchague 22/04/2202   : On change I-F en S2 et F-I en S1 1.43
* Niepceron	11/08/2005	: Ajout du mode automatic DEM413 v1.44
* Niepceron	14/01/2008	: Modifier les traitements et filtres spécifiques DN pour les adapter à DM DEM743 v1.45
* JBL		Nov 2007 : DEM 665
* ABE 01-10-2008 : correction FT 1924 : anomalie pilotage échangeur
*					dans ITMA_TEC_Lecture_PA_echangeur_renov
* JMG          29/09/09         : SECTO DEM 887
* ABE 25-03-2010 : correction FT 3450 : Problème d'envoi de TC eqp sur les échangeurs
* ABE 14-06-2010 : FT 3451: Problème d'envoi de TC eqp + scénarios sur l'échangeur Nice Centre sens 2 + réception des états
* ABE 27-04-2015 : projet suppression ancienne GTC (GTCA)
* JMG 26/06/2016 : pilotage depuis le CI 1.60 1.61
* JMG	23/03/17 : regionalisation 1.62
* JPL	23/03/17 : Changement du terme Secteur en Region (DEM 1173)  1.63
* LCL	31/03/20 : Ajout site local MOVIS DEM-SAE93 1.64
* LCL	23/11/20 : Correction envoi site equipement au lieu de site de pilotage sur ITMA_TEC_Fin_Cmd_Manu_Ech 1.65
---------------------------------------------------------------------------- */


/*A Description des constantes générales
 * ------------------------------------- */
DEFINE	C_MODULE			"MTEC"	' Nom du module
DEFINE	REP_CONFIG		"../fichiers/"
DEFINE	REP_RENOVE		"../fichiers/renov/"

DEFINE	POSX_BP_INDIVIDUEL	330
DEFINE	POSY_BP_INDIVIDUEL	665


/*A Description des modules à inclures 
* ---------------------------------------*/
INCLUDE	"dbase_.am"
INCLUDE	"../inc/ITMA_COM.h"
INCLUDE	"../inc/ITMA_TDO.h"
INCLUDE	"../inc/ITMA_TAR.h"
INCLUDE	"../../XDMICG/inc/xdc_ax.h"
INCLUDE	"../../XDMICG/inc/xzic_ax.h"


 /*A Description des procedures sotckées à appeler
* ------------------------------------------------ */
INCLUDE	"../inc/xzac07sp.h"
INCLUDE	"../inc/xzat02sp.h"
INCLUDE	"../inc/xzat08sp.h"
INCLUDE	"../inc/xzac64sp.h"
INCLUDE	"../inc/xzac08sp.h"
INCLUDE	"../inc/xzat01sp.h"
INCLUDE	"../inc/xzac43sp.h"
INCLUDE	"../inc/xzap15sp.h"

INCLUDE	"../inc/xzac100sp.h"
INCLUDE	"../inc/xzac102sp.h"
INCLUDE	"../inc/xzac110sp.h"
INCLUDE	"../inc/xzac120sp.h"
INCLUDE	"../inc/xzac631sp.h"


/*A Description des variables globales
 * ----------------------------------- */
var		vm_statut				' Valeur de retour du module
var     	vm_fenetre_TEC			' item de la fenetre du module
var		vm_messages_acceptes
var		vm_F_echangeur			' fichier de config des echangeurs 
var		vm_F_ech				' fichier des echangeurs dispos en base 
var		vm_ech				' libellé des echangeurs dispos en base 
var		vm_F_panneau			' fichier de config des panneaux 
var		vm_F_bouton			' fichier de config des boutons 
var		vm_dispo				' indice de disponibilité 
var		vm_District				' N° du district 
var		vm_Simulation			' flag de vm_Simulation 
var		vm_NomSite			' Nom du site en cours 
var		vm_text				' text en edition 
var		vm_NumSequence			' n° de la dernière sequence selectionnée 
var		vm_NumEch				' Numero du tube selectionné
var		vm_seq_select			' Nom de la sequence selectionné
var		vm_semiautomatique		' Flag de semi-automatique
var		vm_resultat			' Flag de resultat de sequence
var		vm_exe_seq_en_cours		' Flag d'execution d'une sequence selectionné
var		vm_NomOperateur		' nom de l'operateur
var		vm_mode_PA			' mode de retour du plan d'action
var		vm_NumEvt 			' N° d'evenement
var		vm_CleEvt 			' Clé de l'evenement
var		vm_NumAction			' Numero d'action
var		vm_Appel				' macro d'appel
var		vm_text_sup			' pour choix du sens de l'echangeur
var		vm_liste_Ech			' Liste des echangeurs depuis XZET01
var		vm_index				' index de l'echangeur selectionné dans la liste
var		vm_mode_formation		' Mode formation
var		tm_liste_causes
var		vm_auto				' Mode pilotage automatique

var		vm_Eqp_Signalisation	' fichier de config des eqp signalisation
var		vm_Sce_Signalisation	' fichier de config des seq signalisation
var   	vm_codes_echangeurs_renoves ' liste des codes des echangeurs renoves
var   	vm_noms_echangeurs_renoves ' liste des noms des echangeurs renoves
var 	tm_BP_menu
var		vl_echangeur
var		pos
var		vm_echangeur_renove		' TRUE si renove, false sinon
var 	vm_trigramme

FORMAT 	TMC_actionFiche
			numero_fiche,
			cle_fiche,
			numero_action,
			cle_action,
			libelle_fiche,
			heure_action,
			etat_action,
			domaine_action

FORMAT	PA_Ech
			Remarque,			' remarque (50 char.)
			NumEqt,			' equipement
			Explication,		' explication du PA
			Sequence,			' sequence
			Priorite,			' Priorité
			DistanceEvt,		' Distance de l'événement
			NumEvt,			' N° d'evenement
			CleEvt,			' clé de levenement
			Dispo,			' disponibilité		
			NumeroAction,		' numero d'action
			NomSite,			' nom du site
			fmc_liee			' libellé FMC


var	FORMAT PA_Ech vm_echangeur







/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :	Commande le pilotage des echangeurs
*
*  ----------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TEC_pilotage_echangeur(va_appelant,va_1,va_2,va_3,va_4,va_5,va_6,va_7,va_8)

/*
* ARGUMENTS EN ENTREE :
*  va_appelant		: Nom de la macro Applix ayant invoque la presente.
*  va_1 à va_8		: Suivant la procedure d'appel
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : Status OK ou NOK suivant résultat
*
* CONDITION D'UTILISATION
*   Selection de Piloter -> Echangeur dans MTMT
*
* FONCTION
*    Pilote les panneaux d'echangeurs
*
---------------------------------------------------------------------------- */

VAR FORMAT 	TMC_actionFiche	vl_ficheAction

/*A Déclaration des variables statiques */
var		vl_echangeur		' echangeur selectionné dans la liste 
var		vl_sequence		' sequence selectionné dans la liste 
var		vl_icon 			' graph à afficher dans l'objet 
var		vl_xpos 			' position X de l'objet 
var		vl_ypos 			' position Y de l'objet 
var		vl_abonnement		' flag d'abonnement 
var		vl_les_districts	' listes des disrticts 
var		vl_Poste			' Le nom de la machine
var		vl_fenetre_active	' flag de fenetre active
var		vl_controle_sortie	' flag de sortie
var		vl_erreur			' flag d'erreur
var		vl_indexpt		' index pointeur
var		i,j				' index de loop
var		vl_taille			' taille de tableau
var		vl_defaut			' flag de defaut alarmes
var 		vl_taille2		' 	"        "
var		vl_rang			' rang selectionné dans une liste
var		vl_numero			' numero selectionné
var		vl_message,vl_mess	' mesage affiché
var		vl_text			' text libre
var		vl_fermeture		' flag de fermeture de la fenetre par socket
var		vl_F_tpm			' tableau tampon
var		vl_ligne			' tableau d'une ligne
var		vl_panneau		' tableau des panneaux à commander
var vl_type_panneau		' tableau des types de panneaux à commander
var		vl_etat			' tableau des etat des panneaux à commandes
var		vl_titre  		' titre du bouton
var		vl_titre2  		' titre de l'image digit
var		vl_abt_alarmes		' flag d'abonnement
var		vl_abt_panneau		' flag d'abonnement
var		vl_abt_sequence	' flag d'abonnement
var		vl_defaut_sequence	' flag de defaut sequence
var		vl_explication		' explication du PA
var		vl_remarque		' remarque du PA
var		tl_data,tl_retour	' param. table evenements
var		tl_titres			' titre evenements
var		vl_retour		 	' code retourne à l'appelant
var		vl_fmc			' libelle fmc à construire
var		vl_lib_fmc		' libelle fmc à construire
var		vl_trouve
var		vl_F_sequence
var		vl_F_seq
var		vl_lib_tmc
var		vl_index
var        vl_color
var 		vl_pix_auto
var 		vl_messageDecoupe
var		my_array
var 	vl_sequence_renovee

VAR     FORMAT SQL_Procedure_Params@ vl_parametres
VAR     FORMAT SQL_Procedure_Result@ vl_resultats


MACRO_WINS_BUSY@()


/*A MAJ des variables statiques */
vm_Simulation = SYSTEM_VAR@("vg_simuler_SQL")
vm_District = SYSTEM_VAR@("vg_site")
vm_NomSite = SYSTEM_VAR@("vg_nom_site")
vm_Mode_PA 	= COM_QUITTE
vm_dispo = 0
vl_poste = SYSTEM_VAR@("vg_numero_operateur")
vm_NomOperateur = SYSTEM_VAR@(vg_operateur)
vm_NomOperateur = SUBSTRING@(vm_NomOperateur, 1, 25)
vm_Appel = SUBSTRING@(va_appelant,1,8)
vl_abt_alarmes	= False
vl_abt_panneau	= False
vl_abt_sequence = False
vl_fermeture = FALSE
vm_exe_seq_en_cours = False

vm_mode_formation = (SYSTEM_VAR@(vg_formation) <> NULL)

vl_pix_auto="pix_manu"

/*A Traitements en cas d'erreur durant l'initialisation :
*   informer l'operateur, tracer l'erreur et abandonner
* ------------------------------------------------------*/
ON ERROR 
{
    ERROR_BOX@
    COM01_Trace (COM_WARNING, COM03_Message_Erreur (C_MODULE))
    RETURN(COM_NOK)
}


/*A Tracer l'initialisation de la procedure :
* -------------------------------------------*/
vm_text = "------------------------------------------------------------"
COM01_Trace(0,vm_text)
vm_text = COM09_Date_Courante() ++ "   User : " ++ vm_NomOperateur
vm_text = "Coucou - Start ITMA_TEC_pilotage_echangeur " ++ vm_text
COM01_Trace(0,vm_text)


vm_text = "va_appelant : " ++ va_appelant
COM01_Trace(0,vm_text)

if NOT(IS_ARRAY@(va_1))
{vm_text = "va_1 : " ++ va_1
COM01_Trace(0,vm_text)}

if NOT(IS_ARRAY@(va_2))
{vm_text = "va_2 : " ++ va_2
COM01_Trace(0,vm_text)}

if NOT(IS_ARRAY@(va_3))
{vm_text = "va_3 : " ++ va_3
COM01_Trace(0,vm_text)}

if NOT(IS_ARRAY@(va_4))
{vm_text = "va_4 : " ++ va_4
COM01_Trace(0,vm_text)}

if NOT(IS_ARRAY@(va_5))
{vm_text = "va_5 : " ++ va_5
COM01_Trace(0,vm_text)}

if NOT(IS_ARRAY@(va_6))
{vm_text = "va_6 : " ++ va_6
COM01_Trace(0,vm_text)}

if NOT(IS_ARRAY@(va_7))
{vm_text = "va_7 : " ++ va_7
COM01_Trace(0,vm_text)}
if NOT(IS_ARRAY@(va_7))
{vm_text = "va_8 : " ++ va_8
COM01_Trace(0,vm_text)}

/*A Mode automatique inhiber par defaut */
vm_auto=0

/*A Chargement du fichier de config echangeurs 
*   ------------------------------------------ */
vl_F_tpm = READ_ASCII_FILE@(REP_CONFIG ++ "pmv/ConfigBDEchangeur.cfg")
vl_taille = ARRAY_SIZE@(vl_F_tpm) -1
for i = 1 to vl_taille
	vl_ligne = ARRAY_FROM_STRING@(vl_F_tpm[i],",")
	vl_taille2 = ARRAY_SIZE@(vl_ligne) -1
	for j = 0 to vl_taille2
		vm_F_echangeur[vl_ligne[0],j]=TRIM@(TABS_TO_SPACES@(vl_ligne[j]))
	next j
next i

'----- GTC RENOVEE - chargement du fichier ConfigMenuEchangeuur
COM01_Trace(0, "Lecture du fichier " ++ REP_RENOVE ++ "ConfigMenuEchangeur.cfg")
vl_F_tpm = READ_ASCII_FILE@(REP_RENOVE ++ "ConfigMenuEchangeur.cfg")
vl_taille = ARRAY_SIZE@(vl_F_tpm) -1

for i = 0 to vl_taille
  if ( substring@(vl_F_tpm[i],1,1) <> "#" )
  {
    vl_ligne = ARRAY_FROM_STRING@(vl_F_tpm[i],",")
    tm_BP_menu[i,0]=TRIM@(TABS_TO_SPACES@(vl_ligne[0]))
    tm_BP_menu[i,1]=TRIM@(TABS_TO_SPACES@(vl_ligne[1]))
    vm_noms_echangeurs_renoves[ARRAY_SIZE@(vm_noms_echangeurs_renoves)]=TRIM@(TABS_TO_SPACES@(vl_ligne[0]))
  	vm_codes_echangeurs_renoves[ARRAY_SIZE@(vm_codes_echangeurs_renoves)]=TRIM@(TABS_TO_SPACES@(vl_ligne[1]))
	COM01_Trace(0, "Echangeur " ++ TRIM@(TABS_TO_SPACES@(vl_ligne[0])) ++ " code " ++ TRIM@(TABS_TO_SPACES@(vl_ligne[1])) ++ " renove")
  }
next i


/*A lecture des echangeurs dispo dans la base 
*   ----------------------------------------- */
vm_dispo = 0
vm_ech = ITMA_TEC_Liste_Eqt_Dispo(XDC_EQT_ECH,vm_district,vm_dispo)


/*A Chargement du fichier de config panneau 
*   --------------------------------------- */
vl_F_tpm = READ_ASCII_FILE@(REP_CONFIG ++ "pmv/ConfigBDPanneau.cfg")
vl_taille = ARRAY_SIZE@(vl_F_tpm) -1
for i = 1 to vl_taille
	vl_ligne = ARRAY_FROM_STRING@(vl_F_tpm[i],",")
	vl_taille2 = ARRAY_SIZE@(vl_ligne) -1
	for j = 1 to vl_taille2
		vm_F_panneau[vl_ligne[0],j-1]=TRIM@(TABS_TO_SPACES@(vl_ligne[j]))
	next j
next i


/*A si l'appelant est le menu principal */
if vm_Appel="ITMA_TMT" or TRIM@(va_appelant)=""
{

	/*A construction de la liste des echangeurs */
	vl_F_tpm = ""
	vl_taille = ARRAY_SIZE@(vm_F_echangeur) -1
	for i = 0 to vl_taille
		vl_F_tpm[i] = vm_F_echangeur[i,2]
	next i

	/*A Ouvertue de la liste des échangeurs */
	vm_fenetre_TEC = DB_LOAD@("ITMA_TEC_liste_echangeur")
	vm_messages_acceptes[0] = COM_CANAL_FIN
	DB_ACCEPT_POKES@ (vm_fenetre_TEC, vm_messages_acceptes)

	/*A Positionnement de la fenetre & assignation de la fiche d'aide  
	*   ------------------------------------------------------------- */
	DB_XPOS@(vm_fenetre_TEC,0)
	DB_YPOS@(vm_fenetre_TEC, 100)
	DB_WIDTH@(vm_fenetre_TEC, 993)
	DEFINE_HELPFILE@("Liste des echangeurs", "./aid/ITMA_TEC_liste_echangeur.aide")
	DB_HELP_TOPIC@(vm_fenetre_TEC,"Liste des echangeurs")

	DB_CTRL_RETURN_ON_CHANGE@(vm_fenetre_TEC,"BL_echangeur",True)

	if NOt(IS_ARRAY@(vm_ech))
	{
		info_message@("Pas d'échangeur disponible pour cette région")
		RETURN(COM_NOK)
	}
	DB_CTRL_STRINGS@(vm_fenetre_TEC,"BL_echangeur",vm_Ech)
	DB_CTRL_VALUE@(vm_fenetre_TEC,"BL_echangeur",-1)

	DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_valider",True)

	/*A Boucle de capture des événements de la boite de dialogue  
	*   -------------------------------------------------------- */
	vl_fenetre_active = TRUE


	/*A tant que la fenetre est active */
	WHILE (vl_fenetre_active)

		/* affichage de la liste */
		DB_DISPLAY@(vm_fenetre_TEC)

		/*A capture de l'evenement dans la BD TCA */
		vl_controle_sortie = DB_EXIT_CTRL@(vm_fenetre_TEC)
	
		/*A si l'evenement n'est pas un poke & verrou = vrai */
		if vl_controle_sortie<>"poke_" and SYSTEM_VAR@(vg_verrou)
			/*A reset de l'evenement */
			vl_controle_sortie = NULL 
	
		/* selon l'evenement */
		CASE OF vl_controle_sortie
	
			/*A sur action valider */
			CASE "BP_valider"

				/*A la fenetre n'est plus active */
				vl_fenetre_active = FALSE

				/*A lecture du dernier etat de l'echangeur */
				ITMA_TEC_Lecture_Ech(vm_NumEch)

			/*A sur action quitter */
			CASE "BP_quitter"

				/*A Fermeture de la fenetre */
				RETURN(COM_NOK)

			/*A sur action quitter */
			CASE "BL_echangeur"

				/*A Capture du rang dans la liste des echangeurs */
				vl_rang = DB_CTRL_GET_VALUE@(vm_fenetre_TEC,"BL_echangeur")

				/*A recherche de l'indisponibilité de l'echangeur selectionné */
				vm_index= -1
				for i = 0 to ARRAY_SIZE@(vm_F_echangeur)-1
					if vm_F_echangeur[i,1] = vm_Liste_Ech[vl_rang,2] 
					{ vm_index = i }
				next i
				if vm_index=-1		
				{
					vl_text = "Status : Config. Echangeur '" 
								++ vm_F_echangeur[vl_rang,2] 
												++ "' innconnue."
					DB_CTRL_TITLE@(vm_fenetre_TEC,"LI_status",vl_text)
					DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_valider",True)
				}

				if vm_F_echangeur[vm_index,5]<1 
				{
					vl_text = "Status : Pas de pilotage sur l'echangeur '"
								++ vm_F_echangeur[vm_index,2] ++ "'"
					DB_CTRL_TITLE@(vm_fenetre_TEC,"LI_status",vl_text)
					DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_valider",True)
				}
				else
				{
					for i = 0 to 25
						vl_echangeur[i] = vm_F_echangeur[vm_index,i]
					next i
					pos = ARRAY_INDEX@(vm_noms_echangeurs_renoves, vl_echangeur[2])
					if ( pos > -1)
					{
						vm_echangeur_renove = TRUE
						vm_trigramme = vm_codes_echangeurs_renoves[pos]
					} 
					else
					{
						vm_echangeur_renove = FALSE
					}

					vm_NumEch = vm_Liste_Ech[vl_rang,1]

					vl_text = "Status : Selection de '" 
								++ vm_F_echangeur[vm_index,2] ++ "'"
					if vm_NumEch = 0
					{ vl_text = vl_text ++ " en consultation" }		

					DB_CTRL_TITLE@(vm_fenetre_TEC,"LI_status",vl_text)
					DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_valider",False)
				}

			/*A sur reception de poke */
			CASE "poke_"
	
				/*A suivant le canal de reception de poke */
				CASE OF DB_GET_POKE@(vm_fenetre_TEC)

					/*A si poke de fin de canal : fermeture de fenetre */
					CASE COM_CANAL_FIN
						/*A la fenetre n'est plus active */
						vl_fenetre_active = FALSE
						vl_fermeture = TRUE

				ENDCASE

		ENDCASE

	/*A fin tant que */
	WEND
}
else
{

	/*A si appelant : ISYN_SOP */
	if NOT IS_NUMBER@(va_1) and SUBSTRING@(va_appelant,1,8) = "ISYN_SOP"
	{
		vl_text = va_1[0]++"  "
		vl_echangeur = ""
		vl_echangeur[0] = 0

		/*A Ouvertue de la boite de choix du sens */
		vm_fenetre_TEC = DB_LOAD@("ITMA_TEC_choix_sens")
		vm_messages_acceptes[0] = COM_CANAL_FIN
		DB_ACCEPT_POKES@ (vm_fenetre_TEC, vm_messages_acceptes)
		DB_XPOS@(vm_fenetre_TEC,450)
		DB_YPOS@(vm_fenetre_TEC, 500)

		DB_CTRL_TITLE@(vm_fenetre_TEC,"LI_echangeur","Echangeur  " ++vl_text)
		vl_fenetre_active = TRUE

		/*A tant que la fenetre est active */
		WHILE (vl_fenetre_active)

			/* affichage de la liste */
			DB_DISPLAY@(vm_fenetre_TEC)

			/*A capture de l'evenement dans la BD TCA */
			vl_controle_sortie = DB_EXIT_CTRL@(vm_fenetre_TEC)
	
			/*A si l'evenement n'est pas un poke & verrou = vrai */
			if vl_controle_sortie<>"poke_" and SYSTEM_VAR@(vg_verrou)
				/*A reset de l'evenement */
				vl_controle_sortie = NULL 

			/* selon l'evenement */
			CASE OF vl_controle_sortie

				/*A sur action valider */
				CASE "BP_quitter"

					/*A la fenetre n'est plus active */
					Return(COM_NOK)

				/*A sur action valider */
				CASE "BP_I_F"

					vm_text_sup = " S2"
					vl_fenetre_active = FALSE

				/*A sur action valider */
				CASE "BP_F_I"

					vm_text_sup = " S1"
					vl_fenetre_active = FALSE

				/*A sur action valider */
				CASE "BP_aide"

					info_message@("Choisissez un coté...")
	

				/*A sur reception de poke */
				CASE "poke_"
	
					/*A suivant le canal de reception de poke */
					CASE OF DB_GET_POKE@(vm_fenetre_TEC)

						/*A si poke de fin de canal : fermeture de fenetre */
						CASE COM_CANAL_FIN
							/*A la fenetre n'est plus active */
							vl_fenetre_active = FALSE
							return(COM_NOK)

					ENDCASE

			ENDCASE
		WEND

		vl_text = TRIM@(vl_text) ++ vm_text_sup
		vl_echangeur[0] = 0

		/*a lecture de tout le fichier  de config echangeur */
		vl_taille  = ARRAY_SIZE@(vm_F_echangeur)
		for i = 1 to vl_taille
			
			/*A si nom d'echangeur trouvé : MAJ tableau */
			if vl_text = vm_F_echangeur[i,2]
			{	
				if vm_F_echangeur[i,5] > 0
				{	
					for j = 0 to 25
						vl_echangeur[j] = vm_F_echangeur[i,j]
					next j
					
					pos = ARRAY_INDEX@(vm_noms_echangeurs_renoves, vl_echangeur[2])
					if ( pos > -1)
					{
						vm_echangeur_renove = TRUE
						vm_trigramme = vm_codes_echangeurs_renoves[pos]
					} 
					else
					{
						vm_echangeur_renove = FALSE
					}

				}
			}

		next i
		
		vm_NumEch = vl_echangeur[0]+0
		vm_echangeur.NumEqt = vm_NumEch
		if vm_NumEch=0
		{	info_message@("Pas de pilotage pour l'echangeur  '"++vl_text++"'")
			RETURN(COM_NOK)
		}
		
	}
	else 
	{
		if vm_Appel = "ITMA_TMC"
		{
			vl_FicheAction = va_1
			if (vl_FicheAction.domaine_action <> XDC_ACT_GTC_SIG_ECH)
			{
				vm_echangeur_renove = FALSE
				vl_retour =  ITMA_TEC_Lecture_PA_echangeur(
										vl_FicheAction.Numero_Action,
										vl_FicheAction.cle_action)

				vm_NumEch = vl_retour[0]+0
				vm_NumSequence = vl_Retour[2]+0

				/*A recherche de l'echangeur */
				if vm_NumEch>0 
				{
					for i = 0 to 25
						vl_echangeur[i] = vm_F_echangeur[vm_NumEch,i]
					next i
				}

				/*A Chargement du fichier de config sequences */
				vl_F_tpm = READ_ASCII_FILE@(REP_CONFIG 
								++ "pmv/ConfigSequenceEchangeur.cfg")
				vl_taille = ARRAY_SIZE@(vl_F_tpm) -1
				for i = 1 to vl_taille
					vl_ligne = ARRAY_FROM_STRING@(vl_F_tpm[i],",")
					vl_taille2 = ARRAY_SIZE@(vl_ligne) -1
					for j = 0 to vl_taille2
						vl_F_sequence[i,j]=TRIM@(TABS_TO_SPACES@(vl_ligne[j]))
					next j
				next i
			
				/*A construction de la liste des sequences */
				vl_taille = ARRAY_SIZE@(vl_F_sequence) -1
				i = 1
				vl_trouve = 0
				for i = 1 to vl_taille
					if vl_F_sequence[i,0] = "--> " ++ vl_echangeur[1]
					{ vl_trouve = i }
				next i		
				vl_F_tpm = ""
				if vl_trouve <> 0
				{
					for i = vl_trouve+1 to vl_taille
						vl_F_tpm[i-vl_trouve-1] = vl_F_sequence[i,1] 
						vl_F_seq[i-vl_trouve-1] = vl_F_sequence[i]
						if SUBSTRING@(vl_F_sequence[i+1,0],1,3) = "-->" 
						{ i = vl_taille}
					next i
				}

				/*A recherche de la sequence correspondante dans la table vl_F_seq */
				vl_index = 50
				for i = 0 to ARRAY_SIZE@(vl_F_seq)
					if vl_F_seq[i,0]+0 = vm_NumSequence+0 { vl_index = i }
				next i

				/*A MAJ de vl_sequence */
				for i = 0 to 49
					vl_sequence[i] = vl_F_seq[vl_index,i+2]
				next i

				if TRIM@(vl_F_seq[vl_index,1])=""
				{ 	vl_lib_tmc = "Echangeur : " ++vl_echangeur[2] ++ 
				"     Pas de sequence trouvée pour cette action.   "++ vl_retour[3] 
				}
				else
				{	vl_lib_tmc = "Echangeur " ++vl_echangeur[2] 
										++ "      Sequence : " ++
	 									vl_F_seq[vl_index,1] ++ "      " 
										++ vl_retour[3]
				}
			}
			else
			{
				/* GTC renovee */
				vl_retour = ITMA_TEC_Lecture_PA_echangeur_renov(vl_FicheAction.Numero_Action, vl_FicheAction.cle_action)
				vm_NumEch = vl_retour[0]+0
				vm_NumSequence = vl_Retour[2]+0
				
				/*A recherche de l'echangeur */
				if vm_NumEch>0 
				{
					for i = 0 to 25
						vl_echangeur[i] = vm_F_echangeur[vm_NumEch,i]
					next i
				}
				pos = ARRAY_INDEX@(vm_noms_echangeurs_renoves, vl_echangeur[2])
				if ( pos > -1)
				{
					vm_echangeur_renove = TRUE
					vm_trigramme = vm_codes_echangeurs_renoves[pos]
				} 
				else
				{
					vm_echangeur_renove = FALSE
				}
				
				/* GTC renovee : affichage de la sequence precedemment envoyee */
				COM01_Trace(0, "Appel par ITMA_TMC et echangeur renove, on charge la sequence de l'echangeur renove " ++ vl_echangeur[2])
				COM01_Trace(0, "Recherche de la sequence " ++ vm_NumSequence)
				vl_F_tpm = READ_ASCII_FILE@(REP_RENOVE ++ vm_trigramme ++ "/ConfigSceSignalisation_" ++ vm_trigramme ++ ".cfg")
				vl_taille = ARRAY_SIZE@(vl_F_tpm) -1
				for i = 0 to vl_taille
				  vl_ligne = ARRAY_FROM_STRING@(vl_F_tpm[i],",")
				  if ( substring@(vl_F_tpm[i],1,1) <> "#" and vl_ligne[0] = vm_NumSequence)
					i = vl_taille
				next i
				
				vl_sequence_renovee = vl_ligne
				
				COM01_Trace(0, "Le libelle de la sequence est " ++ vl_ligne[1])
				vl_lib_tmc = "Echangeur " ++
							vl_echangeur[2] ++
							"   -   Sequence : " ++
							vl_ligne[1] ++
							"   -   " ++
							vl_retour[3]
			}

		}
		
		else
		{
			if vm_Appel = "ITMA_TPA"
			{
				/*A Mise à jour du mode automatique */
				vm_auto=va_5+0
				vl_retour = ITMA_TEC_Lecture_Prop_PA_Ech(va_1,va_2)
				vm_NumEch 		= vl_retour[0]
				vm_NumSequence 	= vl_retour[1]
				vl_explication 	= vl_retour[2]
				vl_remarque 		= vl_retour[3]
				
				for i = 0 to 25
					vl_echangeur[i] = vm_F_echangeur[vm_NumEch,i]
				next i
				pos = ARRAY_INDEX@(vm_noms_echangeurs_renoves, vl_echangeur[2])
				if ( pos > -1)
				{
					vm_echangeur_renove = TRUE
					vm_trigramme = vm_codes_echangeurs_renoves[pos]
				} 
				else
				{
					vm_echangeur_renove = FALSE
				}
				vm_echangeur.NumEqt = vm_NumEch
				vm_echangeur.Sequence = vm_NumSequence
				vm_echangeur.Priorite = vl_retour[4]
				vm_echangeur.Distanceevt = vl_retour[5]
				vm_echangeur.NumEvt = va_3
				vm_echangeur.CleEvt = va_4

				vm_NumEvt = va_3 + 0
				vm_CleEvt = va_4 + 0

				if vm_NumEch+vm_NumSequence = 0
				{	info_message@("Le plan d'action ne propose rien...")
					RETURN(COM_NOK)
				}

				if vl_echangeur[3]="rien" or vl_echangeur[5] < 1
				{ 	info_message@
					("Proposition du plan d'action incorrect : Echangeur '"
							++vl_echangeur[2]++"' non pilotable")
					RETURN(COM_NOK) 
				}
				if vm_NumSequence = XDC_ECH_ETEINT { vm_NumSequence = 2 }
				if (vm_echangeur_renove = TRUE)
				{
					/* GTC renovee : affichage de la sequence proposee */
					COM01_Trace(0, "Appel par ITMA_TPA et echangeur renove, on charge la sequence de l'echangeur renove " ++ vl_echangeur[2])
					COM01_Trace(0, "Recherche de la sequence " ++ vm_NumSequence)
					vl_F_tpm = READ_ASCII_FILE@(REP_RENOVE ++ vm_trigramme ++ "/ConfigSceSignalisation_" ++ vm_trigramme ++ ".cfg")
					vl_taille = ARRAY_SIZE@(vl_F_tpm) -1
					for i = 0 to vl_taille
					  vl_ligne = ARRAY_FROM_STRING@(vl_F_tpm[i],",")
					  if ( substring@(vl_F_tpm[i],1,1) <> "#" and vl_ligne[0] = vm_NumSequence)
						i = vl_taille
					next i
					vl_sequence_renovee = vl_ligne
				}
				
			}
			else
			{
				if va_1>0
				{
					if vm_F_echangeur[va_1,5] > 0
					{
						for i = 0 to 25
							vl_echangeur[i] = vm_F_echangeur[va_1,i]
						next i
						vm_NumEch = va_1
						pos = ARRAY_INDEX@(vm_noms_echangeurs_renoves, vl_echangeur[2])
						if ( pos > -1)
						{
							vm_echangeur_renove = TRUE
							vm_trigramme = vm_codes_echangeurs_renoves[pos]
						} 
						else
						{
							vm_echangeur_renove = FALSE
						}

					}
					else
					{	info_message@("Echangeur "++vm_F_echangeur[va_1,2]
										++" non pilotable")
						RETURN(COM_NOK)
					}
				}
				else
				{
					info_message@("ERREUR : Veuillez passer le N° d'équipement de l'echangeur en 2eme arguments, merci ...")
					return(COM_NOK)
				}
			}
		}
	}

}

/*A si la fenetre à été fermé par socket arreter l'application 
*   ---------------------------------------------------------- */
if vl_fermeture = TRUE then RETURN(COM_NOK)



/*A Chargement de la fenetre & assignation des sockets 
*   -------------------------------------------------- */
if (vm_auto <> 1 )
{
	if (vm_echangeur_renove = TRUE)
	{
		ITMA_TEC_ChargerFichierRenove(vm_codes_echangeurs_renoves[pos])
	}

vm_fenetre_TEC = DB_LOAD@(vl_echangeur[3])
vm_messages_acceptes[0] = COM_CANAL_FIN
vm_messages_acceptes[1] = COM_CANAL_MTEC_PAN
vm_messages_acceptes[2] = COM_CANAL_MTEC_SEQ
vm_messages_acceptes[3] = COM_CANAL_MTEC_ALM
DB_ACCEPT_POKES@ (vm_fenetre_TEC, vm_messages_acceptes)
DB_CTRL_WORK_COLORS@(vm_fenetre_TEC,"BE_remarque",TRUE)


/*A Positionnement de la fenetre & assignation de la fiche d'aide  
*   ------------------------------------------------------------- */
DB_XPOS@(vm_fenetre_TEC,0)
DB_YPOS@(vm_fenetre_TEC, 100)
DEFINE_HELPFILE@("gerer_pilotage_echangeur", "./aid/ITMA_TEC_echangeur.aide")
DB_HELP_TOPIC@(vm_fenetre_TEC,"gerer_pilotage_echangeur")




/*A Si appel en mode consultation : cacher les commandes */
if vm_Appel="ITMA_TUE" or vm_Appel="ITMA_TMC"
{
	DB_HEIGHT@(vm_fenetre_TEC,275)
	DB_CTRL_DISPLAY@(vm_fenetre_TEC,"BP_quitter2",True)
	DB_CTRL_DISPLAY@(vm_fenetre_TEC,"BP_actuel",False)
	DB_XPOS@(vm_fenetre_TEC,0)
	DB_YPOS@(vm_fenetre_TEC, 100)
}


/*A Griser les boutons de confirmation operateur  
*   -------------------------------------------- */
DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_ok",True)
DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_nul",True)

/*A affichage le titre de la boite 
*   -------------------------------- */
DB_TITLE@(vm_fenetre_TEC,"Signalisation Echangeur " ++ vl_echangeur[2])
DB_CTRL_TITLE@(vm_fenetre_TEC,"LI_nom",
					"Signalisation Echangeur " ++ vl_echangeur[2])

if (vm_echangeur_renove = FALSE)
{
	/*A Créer et positionner les panneaux */
	vl_color[0] = 1
	vl_color[1] = 255,255,255
	i = 5
	WHILE vl_echangeur[i]<>NULL

		vl_numero = i - 4
		vm_F_bouton[vl_numero,0]	= 0				' le n° du picto associé
		vm_F_bouton[vl_numero,1]	= vl_echangeur[i]	' le n° Merlin Gerin
		vm_F_bouton[vl_numero,2]	= vm_F_panneau[vl_echangeur[i],5] 
											' le picto associé
		vm_F_bouton[vl_numero,3]	= vm_F_panneau[vl_echangeur[i],0] 
											' le type (TF ou TP)
		vm_F_bouton[vl_numero,4]	= vm_F_panneau[vl_echangeur[i],2] 
											' n° d'eqt en base
		vl_icon 	= vm_F_panneau[vl_echangeur[i],5]
		vl_xpos 	= vm_F_panneau[vl_echangeur[i],3]	' la posiiton X
		vl_ypos 	= vm_F_panneau[vl_echangeur[i],4]	' la position Y
		vl_titre 	= "BP_cmd" ++ vl_numero		' le nom de l'objet de commande
		vl_titre2 = "BP_panneau" ++ vl_numero	' le nom de l'objet d'affichage

		DB_CREATE_CTRL@(vm_fenetre_TEC,3,vl_titre,vl_icon,vl_xpos,vl_ypos,0)
		DB_CREATE_CTRL@(vm_fenetre_TEC,3,vl_titre2,vl_icon,vl_xpos,
									vl_ypos - 280,0)
		DB_CTRL_BUTTON_TYPE@(vm_fenetre_TEC,"BP_panneau"++vl_numero,4)
		DB_CTRL_BUTTON_TYPE@(vm_fenetre_TEC,"BP_cmd"++vl_numero,4)
		DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_panneau"++vl_numero,True)
		if vm_NumEch = 0
		{ DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_cmd"++vl_numero,True) }

		/*!!! Ajout numero de panneau */
		if ( vl_numero > 1000 ) then vl_numero = vl_numero - 1000
		vl_titre  = "BP_Lib_Pan" ++ vl_numero           ' libelle panneau
	  	vl_titre2 = "BP_Lib_Cmd" ++ vl_numero           ' libelle panneau
		if ( vl_echangeur[i] > 1000 ) 
		{	vl_numero = vl_echangeur[i] - 1000	}
		else
		{	vl_numero = vl_echangeur[i]	}
	  	DB_CREATE_CTRL@(vm_fenetre_TEC,3,vl_titre,
				vl_numero,vl_xpos+7,vl_ypos-292,0)
	  	DB_CTRL_WIDGET_COLOR@(vm_fenetre_TEC,vl_titre,vl_color)
		DB_CTRL_FONT@(vm_fenetre_TEC, vl_titre,
		 "-adobe-courier-bold-r-normal--10-100-75-75-m-65-iso8859-1")
	/*  	DB_CTRL_BUTTON_TYPE@(vm_fenetre_TEC,vl_titre,0)
	 	DB_CTRL_GRAYED@(vm_fenetre_TEC,vl_titre,True)*/

		DB_CREATE_CTRL@(vm_fenetre_TEC,3,vl_titre2,
				vl_numero,vl_xpos+7,vl_ypos-12,0)
	 	DB_CTRL_WIDGET_COLOR@(vm_fenetre_TEC,vl_titre2,vl_color)
		DB_CTRL_FONT@(vm_fenetre_TEC, vl_titre2,
		 "-adobe-courier-bold-r-normal--10-100-75-75-m-65-iso8859-1")
	/* 	DB_CTRL_BUTTON_TYPE@(vm_fenetre_TEC,vl_titre2,0)
	 	DB_CTRL_GRAYED@(vm_fenetre_TEC,vl_titre2,True)*/

		i = i + 1
	WEND
}
else
{
	ITMA_TEC_creation_eqp_signalisation_renove()
}

/*A Effacer la discordance sequence */ 
DB_CTRL_DISPLAY@(vm_fenetre_TEC,"BP_defaut",False)


/*A Boucle de capture des événements de la boite de dialogue  
*   -------------------------------------------------------- */
vl_fenetre_active = TRUE


/*A appel de la liste des sequences */
DB_DISPLAY_ONLY@(vm_fenetre_TEC,True)
DB_DISPLAY@(vm_fenetre_TEC,False)
DB_DISPLAY@(vm_fenetre_TEC,True)
DB_DISPLAY_ONLY@(vm_fenetre_TEC,False)
}

/*A si consultation : pas de selection de sequence */
if vm_Appel<>"ITMA_TUE" and vm_Appel<>"ITMA_TPA" 
			and vm_Appel<>"ITMA_TMC" and vm_NumEch<>0
{ 	
/*	vl_sequence = Pend_For_New_Task@("ITMA_TEC_sequence",vl_echangeur[1]) */
	vm_NumSequence = 3		' Sequence autre par défaut
	vl_sequence = ITMA_TEC_sequence_PA(vl_echangeur[1],vm_NumSequence)
}
else
{ 	if SUBSTRING@(va_appelant,1,8)="ITMA_TPA"
	{
		vl_sequence = ITMA_TEC_sequence_PA(vl_echangeur[1],vm_NumSequence)
		if ( vm_auto <> 1 )
		{
		DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_explication",False)
		DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_refuser",False)
		if TRIM@(vl_remarque)<>""
		{
			vm_text[0] = vl_remarque
			DB_EDITBOX_CLEAR@(vm_fenetre_TEC,"BE_remarque")
			DB_EDITBOX_SET_DATA@(vm_fenetre_TEC,"BE_remarque",vm_text)
			DB_CTRL_DISPLAY@(vm_fenetre_TEC,"LI_remarque",TRUE)
			DB_CTRL_DISPLAY@(vm_fenetre_TEC,"ID_remarque",TRUE)
			DB_CTRL_DISPLAY@(vm_fenetre_TEC,"BE_remarque",TRUE)
		}
		

		if vm_NumEvt = 0 or vm_CleEvt = 0 
		{ 	
			DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_executer",True)
		}
		else
		{
			/*A MAJ du libelle fmc nouveau */
			ITMA_COM_Lire_Evenement ( vm_NumEvt, 
								vm_CleEvt, 
								vl_lib_fmc,
								C_MODULE) 
			vl_fmc = COM11_Libelle_FMC(vl_lib_fmc)
			DB_CTRL_TITLE@(vm_fenetre_TEC,"LI_fmc",vl_fmc)
			DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_executer",False)
		}
		}

	}	
	else if vm_Appel<>"ITMA_TMC" {vl_sequence[0] = -1 }
}
vl_pix_auto="pix_manu"
/*A si retour d'une sequence */
if vl_sequence[0] <> -1
{
	vm_NumSequence =  SYSTEM_VAR@("NumSequence")+0
	vl_pix_auto="pix_auto"
}

if (vm_auto <> 1 ) /* si on n'est pas en auto */
{

if vl_sequence[0] <> -1
{
	/*A dégriser le bouton 'BP_executer' */
	DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_executer",False)

	/*A MAJ du n° de sequence selectionné */
	vm_NumSequence =  SYSTEM_VAR@("NumSequence")+0

	/*A MAJ du message status */
	vm_text = SYSTEM_VAR@("sequence")
	vm_text = "Sequence en cours : " ++ vm_text
	DB_CTRL_TITLE@(vm_fenetre_TEC,"LI_status",vm_text)

	/*A MAJ du mode automatique sur le bouton 'BP_manuel' */
	DB_CTRL_TITLE@(vm_fenetre_TEC,"BP_manuel","pix_auto")

	if (vm_echangeur_renove = FALSE)
	{
		/*A boucle sur les 27 boutons */
		for j = 1 to 27

			/*A boucle sur la liste des etats dans la sequence */
			for i = 0 to 49 step 2
				 if vm_F_bouton[j,1] = vl_sequence[i] 
						and 	TRIM@(TABS_TO_SPACES@(vm_F_bouton[j,1]))<>""
					ITMA_TEC_pix_select(j,vl_sequence[i+1])
			next i

		next j
	}
	else
	{
		if (vm_appel = "ITMA_TMC")
		{
			/* Fiche Main Courante --> Affichage sur la vue existante */
			my_array[0] = 0
			my_array[1] = 0
			my_array[2] = 0
			my_array[3] = 0
			my_array[5] = XDC_NORMAL
			my_array[6] = 0
			
			for j = 1 to ARRAY_SIZE@(vm_F_bouton)-1
				for i = 2 to ARRAY_SIZE@(vl_sequence_renovee)-1 step 2
					if vm_F_bouton[j,1] = vl_sequence_renovee[i] and vm_F_bouton[j,1]<>""
					{
						my_array[4] = TRIM@(TABS_TO_SPACES@(vl_sequence_renovee[i+1]))
						ITMA_TEC_MAJ_ID_renov(j,my_array)
					}
				next i
			next j
		}
		if (vm_appel = "ITMA_TPA")
		{
			/* Plan d'action --> Affichage sur la vue future */
			for j = 1 to ARRAY_SIZE@(vm_F_bouton)-1
				for i = 2 to ARRAY_SIZE@(vl_sequence_renovee)-1 step 2
					if vm_F_bouton[j,1] = vl_sequence_renovee[i] and vm_F_bouton[j,1]<>""
					{
						my_array[4] = TRIM@(TABS_TO_SPACES@(vl_sequence_renovee[i+1]))
						ITMA_TEC_pix_select_renov(j, vl_sequence_renovee[i+1])
					}
				next i
			next j
		}
	}
	
}

if vm_NumEch = 0
{	DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_sequence",TRUE)
	DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_lier",TRUE)
}

DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_executer",True)
if vm_NumEvt > 0 and vm_CleEvt > 0 
{ 	DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_executer",False) 
}

} /* fin if si on n'est pas en auto */

if vm_Appel<>"ITMA_TMC"
{
	if NOT(COM04_Operateur_A_Le_Droit_De(XDC_FAM_EXPLOITATION))
	{
		if vm_NomSite <> XDC_NOM_SITE_CI and NOT vm_mode_formation
		{
			ITMA_TEC_Acces_interdit("ITMA_TEC_pilotage_echangeur")
			RETURN(COM_OK)
		}
		if NOT vm_mode_formation
		{
			DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_sequence",TRUE)
			DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_lier",TRUE)
		}
	}
	else
	{/* DEM743 : secteur */
		if (vm_NomSite <> XDC_NOM_SITE_DN) AND (vm_NomSite <> XDC_NOM_SITE_VC) AND (vm_NomSite <> XDC_NOM_SITE_CI)/*!!!*/
		{
			if NOT vm_mode_formation
			{
				INFO_MESSAGE@(" Commande possible à Nice uniquement ...")
	     		if vm_NomSite <> XDC_NOM_SITE_CI  RETURN(COM_OK)
				DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_sequence",TRUE)
				DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_lier",TRUE)
			}
		}
	}

	/*A Abonnement au differents services */ 
	if (vm_echangeur_renove = FALSE)
	{
		vl_erreur = ITMA_TEC_Abt_Telealarmes(XDC_DEBUT_ABONNEMENT_EQUEXT,vm_NomSite)
		if (vl_erreur <> COM_NOK) { vl_abt_alarmes = TRUE }
		vl_erreur = ITMA_TEC_Abt_Etat_Panneaux(XDC_DEBUT_ABONNEMENT_EQUEXT,vm_NomSite)
		if (vl_erreur <> COM_NOK) { vl_abt_panneau = TRUE }
		vl_erreur =	 ITMA_TEC_Abt_Etat_Seq_Ech(XDC_DEBUT_ABONNEMENT_EQUEXT,vm_NomSite)
		if (vl_erreur <> COM_NOK) { vl_abt_sequence = TRUE }
	}
	else
	{
		/*vl_erreur = ITMA_TEC_Abt_Telealarmes(XDC_DEBUT_ABONNEMENT_EQUEXT,vm_NomSite)
		if (vl_erreur <> COM_NOK) { vl_abt_alarmes = TRUE }*/
		vl_erreur = ITMA_TEC_Abt_Etat_Panneaux_renov(XDC_DEBUT_ABONNEMENT_EQUEXT,vm_NomSite)
		if (vl_erreur <> COM_NOK) { vl_abt_panneau = TRUE }
		vl_erreur =	 ITMA_TEC_Abt_Etat_Seq_Ech_renov(XDC_DEBUT_ABONNEMENT_EQUEXT,vm_NomSite)
		if (vl_erreur <> COM_NOK) { vl_abt_sequence = TRUE }
	}
}
else
{
	if (vm_auto <> 1 )
	{
	DB_CTRL_TITLE@(vm_fenetre_TEC,"LI_tmc",vl_lib_tmc)
	DB_CTRL_DISPLAY@(vm_fenetre_TEC,"LI_tmc",TRUE)
	DB_TITLE@(vm_fenetre_TEC,"Signalisation Echangeur")
	}
}

if ( vm_auto=1 and vl_pix_auto = "pix_auto" )
{
	vl_fenetre_active = FALSE
		
	/*A***************************************************
			Pilotage en Automatique
	*************************************************/
	/*A 	
	Sequence AUTRE interdite en pilotage automatique
	*/
	if vm_NumSequence = 3
	{	INFO_MESSAGE@
		("Choisissez une séquence connue de la GTC")
	}
	else
	{

	/*A modif code retour pour PA */
	if SUBSTRING@(va_appelant,1,8)="ITMA_TPA" 
	and vm_NumSequence = vm_Echangeur.Sequence
	{ vm_mode_PA=COM_VALIDE }
	else	{ vm_mode_PA=COM_REFUSE }

	/*A Set du flag d'execution de sequence */
	vm_exe_seq_en_cours = True


	/*A Commande de la sequence vers SYBASE */
	if vm_NumSequence <>2
	{
		if NOT vm_mode_formation
		{
			if (vm_echangeur_renove = TRUE)
			{
				' GTC renovee
				vm_NumAction = ITMA_TEC_Cmd_Seq_Ech_renov (	vl_Poste,	XDC_FAUX,	vm_NumSequence, vm_NumEch	)
			}
			else
			{
				vm_NumAction = ITMA_TEC_Cmd_Seq_Ech (	vl_Poste,	XDC_FAUX,	vm_NumSequence	)
			}
		}
	}
	else 
	{ 	
   	   if NOT vm_mode_formation
		ITMA_TEC_Cmd_Fin_Ech 
		(	vm_Echangeur.NumEqt,
			XDC_FAUX,
			vm_Echangeur.NomSite ) 
	}


  }
		   				

}
else
	vl_fenetre_active = TRUE

	
/*A tant que la fenetre est active */
WHILE (vl_fenetre_active)

	/* affichage de la liste */
	DB_DISPLAY@(vm_fenetre_TEC)

	/*A capture de l'evenement dans la BD TCA */
	vl_controle_sortie = DB_EXIT_CTRL@(vm_fenetre_TEC)

	/*A si l'evenement n'est pas un poke & verrou=vrai */
	if vl_controle_sortie<>"poke_" and SYSTEM_VAR@(vg_verrou)
		/*A reset de l'evenement */
		{ vl_controle_sortie = NULL }

	/* selon l'evenement */
	CASE OF vl_controle_sortie

		/*A sur action quitter */
		CASE "BP_quitter"
			/*A la fenetre n'est plus active */
			vl_fenetre_active = FALSE
			if  vm_Appel="ITMA_TPA"
				RETURN(vm_mode_PA)


		/*A sur action lier FMC */
		CASE "BP_lier"

			vl_text = "Status : appel lien FMC"
			DB_CTRL_TITLE@(vm_fenetre_TEC,"LI_status",vl_text)

			/*B on lance la tache de recherche d'evt cause*/
			tl_data=PEND_FOR_NEW_TASK@("ITMA_COM_Liste_Causes",
									"ITMA_TEC_pilotage_echangeur")
			tm_liste_causes=tl_data[0]
			/*B affiche la liste des evts a traiter*/
			DB_CTRL_DISPLAY@(vm_fenetre_TEC,"LI_Evenements",TRUE)
			DB_CTRL_DISPLAY@(vm_fenetre_TEC,"TA_Evenements",TRUE)
			DB_CTRL_RETURN_ON_CHANGE@(vm_fenetre_TEC,"TA_Evenements",
						TRUE)
			DB_TABLE_SET_MARKER_WIDTH@(vm_fenetre_TEC, "TA_Evenements", 25)
			DB_TABLE_ALLOW_COLUMN_RESIZING@(vm_fenetre_TEC,
					"TA_Evenements",True)
			tl_titres[0] = COM_CAUSE_NUMERO,COM_CAUSE_LONG_NUMERO
			tl_titres[1] = COM_CAUSE_CLE,COM_CAUSE_LONG_CLE
			tl_titres[2] = COM_CAUSE_TYPE,COM_CAUSE_LONG_TYPE
			tl_titres[3] = COM_CAUSE_DATE,COM_CAUSE_LONG_DATE
			tl_titres[4] = COM_CAUSE_LOCALISATION,
									COM_CAUSE_LONG_LOCALISATION
			DB_TABLE_SET_DATA@(vm_fenetre_TEC,
					"TA_Evenements",tl_data[1],tl_titres)
			DB_TABLE_MARKER_PIXMAPS@(vm_fenetre_TEC, "TA_Evenements", 0, tl_data[2])

		
		/*B selection d'un element dans la liste des fiches a traiter*/
		CASE "TA_Evenements"
			vl_text = "Status : selection evenement"
 			DB_CTRL_TITLE@(vm_fenetre_TEC,"LI_status",vl_text)

			tl_retour=ITMA_COM_Validite_Cause("ITMA_TEC_pilotage_echangeur",
									vm_fenetre_TEC,
									tm_liste_causes)
			vm_NumEvt = tl_retour[0][0]
			vm_CleEvt = tl_retour[0][1]
			vl_fmc = tl_retour[1]
			vl_text=TRIM@(SUBSTRING@(vl_fmc,1,46))
			vl_fmc=vl_text ++ "  " ++ TRIM@(SUBSTRING@(vl_fmc,60,18))

			DB_CTRL_DISPLAY@(vm_fenetre_TEC,"LI_Evenements",FALSE)
			DB_CTRL_DISPLAY@(vm_fenetre_TEC,"TA_Evenements",FALSE)
			DB_CTRL_TITLE@(vm_fenetre_TEC,"LI_fmc",vl_fmc)

			if vm_NumEvt = 0 or vm_CleEvt = 0 
			{ DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_executer",True) }
			else
			{ DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_executer",False) }



		/*A sur action refuser */
		CASE "BP_refuser"

			vm_mode_PA = COM_REFUSE
			DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_executer",True)
			DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_explication",True)
			DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_refuser",True)
			DB_CTRL_DISPLAY@(vm_fenetre_TEC,"LI_remarque",False)
			DB_CTRL_DISPLAY@(vm_fenetre_TEC,"ID_remarque",False)
			DB_CTRL_DISPLAY@(vm_fenetre_TEC,"BE_remarque",False)

			/*A MAJ du message status */
			vl_text = "Status : Refus de la proposition de plan d'action !!!"
			DB_CTRL_TITLE@(vm_fenetre_TEC,"LI_status",vl_text)

		/*A sur action quitter2 */
		CASE "BP_quitter2"
			IF vm_mode_formation
				RETURN (COM_QUITTE)
			/*A la fenetre n'est plus active */
			vl_fenetre_active = FALSE

		/*A sur action 'BP_sequence' */
		CASE "BP_sequence"

			/*A appel la liste des sequences */
			if (vm_echangeur_renove = FALSE)
			{
				vl_sequence = Pend_For_New_Task@("ITMA_TEC_sequence",vl_echangeur[1])
				/*A si retour d'une sequence */
				if vl_sequence[0] <> -1
				{
			
					/*A Effacer le bouton de discordance séquence */
					DB_CTRL_DISPLAY@(vm_fenetre_TEC,"BP_defaut",FALSE)

					/*A Reset du flag d'execution de sequence */
					vm_exe_seq_en_cours = False
		
					/*A Griser le bouton d'explication et de refus */
					DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_explication",True)
					DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_refuser",True)
		
					/*A Effacer la zone de remarque */
					DB_CTRL_DISPLAY@(vm_fenetre_TEC,"LI_remarque",False)
					DB_CTRL_DISPLAY@(vm_fenetre_TEC,"ID_remarque",False)
					DB_CTRL_DISPLAY@(vm_fenetre_TEC,"BE_remarque",False)

					/*A MAJ du n° de sequence selectionné */
					vm_NumSequence =  SYSTEM_VAR@("NumSequence")+0

					/*A MAJ du message status */
					vm_text = SYSTEM_VAR@("sequence")
					vm_text = "Sequence en cours : " ++ vm_text
					DB_CTRL_TITLE@(vm_fenetre_TEC,"LI_status",vm_text)

					/*A dégriser le bouton 'BP_executer' */
					if vm_NumEvt = 0 or vm_CleEvt = 0 
					{ DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_executer",True) }
					else
					{ DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_executer",False) }

					/*A griser les boutons de resultats */
					DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_ok",True)
					DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_nul",True)
	 
					/*A MAJ du mode automatique sur le bouton 'BP_manuel' */
					DB_CTRL_TITLE@(vm_fenetre_TEC,"BP_manuel","pix_auto")

					/*A boucle sur les 27 boutons */
					for j = 1 to 27

						/*A boucle sur la liste des etats dans la sequence
								 pour MAJ des boutons */
						for i = 0 to 49 step 2
						 if vm_F_bouton[j,1] = vl_sequence[i] 
									 and vm_F_bouton[j,1]<>""
							ITMA_TEC_pix_select(j,vl_sequence[i+1])
						next i

					next j
				}
				}
			else
			{
				vl_sequence = Pend_For_New_Task@("ITMA_TEC_sequence_renov",vm_codes_echangeurs_renoves[ARRAY_INDEX@(vm_noms_echangeurs_renoves, vl_echangeur[2])]);
				/*A si retour d'une sequence */
				if vl_sequence[0] <> -1
				{
					/*A Effacer le bouton de discordance séquence */
					DB_CTRL_DISPLAY@(vm_fenetre_TEC,"BP_defaut",FALSE)

					/*A Reset du flag d'execution de sequence */
					vm_exe_seq_en_cours = False
		
					/*A Griser le bouton d'explication et de refus */
					DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_explication",True)
					DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_refuser",True)
		
					/*A Effacer la zone de remarque */
					DB_CTRL_DISPLAY@(vm_fenetre_TEC,"LI_remarque",False)
					DB_CTRL_DISPLAY@(vm_fenetre_TEC,"ID_remarque",False)
					DB_CTRL_DISPLAY@(vm_fenetre_TEC,"BE_remarque",False)

					/*A MAJ du n° de sequence selectionné */
					vm_NumSequence =  SYSTEM_VAR@("NumSequence")+0

					/*A MAJ du message status */
					vm_text = SYSTEM_VAR@("sequence")
					vm_text = "Sequence en cours : " ++ vm_text
					DB_CTRL_TITLE@(vm_fenetre_TEC,"LI_status",vm_text)

					/*A dégriser le bouton 'BP_executer' */
					if vm_NumEvt = 0 or vm_CleEvt = 0 
					{ DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_executer",True) }
					else
					{ DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_executer",False) }

					/*A griser les boutons de resultats */
					DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_ok",True)
					DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_nul",True)
	 
					/*A MAJ du mode automatique sur le bouton 'BP_manuel' */
					DB_CTRL_TITLE@(vm_fenetre_TEC,"BP_manuel","pix_auto")
					
					/*A boucle sur les 27 boutons */
					for j = 1 to ARRAY_SIZE@(vm_F_bouton)-1

						/*A boucle sur la liste des etats dans la sequence */
						for i = 0 to ARRAY_SIZE@(vl_sequence)-1 step 2
						if vm_F_bouton[j,1] = vl_sequence[i]  and vm_F_bouton[j,1]<>""
							ITMA_TEC_pix_select_renov(j,vl_sequence[i+1])
						next i

					next j
				}				
			}



		/*A sur action 'BP_manuel' */
		CASE "BP_manuel"
			vl_titre = DB_CTRL_GET_TITLE@(vm_fenetre_TEC,"BP_manuel")
			if vl_titre = "pix_manu" 
			{info_message@("Commande Individuelle.")}
			else {info_message@("Commande Sequence Echangeur.")}


		/*A sur action executer */
		CASE "BP_executer"
/* DEM743 : secteur */
	  		 if vm_NomSite <> "DN" and vm_NomSite <> "VC" AND (vm_NomSite <> XDC_NOM_SITE_CI) /*!!*/ and  NOT vm_mode_formation
	   		{	INFO_MESSAGE@(" Commande possible à Nice uniquement ...")
	   		}
	   		else
	   		{
				if vm_NumSequence = 0
				{	INFO_MESSAGE@(" Choisissez une séquence ...")
				}

				else
				{
					if vm_NumEvt<>0 and vm_CleEvt<>0
					{
		
				   		/*A Effacer le bouton de discordance séquence */
			   	   		DB_CTRL_DISPLAY@(vm_fenetre_TEC,"BP_defaut",FALSE)

				   		/*A ***********************************************
								Pilotage en Manuel
						*****************************************************/
				   		if DB_CTRL_GET_TITLE@(vm_fenetre_TEC,"BP_manuel")
									 = "pix_manu"		
				   		{
							if (vm_echangeur_renove = FALSE)
							{
								/* GTC non renovee */
								/*A reset des chaines de caractères */
								vl_panneau = ""
								vl_etat = ""
			
								/*A pour tout les bouton panneau */
								for j = 1 to 27

									/*A 
									si bouton existant & pas en position neutre
									 */
									if vm_F_bouton[j,1]<>""
									{
										if vm_F_bouton[j,0]>0  
											and  vm_F_bouton[j,4]>0
										{ 	vl_etat = vl_etat ++
												 vm_F_bouton[j,0] ++ ","
												vl_panneau = vl_panneau ++
												 vm_F_bouton[j,4] ++ ","
										}
				
									}
								next j
								vl_etat = vl_etat ++ "0"
								vl_panneau = vl_panneau ++ "0"

			
								/*A MAJ de la ligne de status */
								DB_CTRL_TITLE@(vm_fenetre_TEC,"LI_status",
									"Executer en manuel ( à confirmer ! )")	
		
								/*A Appel de la macro de pilotage */
								if NOT vm_mode_formation
									ITMA_TEC_pilote_panneau( vm_NumEch,
	 								vl_panneau, vl_etat, vm_NumSequence)

								/*A MAJ des boutons de commandes */
								DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_ok",False)
								DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_nul",False)	
								DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_sequence",
														True)	
								DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_executer",
														True)	
								DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_quitter",True)	
								DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_lier",True)	
		
								/*A Commande de la sequence vers SYBASE */
								if vm_NumSequence <>2
								{
								   if NOT vm_mode_formation
									vm_NumAction = ITMA_TEC_Cmd_Seq_Ech
												 (	vl_Poste,
													XDC_VRAI,
													vm_NumSequence)
								}
								else 
								{ 								   
								   if NOT vm_mode_formation
									ITMA_TEC_Cmd_Fin_Ech 
												(	vm_Echangeur.NumEqt,
													XDC_VRAI,
													vm_Echangeur.NomSite) 
								}
								/*A modif code retour pour PA */
								if SUBSTRING@(va_appelant,1,8)="ITMA_TPA" 
								{ 	vm_mode_PA=COM_REFUSE }
								else	{ vm_mode_PA=COM_QUITTE }
							}
							else
							{
								/* GTC renovee */
					  			vl_panneau = ""
					  			vl_etat = ""
								vl_type_panneau = ""
					  
					  			for j = 1 to ARRAY_SIZE@(vm_F_bouton)-1
					  
					  				/*A construction des tableaux à envoyer à la tâche relais */
					  				if vm_F_bouton[j,1]<>""
					  				{
					  					if vm_F_bouton[j,0]>0 and vm_F_bouton[j,4]>0
					  					{
					                        vl_etat = vl_etat ++ vm_F_bouton[j,0] ++ ","
					  						vl_panneau = vl_panneau ++ vm_F_bouton[j,4] ++ ","
											vl_type_panneau = vl_type_panneau ++ vm_F_bouton[j,12] ++ ","
					  					}
					  				}
					  			next j
					  			
					            vl_etat = vl_etat ++ "0"
					  			vl_panneau = vl_panneau ++ "0"
								vl_type_panneau = vl_type_panneau ++ "0"

					  			/*A MAJ de la ligne de status */
					  			DB_CTRL_TITLE@(vm_fenetre_TEC,"LI_status", "Execution en manuel (mode renove) ( à confirmer ! )")	

					  			/*A Appel de la macro de pilotage */
					  			ITMA_TEC_pilote_panneau_renov(vm_NumEch, vl_type_panneau, vl_panneau, vl_etat, vm_NumSequence)
					            					  
								/*A MAJ des boutons de commandes */
								DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_ok",False)
								DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_nul",False)	
								DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_sequence",
														True)	
								DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_executer",
														True)	
								DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_quitter",True)	
								DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_lier",True)							
								/*A Commande de la sequence vers SYBASE */
								if vm_NumSequence <>2
								{
								   if NOT vm_mode_formation
									vm_NumAction = ITMA_TEC_Cmd_Seq_Ech_renov
												 (	vl_Poste,
													XDC_VRAI,
													vm_NumSequence,vm_NumEch)
								}
								else 
								{ 								   
								   if NOT vm_mode_formation
									ITMA_TEC_Cmd_Fin_Ech_renov 
												(	vm_Echangeur.NumEqt,
													XDC_VRAI,
													vm_Echangeur.NomSite) 
								}
								/*A modif code retour pour PA */
								if SUBSTRING@(va_appelant,1,8)="ITMA_TPA" 
								{ 	vm_mode_PA=COM_REFUSE }
								else	{ vm_mode_PA=COM_QUITTE }							}
						}
		
						/*A***************************************************
								Pilotage en Automatique
						*************************************************/
						if DB_CTRL_GET_TITLE@(vm_fenetre_TEC,"BP_manuel") 
							= "pix_auto"
						{
							/*A 	
							Sequence AUTRE interdite en pilotage automatique
							*/
							if vm_NumSequence = 3
							{	INFO_MESSAGE@
								("Choisissez une séquence connue de la GTC")
							}

							else
							{

								/*A modif code retour pour PA */
								if SUBSTRING@(va_appelant,1,8)="ITMA_TPA" 
								and vm_NumSequence = vm_Echangeur.Sequence
								{ vm_mode_PA=COM_VALIDE }
								else	{ vm_mode_PA=COM_REFUSE }

								/*A Set du flag d'execution de sequence */
								vm_exe_seq_en_cours = True

								DB_CTRL_TITLE@(vm_fenetre_TEC,"LI_status",
										"Executer en automatique")
								DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_ok",True)
								DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_nul",
										True)		
								DB_CTRL_GRAYED@(vm_fenetre_TEC,
										"BP_sequence",False)	
								DB_CTRL_GRAYED@(vm_fenetre_TEC,
										"BP_executer",True)	
								DB_CTRL_GRAYED@(vm_fenetre_TEC,
										"BP_quitter",False)	
								DB_CTRL_GRAYED@(vm_fenetre_TEC,
										"BP_lier",False)	

								/*A Commande de la sequence vers SYBASE */
								if vm_NumSequence <>2
								{
							   	   if NOT vm_mode_formation
								   {
									   if (vm_echangeur_renove = FALSE)
									    {
											vm_NumAction = ITMA_TEC_Cmd_Seq_Ech 
											(	vl_Poste,
												XDC_FAUX,
												vm_NumSequence	)
										}
										else
										{
											vm_NumAction = ITMA_TEC_Cmd_Seq_Ech_renov
											(	vl_Poste,
												XDC_FAUX,
												vm_NumSequence, vm_NumEch	)
										}
									}
								}
								else 
								{ 	
							   	   if NOT vm_mode_formation
								   {
										if (vm_echangeur_renove = FALSE)
										{
											ITMA_TEC_Cmd_Fin_Ech 
											(	vm_Echangeur.NumEqt,
												XDC_FAUX,
												vm_Echangeur.NomSite ) 
											
										}
										else
										{
											ITMA_TEC_Cmd_Fin_Ech_renov
											(	vm_Echangeur.NumEqt,
												XDC_FAUX,
												vm_Echangeur.NomSite) 
											
										}
								    }
								}


							  }
		   				}
						vm_NumEvt = 0
						vm_CleEvt = 0
						vm_Echangeur.NumEvt = 0
						vm_Echangeur.CleEvt = 0
 						DB_CTRL_TITLE@(vm_fenetre_TEC,"LI_fmc","")
					}
					else
	   				{
						info_message@("Veuillez d'abord lier cette action a une F.M.C...")
	   				}
				}
			}

		/*A sur action BP_actuel */
		CASE "BP_actuel"
			info_message@
					("Zone correspondant à l'état actuel des panneaux ...")

		/*A sur action BP_nouveau */
		CASE "BP_nouveau"
			info_message@("Zone de commande des panneaux ...")

		/*A sur action BP_ok */
		CASE "BP_ok"
			/*A MAJ de l'IHM */
			vl_text = "Confirmation de l'operateur sur OK ..."
			DB_CTRL_TITLE@(vm_fenetre_TEC,"LI_status",vl_text)
			DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_ok",True)
			DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_nul",True)
			DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_sequence",False)
			DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_quitter",False)
			DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_lier",False)	
			DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_executer",False)	

			/*A renvoi à la base du retour OK operateur */
			if (vm_echangeur_renove = FALSE)
			{
				vl_erreur = ITMA_TEC_Fin_Cmd_Manu_Ech (	vm_NumAction,
											XDC_VRAI,
											vm_NumSequence,
											vm_Echangeur.NomSite)
			}
			else
			{
				vl_erreur = ITMA_TEC_Fin_Cmd_Manu_Ech_renov (	vm_NumAction,
											XDC_VRAI,
											vm_NumSequence,
											vm_Echangeur.NomSite)
			}
		
		/*A sur action BP_nul */
		CASE "BP_nul"

			/*A MAJ de l'IHM */
			vl_text = "Confirmation de l'operateur sur NUL ..."
			DB_CTRL_TITLE@(vm_fenetre_TEC,"LI_status",vl_text)
			DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_ok",True)
			DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_nul",True)
			DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_sequence",False)
			DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_quitter",False)
			DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_lier",False)	
			DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_executer",False)	

			/*A renvoi à la base du retour NUL operateur */
			if (vm_echangeur_renove = FALSE)
			{
				vl_erreur = ITMA_TEC_Fin_Cmd_Manu_Ech (	vm_NumAction,
											XDC_FAUX,
											vm_NumSequence,
											vm_Echangeur.NomSite)
			}
			else
			{
				vl_erreur = ITMA_TEC_Fin_Cmd_Manu_Ech_renov (	vm_NumAction,
											XDC_FAUX,
											vm_NumSequence,
											vm_Echangeur.NomSite)
			}
			
		
		/*A sur action BP_explication */
		CASE "BP_explication"
			/* appel de MTEX avec passage en argument de l'explication */
			vl_erreur = NEW_TASK@("ITMA_TEX_Explication_Propo",
					"ITMA_TEC_pilotage_d_un_echangeur",vl_explication)

		/*A sur action panneau 1 */
		CASE "BP_cmd1"
			ITMA_TEC_pix_suivant(1)
	
		/*A sur action panneau 2 */
		CASE "BP_cmd2"
			ITMA_TEC_pix_suivant(2)

		/*A sur action panneau 3 */
		CASE "BP_cmd3"
			ITMA_TEC_pix_suivant(3)

		/*A sur action panneau 4 */
		CASE "BP_cmd4"
			ITMA_TEC_pix_suivant(4)

		/*A sur action panneau 5 */
		CASE "BP_cmd5"
			ITMA_TEC_pix_suivant(5)

		/*A sur action panneau 6 */
		CASE "BP_cmd6"
			ITMA_TEC_pix_suivant(6)

		/*A sur action panneau 7 */
		CASE "BP_cmd7"
			ITMA_TEC_pix_suivant(7)

		/*A sur action panneau 8 */
		CASE "BP_cmd8"
			ITMA_TEC_pix_suivant(8)

		/*A sur action panneau 9 */
		CASE "BP_cmd9"
			ITMA_TEC_pix_suivant(9)
		
		/*A sur action panneau 10 */
		CASE "BP_cmd10"
			ITMA_TEC_pix_suivant(10)
				
		/*A sur action panneau 11 */
		CASE "BP_cmd11"
			ITMA_TEC_pix_suivant(11)

		/*A sur action panneau 12 */
		CASE "BP_cmd12"
			ITMA_TEC_pix_suivant(12)

		/*A sur action panneau 13 */
		CASE "BP_cmd13"
			ITMA_TEC_pix_suivant(13)

		/*A sur action panneau 14 */
		CASE "BP_cmd14"
			ITMA_TEC_pix_suivant(14)

		/*A sur action panneau 15 */
		CASE "BP_cmd15"
			ITMA_TEC_pix_suivant(15)

		/*A sur action panneau 16 */
		CASE "BP_cmd16"
			ITMA_TEC_pix_suivant(16)

		/*A sur action panneau 17 */
		CASE "BP_cmd17"
			ITMA_TEC_pix_suivant(17)

		/*A sur action panneau 18 */
		CASE "BP_cmd18"
			ITMA_TEC_pix_suivant(18)

		/*A sur action panneau 19 */
		CASE "BP_cmd19"
			ITMA_TEC_pix_suivant(19)

		/*A sur action panneau 20 */
		CASE "BP_cmd20"
			ITMA_TEC_pix_suivant(20)

		/*A sur action panneau 21 */
		CASE "BP_cmd21"
			ITMA_TEC_pix_suivant(21)
		
		/*A sur action panneau 22 */
		CASE "BP_cmd22"
			ITMA_TEC_pix_suivant(22)

		/*A sur action panneau 23 */
		CASE "BP_cmd23"
			ITMA_TEC_pix_suivant(23)

		/*A sur action panneau 24 */
		CASE "BP_cmd24"
			ITMA_TEC_pix_suivant(24)

		/*A sur action panneau 25 */
		CASE "BP_cmd25"
			ITMA_TEC_pix_suivant(25)

		/*A sur action panneau 26 */
		CASE "BP_cmd26"
			ITMA_TEC_pix_suivant(26)
				
		/*A sur action panneau 27 */
		CASE "BP_cmd27"
			ITMA_TEC_pix_suivant(27)

		/*A sur reception de poke */
		CASE "poke_"
	
			/*A suivant le canal de reception de poke */
			CASE OF DB_GET_POKE@(vm_fenetre_TEC)

				/*A si poke de fin de canal : fermeture de fenetre */
				CASE COM_CANAL_FIN
					/*A la fenetre n'est plus active */
					vl_fenetre_active = FALSE

				/*A si poke de reception d'abonnement : MAJ du panneau */
				CASE COM_CANAL_MTEC_PAN

					/*A capture du message */
					vl_message = DB_GET_POKE_DATA@(vm_fenetre_TEC)

						/*A trace de la reception du message */
					vm_text = COM09_Date_Courante() ++ "   MsgPoke MTEC_PAN : "
					if (vm_echangeur_renove = FALSE)
					{
						vm_text =  vm_text ++ vl_message[0] ++ " (non renove) "
						COM01_Trace(0,vm_text)

						/*A décomposition des messages en tableau */
						vl_mess = ARRAY_FROM_STRING@(vl_message[0],",")
			
						if (vl_mess[0] = XDC_EQT_ECH) and 
								(vl_mess[1]+0 = vm_NumEch+0)
						{				
							/*A reset de l'index */
							vl_indexpt = -1

							/*A 
							on  boucle sur tout les panneau de l'IHM */
							for j = 0 to 27
								if vm_F_bouton[j,4]=vl_mess[2] and vl_mess[2]<>0  
								then vl_indexpt = j
							next j

							/*A 
							MAJ du panneau sur l'IHM (avec gestion du defaut)
							*/
							if vl_indexpt<>-1 
							{
								if vl_mess[4]=XDC_NORMAL
								{
									ITMA_TEC_MAJ_ID(vl_indexpt,vl_mess[3])
									vl_text = "Réception état panneau "				
											 ++vm_F_bouton[vl_indexpt,1]
									DB_CTRL_TITLE@( vm_fenetre_TEC,
												"LI_status",vl_text)
								}
								else
								{	
									ITMA_TEC_MAJ_ID(vl_indexpt,-1)
									vl_text = 
											"Panneau "++
											vm_F_bouton[vl_indexpt,1] ++ " en defaut !"
									DB_CTRL_TITLE@( vm_fenetre_TEC,
													"LI_status",vl_text)
								}
							}
						}
					}
					else
					{
						/* GTC renovee */
						vl_messageDecoupe = ARRAY_FROM_STRING@(vl_message[0],"|")
						vl_taille2 = ARRAY_SIZE@(vl_messageDecoupe)

						/*A trace de la reception du message */
						vm_text = COM09_Date_Courante() ++ "   MsgPoke MTEC_PAN : (renove)"
						for i = 0 to vl_taille2 - 1
							vm_text = vm_text ++ vl_messageDecoupe[i] ++ " / "
						next i
						COM01_Trace(0,vm_text)

						'-- parcours du tableau des messages
						for i = 0 to vl_taille2 - 1
						
							/*A décomposition des messages en tableau */
							vl_mess = ARRAY_FROM_STRING@(vl_messageDecoupe[i],",")
					  
							if ( vl_mess[0] = XDC_EQT_ECH and vl_mess[1]+0 = vm_NumEch+0 )
							{				
								/*A on  boucle sur tous les panneaux présents sur l'IHM */
								if ( vl_mess[3] <> 0 )
								{
									vl_taille = ARRAY_SIZE@(vm_F_bouton)
									for j = 0 to vl_taille-1
										'-- comparaison avec type SAE et ID SAE au lieu de ID Intranet
										if ( vm_F_bouton[j,12] = vl_mess[2] and vm_F_bouton[j,4] = vl_mess[3] )
										{
											'-- MAJ du panneau sur l'IHM (avec gestion defaut et mode)
											ITMA_TEC_MAJ_ID_renov(j, vl_mess)
											break j
										}
									next j
								}
							}
							
						next i						
					}

				/*A si poke de reception d'abonnement etat sequence */
				CASE COM_CANAL_MTEC_SEQ
	
					/*A capture du message */
					vl_message = DB_GET_POKE_DATA@(vm_fenetre_TEC)

					/*A trace de la reception du message */
					vm_text = COM09_Date_Courante() ++ 
									"   MsgPoke MTEC_SEQ : "
					vm_text =  vm_text ++ vl_message[0]
					COM01_Trace(0,vm_text)

				/*	info_message@(vm_NumSequence)*/

					/*A décomposition du message reçu en tableau */
					vl_mess = ARRAY_FROM_STRING@(vl_message[0],",")
		
					/*A transfo. en numérique de variables */
					vl_mess[2] = vl_mess[2] + 0		
					vm_NumSequence = vm_NumSequence + 0

					if (vl_mess[0] = XDC_EQT_ECH) 
							and 	(vl_mess[1] = vm_NumEch+0)
							and vl_mess[2] = vm_NumSequence 
							and vl_mess[3] = XDC_DEFAUT 
							and vm_exe_seq_en_cours
					{
						DB_CTRL_DISPLAY@(vm_fenetre_TEC,"BP_defaut",TRUE)
						vl_defaut_sequence = TRUE
					}

					if (vl_mess[0] = XDC_EQT_ECH) and 
						(vl_mess[1] = vm_NumEch+0)
						and vl_mess[2] = vm_NumSequence and 
						vl_mess[3] = XDC_NORMAL 
						and vm_exe_seq_en_cours
					{
						DB_CTRL_DISPLAY@(vm_fenetre_TEC,
												"BP_defaut",FALSE)
						vl_defaut_sequence = FALSE
					}

				/*A si poke de reception d'abonnement alarmes */
				CASE COM_CANAL_MTEC_ALM

					/*A capture du message */
					vl_message = DB_GET_POKE_DATA@(vm_fenetre_TEC)

					/*A trace de la reception du message */
					vm_text = COM09_Date_Courante() ++ 
										"   MsgPoke MTEC_ALM : "
					vm_text =  vm_text ++ vl_message[0]
					COM01_Trace(0,vm_text)

					/*A décomposition du message reçu en tableau */
					vl_mess = ARRAY_FROM_STRING@(vl_message[0],",")
		
					if (vl_mess[0] = XDC_EQT_ECH) and 
						(vl_mess[1] = vm_NumEch+0)
					{
						vl_defaut = 0
						if vl_mess[4]=XDC_DEFAUT
						{	DB_CTRL_GRAYED@(vm_fenetre_TEC,"LI_lampe",FALSE)
							vl_defaut = 1
						}
						else
						{ 	DB_CTRL_GRAYED@(vm_fenetre_TEC,"LI_lampe",TRUE)
						}
			
						if vl_mess[2]=XDC_DEFAUT 
						{
							DB_CTRL_GRAYED@(vm_fenetre_TEC,"LI_nrj",FALSE)
							vl_defaut = 2
						}
						else
						{
							DB_CTRL_GRAYED@(vm_fenetre_TEC,"LI_nrj",TRUE)
						}

						if vl_mess[3]=XDC_DEFAUT 
						{	DB_CTRL_GRAYED@(vm_fenetre_TEC,"LI_local",FALSE)
							vl_defaut = 2
						}
						else 
						{	DB_CTRL_GRAYED@(vm_fenetre_TEC,"LI_local",TRUE)
						}

						if vl_defaut>0
						{	DB_CTRL_DISPLAY@(vm_fenetre_TEC,"ID_defaut",TRUE)
							DB_CTRL_GRAYED@(vm_fenetre_TEC,"LI_titre",FALSE)}
						else
						{   DB_CTRL_DISPLAY@(vm_fenetre_TEC,"ID_defaut",FALSE)
						}
					}
	
			ENDCASE

	ENDCASE

/*A fin tant que */
WEND

/*B Fermer des abonnements */
if (vm_echangeur_renove = FALSE)
{
	if (vl_abt_alarmes)
	{
		ITMA_TEC_Abt_Telealarmes(XDC_FERMER_ABONNEMENT_EQUEXT,vm_NomSite)
	}
	if (vl_abt_panneau)
	{
		ITMA_TEC_Abt_Etat_Panneaux(XDC_FERMER_ABONNEMENT_EQUEXT,vm_NomSite)
	}
	if (vl_abt_sequence)
	{
		ITMA_TEC_Abt_Etat_Seq_Ech(XDC_FERMER_ABONNEMENT_EQUEXT,vm_NomSite)
	}
}
else
{
	/*if (vl_abt_alarmes)
	{
		ITMA_TEC_Abt_Telealarmes(XDC_FERMER_ABONNEMENT_EQUEXT,vm_NomSite)
	}*/
	if (vl_abt_panneau)
	{
		ITMA_TEC_Abt_Etat_Panneaux_renov(XDC_FERMER_ABONNEMENT_EQUEXT,vm_NomSite)
	}
	if (vl_abt_sequence)
	{
		ITMA_TEC_Abt_Etat_Seq_Ech_renov(XDC_FERMER_ABONNEMENT_EQUEXT,vm_NomSite)
	}
}

/*B trace de la fin de traitement */
	
vm_text = COM09_Date_Courante() ++ "   User : " ++ vm_NomOperateur
vm_text = "Stop ITMA_TEC_pilotage_echangeur " ++ vm_text
COM01_Trace(0,vm_text)

RETURN(vm_mode_PA)

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :	Choisir une sequence de commande de panneaux pour le PA
*
*  ----------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TEC_sequence_PA(va_NomEchangeur,va_NumSequence)

/*
* ARGUMENTS EN ENTREE : 
*	va_NomEchangeur		: le nom de l'echangeur
*	va_NumSequence	: le n° de la sequence désirée
*
* ARGUMENTS EN SORTIE : Aucun
*
* CODE RETOUR         : la liste des etats des panneaux
*
* CONDITION D'UTILISATION
*   origine de l'appel : Plan d'action
*
* FONCTION
*    Choisir une sequence de commande de panneaux pour le PA
*
---------------------------------------------------------------------------- */


/*A Déclaration des variables statiques */
var		vl_fenetre_TEC
var		vl_fenetre_active
var		vl_controle_sortie
var		i,j					' index de loop 
var		vl_taille				' taille d'une table 
var 		vl_taille2			' taille d'une table 
var		vl_rang				' rang selectionné dans la liste 
var		vl_text				' text à afficher dans le status 

var		vl_F_tpm				' tableau tampon 
var		vl_F_seq				' tableau tampon avec sequence 
var		vl_ligne				' tableau d'une ligne 
var		vl_F_sequence			' fichier de config des sequences 
var		vl_sequence			' sequence selectionné dans la liste 

var		vl_icon 				' graph à afficher dans l'objet 
var		vl_xpos 				' position X de l'objet 
var		vl_ypos 				' position Y de l'objet  
var		vl_titre  			' titre du bouton 
var		vl_titre2  			' titre de l'image digit 
var		vl_trouve
var		vl_seq_trouve
var		vl_longeur


/*A Chargement du fichier de config sequences 
*   ------------------------------------------ */
vl_F_tpm = READ_ASCII_FILE@(REP_CONFIG ++ "pmv/ConfigSequenceEchangeur.cfg")
vl_taille = ARRAY_SIZE@(vl_F_tpm) -1
for i = 1 to vl_taille
	vl_ligne = ARRAY_FROM_STRING@(vl_F_tpm[i],",")
	vl_taille2 = ARRAY_SIZE@(vl_ligne) -1
	for j = 0 to vl_taille2
		vl_F_sequence[i,j]=TRIM@(TABS_TO_SPACES@(vl_ligne[j]))
	next j
next i

/*A construction de la liste des sequences */
vl_taille = ARRAY_SIZE@(vl_F_sequence) -1
i = 1
vl_trouve = 0
for i = 1 to vl_taille
	if vl_F_sequence[i,0] = "--> " ++ va_NomEchangeur
	{ vl_trouve = i }
next i

vl_F_tpm = ""

if vl_trouve <> 0
{
	for i = vl_trouve+1 to vl_taille
		vl_F_tpm[i-vl_trouve-1] = vl_F_sequence[i,1] 
		vl_F_seq[i-vl_trouve-1] = vl_F_sequence[i]
		if IS_NUMERIC_STRING@(vl_F_sequence[i,0])
		{
	 	   if vl_F_sequence[i,0]+0 =  va_NumSequence+0
		   {
			/*A Capture du libellé de la sequence choisie */
			vm_seq_select = vl_F_sequence[i,1]
			SET_SYSTEM_VAR@("sequence",vm_seq_select)
			SET_SYSTEM_VAR@("NumSequence",vl_F_sequence[i,0])
			vl_seq_trouve = i-vl_trouve-1
		    }
		}
		if SUBSTRING@(vl_F_sequence[i+1,0],1,3) = "-->" { i = vl_taille}
	next i
}
else
{
	info_message@("Pas de sequence pour cet echangeur...")

	/*A Fermeture de la fenetre */
	vl_sequence[0] = -1
	RETURN(vl_sequence)

}

/*A Capture du libellé de la sequence choisie */
/*
vm_seq_select = vl_F_tpm[va_NumSequence]
SET_SYSTEM_VAR@("sequence",vm_seq_select)
SET_SYSTEM_VAR@("NumSequence",vl_F_seq[va_NumSequence,0])
*/
/*A si non existance d'une sequence pour cette selection */
/*if vl_F_seq[va_NumSequence+0,2]>0 */
if vl_seq_trouve > -1
{
	/*A MAJ de vl_sequence */
	for i = 0 to 49
/*		vl_sequence[i] = vl_F_seq[va_NumSequence+0,i+2]*/
		vl_sequence[i] = vl_F_seq[vl_seq_trouve,i+2]+0
	next i
	
	/*A trace de la sequence selectionné */
	COM01_Trace(0,"Choix sequence PA : " ++ vm_seq_select ++ " ---> " ++ vl_F_seq[vl_seq_trouve,0])

	/*A renvoi de la sequence */	
	Return(vl_sequence)
}
else
{
	info_message@("Erreur : Sequence demandee non trouvee")
}

ENDMACRO





/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :	Choisir une sequence de commande de panneaux
*
*  ----------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TEC_sequence(va_NomEchangeur)

/*
* ARGUMENTS EN ENTREE : 
*	va_NomEchangeur	: le nom de l'echangeur
*
* ARGUMENTS EN SORTIE : Aucun
*
* CODE RETOUR         : la liste des etats des panneaux
*
* CONDITION D'UTILISATION
*   Selectionner le bouton 'Appel sequence' dans la vue echangeur
*
* FONCTION
*    Choisir une sequence de commande de panneaux
*
---------------------------------------------------------------------------- */


/*A Déclaration des variables statiques */
var		vl_fenetre_TEC
var		vl_fenetre_active
var		vl_controle_sortie
var		i,j				/* index de loop */
var		vl_taille
var 		vl_taille2
var		vl_rang
var		vl_text			/* text à afficher dans le status */

var		vl_F_tpm			/* tableau tampon */
var		vl_F_seq			/* tableau tampon avec sequence */
var		vl_ligne			/* tableau d'une ligne */
var		vl_F_sequence		/* fichier de config des sequences */
var		vl_sequence		/* sequence selectionné dans la liste */

var		vl_icon 			/* graph à afficher dans l'objet */
var		vl_xpos 			/* position X de l'objet */
var		vl_ypos 			/* position Y de l'objet */ 
var		vl_titre  		/* titre du bouton */
var		vl_titre2  		/* titre de l'image digit */
var		vl_trouve
var		vl_longeur


/*A Chargement du fichier de config sequences 
*   ------------------------------------------ */
vl_F_tpm = READ_ASCII_FILE@(REP_CONFIG ++ "pmv/ConfigSequenceEchangeur.cfg")
vl_taille = ARRAY_SIZE@(vl_F_tpm) -1
for i = 1 to vl_taille
	vl_ligne = ARRAY_FROM_STRING@(vl_F_tpm[i],",")
	vl_taille2 = ARRAY_SIZE@(vl_ligne) -1
	for j = 0 to vl_taille2
		vl_F_sequence[i,j]=TRIM@(TABS_TO_SPACES@(vl_ligne[j]))
	next j
next i

/*A construction de la liste des sequences */
vl_taille = ARRAY_SIZE@(vl_F_sequence) -1
i = 1
vl_trouve = 0
for i = 1 to vl_taille
	if vl_F_sequence[i,0] = "--> " ++ va_NomEchangeur
	{ vl_trouve = i }
next i

vl_F_tpm = ""

if vl_trouve <> 0
{
	for i = vl_trouve+1 to vl_taille
		vl_F_tpm[i-vl_trouve-1] = vl_F_sequence[i,1] 
		vl_F_seq[i-vl_trouve-1] = vl_F_sequence[i]
		if SUBSTRING@(vl_F_sequence[i+1,0],1,3) = "-->" { i = vl_taille}
	next i
}
else
{
	info_message@("Pas de sequence pour cet echangeur...")

	/*A Fermeture de la fenetre */
	vl_sequence[0] = -1
	RETURN(vl_sequence)

}

/*A Ouvertue de la liste des sequences */
vl_fenetre_TEC = DB_LOAD@("ITMA_TEC_liste_sequence")
vm_messages_acceptes[0] = COM_CANAL_FIN
DB_ACCEPT_POKES@ (vl_fenetre_TEC, vm_messages_acceptes)

/*A Positionnement de la fenetre & assignation de la fiche d'aide  
*   ------------------------------------------------------------- */
DB_XPOS@(vl_fenetre_TEC,500)
DB_YPOS@(vl_fenetre_TEC, 500)
DEFINE_HELPFILE@("Liste des sequences", "./aid/ITMA_TEC_liste_sequence.aide")
DB_HELP_TOPIC@(vl_fenetre_TEC,"Liste des sequences")

DB_DISPLAY_ONLY@(vl_fenetre_TEC,True)
DB_DISPLAY@(vl_fenetre_TEC)
DB_DISPLAY_ONLY@(vl_fenetre_TEC,False)

DB_CTRL_RETURN_ON_CHANGE@(vl_fenetre_TEC,"BL_sequence",True)
DB_CTRL_STRINGS@(vl_fenetre_TEC,"BL_sequence",vl_F_tpm)
DB_CTRL_GRAYED@(vl_fenetre_TEC,"BP_valider",True)

/*A Boucle de capture des événements de la boite de dialogue  
*   -------------------------------------------------------- */
vl_fenetre_active = TRUE

/*A tant que la fenetre est active */
WHILE (vl_fenetre_active)

	/* affichage de la liste */
	DB_DISPLAY@(vl_fenetre_TEC)

	/*A capture de l'evenement dans la BD TCA */
	vl_controle_sortie = DB_EXIT_CTRL@(vl_fenetre_TEC)

	/*A si l'evenement n'est pas un poke & verrou = vrai */
	if vl_controle_sortie<>"poke_" and SYSTEM_VAR@(vg_verrou)
		/*A reset de l'evenement */
		vl_controle_sortie = NULL 

	/* selon l'evenement */
	CASE OF vl_controle_sortie

	/*A sur action valider */
	CASE "BP_valider"

		/*A retour de la sequence */
		Return(vl_sequence)

	/*A sur action quitter */
	CASE "BP_quitter"

		/*A Fermeture de la fenetre */
		vl_sequence[0] = -1
		RETURN(vl_sequence)

	/*A sur action quitter */
	CASE "BL_sequence"

		/*A Capture du rang dans la liste des echangeurs */
		vl_rang = DB_CTRL_GET_VALUE@(vl_fenetre_TEC,"BL_sequence")

		/*A Capture du libellé de la sequence choisie */
		vm_text = vl_F_tpm[vl_rang]
		SET_SYSTEM_VAR@("sequence",vm_text)
		SET_SYSTEM_VAR@("NumSequence",vl_F_seq[vl_rang,0])

		/*A si non existance d'une sequence pour cette selection */
		if vl_F_seq[vl_rang,2]<1 
		{
			/*A griser le bouton valider */
			DB_CTRL_GRAYED@(vl_fenetre_TEC,"BP_valider",True)
		}
		/*A sinon */
		else
		{
			/*A MAJ de vl_sequence */
			for i = 0 to 49
				vl_sequence[i] = vl_F_seq[vl_rang,i+2]
			next i

			/*A trace de la sequence selectionné */
			COM01_Trace(0,"Choix sequence : " ++ vm_seq_select ++ " ---> " 
									  ++ vl_F_seq[vl_rang,0])

			/*A dégriser le bouton valider */
			DB_CTRL_GRAYED@(vl_fenetre_TEC,"BP_valider",False)
		}		

	/*A sur reception de poke */
	CASE "poke_"
	
		/*A suivant le canal de reception de poke */
		CASE OF DB_GET_POKE@(vl_fenetre_TEC)

		/*A si poke de fin de canal : fermeture de fenetre */
		CASE COM_CANAL_FIN
			/*A la fenetre n'est plus active */
			vl_fenetre_active = FALSE

		ENDCASE

	ENDCASE

/*A fin tant que */
WEND


ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :	Choisir le picto suivant pour le panneau désiré
*
*  ----------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TEC_pix_suivant(va_num)

/*
* ARGUMENTS EN ENTREE : 
*	va_num	: le N° du bouton
*
* ARGUMENTS EN SORTIE : Aucun
*
* CODE RETOUR         : COM_OK
*
* CONDITION D'UTILISATION
*   Selectionner le bouton 'Appel sequence' dans la vue echangeur
*
* FONCTION
*    Choisir le picto suivant pour le panneau désiré
*
---------------------------------------------------------------------------- */

var		vl_titre
var		vl_objet
var 		i
var		vl_trouve

if NOT(COM04_Operateur_A_Le_Droit_De(XDC_FAM_EXPLOITATION)) and NOT vm_mode_formation
{ 
		RETURN(COM_OK)
}
/* DEM743 : secteur */
if vm_NomSite <> XDC_NOM_SITE_DN /*!!*/ and vm_NomSite <> XDC_NOM_SITE_VC /*!!*/ and NOT vm_mode_formation
{
		RETURN(COM_OK)
}
if (vm_echangeur_renove = TRUE)
{
	ITMA_TEC_pix_suivant_renov(va_num)
	RETURN
}

vl_objet = "BP_cmd" ++ va_num
vl_trouve = false

/*A dégriser le bouton 'BP_executer' si un evt est lié */
if vm_NumEvt>0 and vm_CleEvt>0
{ DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_executer",False) }

/*A MAJ du mode manuel sur le bouton 'BP_manuel' */
DB_CTRL_TITLE@(vm_fenetre_TEC,"BP_manuel","pix_manu")

/* Capture du picto en cours */
vl_titre = DB_CTRL_GET_TITLE@(vm_fenetre_TEC,vl_objet)

/*A boucle de picto : de 1 à 27 */
for i = 5 to 32
	if vl_titre = vm_F_panneau[vm_F_bouton[va_num,1],i] and vl_trouve = false
	{
		vl_titre =  vm_F_panneau[vm_F_bouton[va_num,1],i+1]
		vm_F_bouton[va_num,0] = i - 4
		vm_F_bouton[va_num,2] = vl_titre
		vl_trouve = true
	}
next i

/*a si arrivé en fin de liste : picto neutre */
if TRIM@(vl_titre) = ""
{
	vl_titre =  vm_F_panneau[vm_F_bouton[va_num,1],5]
	vm_F_bouton[va_num,0] = 0
	vm_F_bouton[va_num,2] = vl_titre
}

/*A MAJ du bouton */
DB_CTRL_TITLE@(vm_fenetre_TEC,vl_objet,vl_titre)

/*A MAJ du message status */
vm_text = "Status : Modification du panneau n° "++vm_F_bouton[va_num,1]
DB_CTRL_TITLE@(vm_fenetre_TEC,"LI_status",vm_text)

/*A retour OK */
RETURN(COM_OK)

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :	Choisir une sequence de commande de panneaux
*
*  ----------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TEC_pix_select(va_num,va_pos)

/*
* ARGUMENTS EN ENTREE : 
*	va_num	: le N° du bouton
*	va_pos	: le N° du picto désiré ( 0 :  neutre )
*
* ARGUMENTS EN SORTIE : Aucun
*
* CODE RETOUR         : COM_OK
*
* CONDITION D'UTILISATION
*   Selectionner le bouton 'Appel sequence' dans la vue echangeur
*
* FONCTION
*    Choisir une sequence de commande de panneaux
*
---------------------------------------------------------------------------- */

var		vl_titre
var		vl_objet
var 		i
var		vl_trouve

vl_objet = "BP_cmd" ++ va_num

/*A si appel depuis TMC : MAJ de la zone superieur */
if vm_appel="ITMA_TMC"
{ vl_objet = "BP_panneau" ++ va_num }

/*a si la position est entre 0 & 10 */
if va_pos >=0 and va_pos<=10
{
	vl_titre =  vm_F_panneau[vm_F_bouton[va_num,1],va_pos+5]
	vm_F_bouton[va_num,0] = va_pos
	vm_F_bouton[va_num,2] = vl_titre

	/*A MAJ du bouton */
	DB_CTRL_TITLE@(vm_fenetre_TEC,vl_objet,vl_titre)

	/*A retour OK */
	Return(COM_OK)
}
else
{
	Return(COM_NOK)
}

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :	MAJ du panneau dans la vue actuelle
* 
*  ----------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TEC_MAJ_ID(va_num,va_pos)

/*
* ARGUMENTS EN ENTREE : 
*	va_num	: le N° du bouton
*	va_pos	: position du bouton
*
* ARGUMENTS EN SORTIE : Aucun
*
* CODE RETOUR         : COM_OK
*
* CONDITION D'UTILISATION
*   Selectionner le bouton 'Appel sequence' dans la vue echangeur
*
* FONCTION
*    Choisir le picto suivant pour le panneau désiré
*
---------------------------------------------------------------------------- */

var		vl_titre
var		vl_objet
var 		i
var		vl_size
var		vl_taille

/*A construction du nom de l'objet vl_objet */
vl_objet = "BP_panneau" ++ va_num

/*A si le bouton existe */
if vm_F_bouton[va_num,1]<>""
{
	vl_size = ARRAY_FROM_STRING@(vm_F_bouton[va_num,2],"_")
	vl_taille = ARRAY_SIZE@(vl_size) - 1
	if vl_taille<2 
	{	vl_taille = 3
		vl_size[2] = "40"
		vl_size[3] = "40"
	}

	/*A lecture du picto disponible à cette position dans vl_titre */
	vl_titre =  vm_F_panneau[vm_F_bouton[va_num,1],va_pos+5]


	if va_pos=-1 { vl_titre = "pix_defaut_" ++ vl_size[vl_taille-1] ++ "_" ++vl_size[vl_taille]}

	/*A si le picto existe pour cette position : MAJ du bouton */
	if TRIM@(vl_titre) <> ""
	{ DB_CTRL_TITLE@(vm_fenetre_TEC,vl_objet,vl_titre) }

	/*A retour OK */
	Return(COM_OK)
}
/*A sinon */
else
{
	/*A retour NOK */
	Return(COM_NOK)
}

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :	Remet l'echangeur à l'etat normal
*
* ---------------------------------------------------------------------------*/

MACRO ITMA_TEC_Cmd_Fin_Ech(va_NumEqt,va_Manuelle,va_district)

/*------------------------------------------------------------------------------
* ARGUMENTS EN ENTREE : 
*		NumAction		:	le numero de l'action
*		va_Manuelle		:	Le flag manuel ou automatique
*
* ARGUMENTS EN SORTIE : aucun
*
* CODE RETOUR		: COM_OK en cas d'execution correcte, COM_NOK sinon.
*
* CONDITION D'UTILISATION
*   		ITMA_TEC_pilotage_echangeur
*
* FONCTION
*   		Remet l'echangeur à l'etat normal.
*
---------------------------------------------------------------------------- */

	VAR FORMAT SQL_Procedure_Params@ vl_parametres
	VAR FORMAT SQL_Procedure_Result@ vl_resultats

	var	vl_heure			' heure courante

	/*A test les droits d'acces à cette fonction */
	if NOT(COM04_Operateur_A_Le_Droit_De(XDC_FAM_EXPLOITATION_DISTRICT)) AND
		   NOT(COM04_Operateur_A_Le_Droit_De(XDC_FAM_EXPLOITATION_CI))
	{
		ITMA_TEC_Acces_interdit("ITMA_TEC_Cmd_Fin_Ech")
		RETURN(COM_NOK)
	}

	vl_Heure = COM09_Date_Courante()

	/*A trace de l'appel de la procedure */
	vm_text = COM09_Date_Courante()++" ---> Appel de la procedure 'XZAC64_Commande_Fin_Echnangeur' "
	COM01_Trace(0,vm_text)

	/*A parametrage de vl_parametres */
	vl_parametres[0].type = SYB#INT4_
	vl_parametres[0].data = va_NumEqt  
	vl_parametres[0].output = FALSE
	
	vl_parametres[1].type = SYB#INT4_
	vl_parametres[1].data = XDC_VC /*vm_District*/  /*!!va_district */
	vl_parametres[1].output = FALSE

	vl_parametres[2].type = SYB#CHAR_
	vl_parametres[2].data = vl_heure
	vl_parametres[2].output = FALSE

	vl_parametres[3].type = SYB#INT4_
	vl_parametres[3].data = va_Manuelle
	vl_parametres[3].output = FALSE

        vl_parametres[5].type = SYB#CHAR_
        vl_parametres[5].data = SYSTEM_VAR@(vg_nom_site)               ' Site local
        vl_parametres[5].output = FALSE

IF COM05_SQL_Procedure (XZAC64_Commande_Fin_Echangeur,vl_parametres,vl_resultats,C_MODULE) <> COM_OK
    RETURN (COM_NOK)


	/*A retour OK */
	RETURN (COM_OK)

ENDMACRO


/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :	Remet l'echangeur à l'etat normal
*
* ---------------------------------------------------------------------------*/

MACRO ITMA_TEC_Cmd_Fin_Ech_renov(va_NumEqt,va_Manuelle,va_district)

/*------------------------------------------------------------------------------
* ARGUMENTS EN ENTREE : 
*		NumAction		:	le numero de l'action
*		va_Manuelle		:	Le flag manuel ou automatique
*
* ARGUMENTS EN SORTIE : aucun
*
* CODE RETOUR		: COM_OK en cas d'execution correcte, COM_NOK sinon.
*
* CONDITION D'UTILISATION
*   		ITMA_TEC_pilotage_echangeur
*
* FONCTION
*   		Remet l'echangeur à l'etat normal.
*
---------------------------------------------------------------------------- */

	VAR FORMAT SQL_Procedure_Params@ vl_parametres
	VAR FORMAT SQL_Procedure_Result@ vl_resultats

	var	vl_heure			' heure courante

	/*A test les droits d'acces à cette fonction */
	if NOT(COM04_Operateur_A_Le_Droit_De(XDC_FAM_EXPLOITATION_DISTRICT)) AND
		   NOT(COM04_Operateur_A_Le_Droit_De(XDC_FAM_EXPLOITATION_CI))
	{
		ITMA_TEC_Acces_interdit("ITMA_TEC_Cmd_Fin_Ech_renov")
		RETURN(COM_NOK)
	}

	vl_Heure = COM09_Date_Courante()

	/*A trace de l'appel de la procedure */
	vm_text = COM09_Date_Courante()++" ---> Appel de la procedure 'XZAC631_Commande_Fin_Signalisation' "
	COM01_Trace(0,vm_text)

	/*A parametrage de vl_parametres */
	vl_parametres[0].type = SYB#INT1_
	vl_parametres[0].data = 11		/* type eqt : echangeur */
	vl_parametres[0].output = FALSE

	vl_parametres[1].type = SYB#INT4_
	vl_parametres[1].data = va_NumEqt
	vl_parametres[1].output = FALSE
	
	vl_parametres[2].type = SYB#INT4_
	vl_parametres[2].data = XDC_VC
	vl_parametres[2].output = FALSE

	vl_parametres[3].type = SYB#CHAR_
	vl_parametres[3].data = vl_heure
	vl_parametres[3].output = FALSE

	vl_parametres[4].type = SYB#INT4_
	vl_parametres[4].data = va_Manuelle
	vl_parametres[4].output = FALSE

        vl_parametres[5].type = SYB#CHAR_
        vl_parametres[5].data = SYSTEM_VAR@(vg_nom_site)               ' Site local
        vl_parametres[5].output = FALSE

	if ( COM05_SQL_Procedure (XZAC631_Commande_Fin_Signalisation,vl_parametres,vl_resultats,C_MODULE) <> COM_OK )
		RETURN (COM_NOK)

	RETURN (COM_OK)

ENDMACRO



/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :	Commander le sequence vers SYBASE
*
* ---------------------------------------------------------------------------*/

MACRO ITMA_TEC_Cmd_Seq_Ech(va_PosteOperateur,va_Manuelle,va_NumSequence)

/*------------------------------------------------------------------------------
* ARGUMENTS EN ENTREE : 
*		va_PosteOperateur		:	le nom du poste operateur
*		va_Manuelle			:	le type manuel ou auto
*		va_NumSequence		:	N° de la sequence
*
* ARGUMENTS EN SORTIE : aucun
*
* CODE RETOUR		: COM_OK en cas d'execution correcte, COM_NOK sinon.
*
* CONDITION D'UTILISATION
*   		ITMA_TEC_pilotage_echangeur
*
* FONCTION
*   		Commander le sequence vers SYBASE.
*
---------------------------------------------------------------------------- */

	VAR FORMAT SQL_Procedure_Params@ vl_parametres
	VAR FORMAT SQL_Procedure_Result@ vl_resultats

	var	vl_Heure			' heure courante
	var	vl_NumAction			' le N° d'action retournée par la base

	/*A test les droits d'acces à cette fonction */
	if NOT(COM04_Operateur_A_Le_Droit_De(XDC_FAM_EXPLOITATION_DISTRICT)) AND
		   NOT(COM04_Operateur_A_Le_Droit_De(XDC_FAM_EXPLOITATION_CI))
	{
		ITMA_TEC_Acces_interdit("ITMA_TEC_Cmd_Seq_Ech")
		RETURN(COM_NOK)
	}

	vl_Heure = COM09_Date_Courante()

	/*A trace de l'appel de la procedure */
	vm_text = COM09_Date_Courante()++" ---> Appel de la procedure 'XZAC08_Commande_Seq_Echangeur("++va_PosteOperateur++","++va_Manuelle++","++va_NumSequence++")'"
	COM01_Trace(0,vm_text)

	/*A parametrage de vl_parametres */
	vl_parametres[0].type = SYB#INT4_
	vl_parametres[0].data = vm_NumEvt			' NumEvt
	vl_parametres[0].output = FALSE
	
	vl_parametres[1].type = SYB#INT1_
	vl_parametres[1].data = vm_CleEvt			' CléEvt
	vl_parametres[1].output = FALSE
	
	vl_parametres[2].type = SYB#INT2_
	vl_parametres[2].data = va_PosteOperateur	' Poste Opérateur
	vl_parametres[2].output = FALSE

	vl_parametres[3].type = SYB#INT2_
	vl_parametres[3].data = vm_NumEch			' NumEqt
	vl_parametres[3].output = FALSE

	vl_parametres[4].type = SYB#DATETIME_
	vl_parametres[4].data = vl_heure		' Heure de lancement
	vl_parametres[4].output = FALSE

	vl_parametres[5].type = SYB#BIT_
	vl_parametres[5].data = va_Manuelle		' Manu ou Auto
	vl_parametres[5].output = FALSE
	
	vl_parametres[6].type = SYB#INT1_
	vl_parametres[6].data = vm_echangeur.Priorite	' Priorité
	vl_parametres[6].output = FALSE

	vl_parametres[7].type = SYB#INT4_
	vl_parametres[7].data = XDC_DISTANCE_INCONNUE	' DistanceEvt
	vl_parametres[7].data = vm_echangeur.DistanceEvt	' DistanceEvt
	vl_parametres[7].output = FALSE

	vl_parametres[8].type = SYB#INT1_
	vl_parametres[8].data = va_NumSequence	' N° de la sequence
	vl_parametres[8].output = FALSE

	vl_parametres[9].type = SYB#INT4_
	vl_parametres[9].data = NULL			' NumAction
	vl_parametres[9].output = True

        vl_parametres[10].type = SYB#CHAR_
        vl_parametres[10].data = SYSTEM_VAR@(vg_nom_site)               ' Site local
        vl_parametres[10].output = FALSE

IF COM05_SQL_Procedure (XZAC08_Commande_Seq_Echangeur,vl_parametres,vl_resultats,C_MODULE) <> COM_OK
    RETURN (COM_NOK)

	vl_NumAction = vl_resultats.return_parameters[0]

	/*A retour du N° d'action */
	RETURN (vl_NumAction)

ENDMACRO


/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :	Commander le sequence vers SYBASE GTC renoveee
*
* ---------------------------------------------------------------------------*/

MACRO ITMA_TEC_Cmd_Seq_Ech_renov(va_PosteOperateur, va_Manuelle,va_NumSequence, va_NumEch)

/*------------------------------------------------------------------------------
* ARGUMENTS EN ENTREE : 
*		va_NumTube			:	numéro du tube
*		va_Manuelle			:	le type manuel ou auto
*		va_NumSequence		:	N° de la sequence
*
* ARGUMENTS EN SORTIE : aucun
*
* CODE RETOUR		: COM_OK en cas d'execution correcte, COM_NOK sinon.
*
* CONDITION D'UTILISATION
*   		ITMA_TTU_pilotage_tunnel
*
* FONCTION
*   		Commander le sequence d'une voie vers SYBASE.
*
---------------------------------------------------------------------------- */


	VAR FORMAT SQL_Procedure_Params@ vl_parametres
	VAR FORMAT SQL_Procedure_Result@ vl_resultats

	var	vl_Heure			' heure courante
	var	vl_NumAction	' le N° d'action retournée par la base
	var vl_poste      ' Le nom de la machine
  
	vl_poste = SYSTEM_VAR@("vg_numero_operateur")

	/*A test les droits d'acces à cette fonction */
	if NOT(COM04_Operateur_A_Le_Droit_De(XDC_FAM_EXPLOITATION_DISTRICT)) AND
	   NOT(COM04_Operateur_A_Le_Droit_De(XDC_FAM_EXPLOITATION_CI))
	{
		ITMA_TEC_Acces_interdit("ITMA_TEC_Commande_Seq_Tunnel")
		RETURN(COM_NOK)
	}

	vl_Heure = COM09_Date_Courante(TRUE)

	/*A trace de l'appel de la procedure */
	vm_text = COM09_Date_Courante()++" ---> Appel de la procedure 'XZAC100_Commande_Seq_SIG("++vl_poste++","++va_Manuelle++","++va_NumSequence++")'"
	COM01_Trace(0,vm_text)

	/*A parametrage de vl_parametres */
	vl_parametres[0].type = SYB#INT4_
	vl_parametres[0].data = vm_NumEvt+0			' NumEvt
	vl_parametres[0].output = FALSE
	
	vl_parametres[1].type = SYB#INT1_
	vl_parametres[1].data = vm_CleEvt+0			' CléEvt
	vl_parametres[1].output = FALSE
	
	vl_parametres[2].type = SYB#INT2_
	vl_parametres[2].data = vl_poste+0		' Poste Opérateur
	vl_parametres[2].output = FALSE

	vl_parametres[3].type = SYB#INT1_
	vl_parametres[3].data = 11			' TypeEqt = echangeur
	vl_parametres[3].output = FALSE
        
	vl_parametres[4].type = SYB#INT2_
	vl_parametres[4].data = va_NumEch+0			' NumEqt
	vl_parametres[4].output = FALSE

	vl_parametres[5].type = SYB#DATETIME_
	vl_parametres[5].data = vl_heure				' Heure de lancement
	vl_parametres[5].output = FALSE

	vl_parametres[6].type = SYB#BIT_
	vl_parametres[6].data = va_Manuelle				' Manu ou Auto
	vl_parametres[6].output = FALSE
	
	vl_parametres[7].type = SYB#INT1_
	vl_parametres[7].data = 0 '--vm_tunnel.Priorite				' Priorité
	vl_parametres[7].output = FALSE

	vl_parametres[8].type = SYB#INT4_
	vl_parametres[8].data = XDC_DISTANCE_INCONNUE	' DistanceEvt
	'--vl_parametres[8].data = vm_tunnel.DistanceEvt	' DistanceEvt
	vl_parametres[8].output = FALSE

	vl_parametres[9].type = SYB#INT1_
	vl_parametres[9].data = va_NumSequence+0			' N° de la sequence
	vl_parametres[9].output = FALSE

	vl_parametres[10].type = SYB#INT4_
	vl_parametres[10].data = NULL					' NumAction
	vl_parametres[10].output = True

        vl_parametres[11].type = SYB#CHAR_
        vl_parametres[11].data = SYSTEM_VAR@(vg_nom_site)               ' Site local
        vl_parametres[11].output = FALSE

	IF COM05_SQL_Procedure(XZAC100_Commande_Seq_SIG, vl_parametres, vl_resultats, C_MODULE) <> COM_OK
            RETURN (COM_NOK)
	
    vl_NumAction = vl_resultats.return_parameters[0]
	RETURN (vl_NumAction)
ENDMACRO


/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :	Indique la fin de la commande individuelle par l'operateur
*
* ---------------------------------------------------------------------------*/

MACRO ITMA_TEC_Fin_Cmd_Manu_Ech(va_NumAction,va_Validation,va_NumSequence,va_NomSiteEchangeur)

/*------------------------------------------------------------------------------
* ARGUMENTS EN ENTREE : 
*		va_NumAction		:	le numero de l'action
*		va_Validation	:	Validation de l'operateur
*		va_NumSequence	:	N° de la sequence
*
* ARGUMENTS EN SORTIE : aucun
*
* CODE RETOUR		: COM_OK en cas d'execution correcte, COM_NOK sinon.
*
* CONDITION D'UTILISATION
*   		ITMA_TEC_pilotage_echangeur
*
* FONCTION
*   		Indique la fin de la commande individuelle par l'operateur.
*
---------------------------------------------------------------------------- */

	VAR FORMAT SQL_Procedure_Params@ vl_parametres
	VAR FORMAT SQL_Procedure_Result@ vl_resultats

	var	vl_Heure1			' heure courante
	var	vl_Heure2			' heure courante

	/*A test les droits d'acces à cette fonction */
	if NOT(COM04_Operateur_A_Le_Droit_De(XDC_FAM_EXPLOITATION_DISTRICT)) AND
		   NOT(COM04_Operateur_A_Le_Droit_De(XDC_FAM_EXPLOITATION_CI))
	{
		ITMA_TEC_Acces_interdit("ITMA_TEC_Fin_Cmd_Manu_Ech")
		RETURN(COM_NOK)
	}

	/*A si retour OK de l'operateur */
	if va_Validation  = XDC_VRAI
	{
		vl_heure1 = COM09_Date_Courante()
		vl_heure2 = NULL
	}
	/*A sinon */
	else
	{
		vl_heure1 = NULL
		vl_heure2 = COM09_Date_Courante()
	}

	/*A trace de l'appel de la procedure */
	vm_text = COM09_Date_Courante()++" ---> Appel de la procedure 'XZAC07_Fin_Cmd_Manuelle_Echangeur("++va_NumAction++","++vl_Heure1++","++vl_heure2++","++va_NumSequence++")' "
	COM01_Trace(0,vm_text)

	/*A parametrage de vl_parametres */
	vl_parametres[0].type = SYB#INT4_
	vl_parametres[0].data = va_NumAction
	vl_parametres[0].output = FALSE
	
	vl_parametres[1].type = SYB#DATETIME_
	vl_parametres[1].data = vl_Heure1
	vl_parametres[1].output = FALSE

	vl_parametres[2].type = SYB#DATETIME_
	vl_parametres[2].data = vl_heure2
	vl_parametres[2].output = FALSE

	vl_parametres[3].type = SYB#INT1_
	vl_parametres[3].data = va_NumSequence
	vl_parametres[3].output = FALSE

        vl_parametres[4].type = SYB#CHAR_
        vl_parametres[4].data = SYSTEM_VAR@(va_NomSiteEchangeur)               ' Site equipement
        vl_parametres[4].output = FALSE


	IF COM05_SQL_Procedure (XZAC07_Fin_Cmd_Manu_Echangeur,vl_parametres,vl_resultats,C_MODULE) <> COM_OK
    		RETURN (COM_NOK)
/*
    IF COM05_SQL_Procedure (XZAC110_Commande_Seq_SIG,vl_parametres,vl_resultats,C_MODULE) <> COM_OK
      RETURN (COM_NOK)
*/

	/*A retour OK */
	RETURN (COM_OK)

ENDMACRO


/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :	Indique la fin de la commande individuelle par l'operateur
*
* ---------------------------------------------------------------------------*/

MACRO ITMA_TEC_Fin_Cmd_Manu_Ech_renov(va_NumAction,va_Validation,va_NumSequence,va_NomSiteEchangeur)

/*------------------------------------------------------------------------------
* ARGUMENTS EN ENTREE : 
*		va_NumAction		:	le numero de l'action
*		va_Validation	:	Validation de l'operateur
*		va_NumSequence	:	N° de la sequence
*
* ARGUMENTS EN SORTIE : aucun
*
* CODE RETOUR		: COM_OK en cas d'execution correcte, COM_NOK sinon.
*
* CONDITION D'UTILISATION
*   		ITMA_TTU_pilotage_tunnel
*
* FONCTION
*   		Indique la fin de la commande individuelle par l'operateur.
*
---------------------------------------------------------------------------- */

	VAR FORMAT SQL_Procedure_Params@ vl_parametres
	VAR FORMAT SQL_Procedure_Result@ vl_resultats

	var	vl_Heure1			' heure courante
	var	vl_Heure2			' heure courante

	/*A test les droits d'acces à cette fonction */
	if NOT(COM04_Operateur_A_Le_Droit_De(XDC_FAM_EXPLOITATION_DISTRICT))
	{
		ITMA_TTU_Acces_interdit("ITMA_TEC_Fin_Cmd_Manu_Ech_renove")
		RETURN(COM_NOK)
	}


	/*A si retour OK de l'operateur */
	if va_Validation  = XDC_VRAI
	{
		vl_Heure1 = COM09_Date_Courante(TRUE)
		vl_heure2 = 0
	}
	else
	{
		vl_Heure1 = 0
		vl_Heure2 = COM09_Date_Courante(TRUE)
	}

	/*A trace de l'appel de la procedure */
	vm_text = COM09_Date_Courante()++" ---> Appel de la procedure 'XZAC110_Commande_Seq_SIG("++va_NumAction++","++vl_Heure1++","++vl_Heure2++","++va_NumSequence++")' "
	COM01_Trace(0,vm_text)
    
	/*A parametrage de vl_parametres */
	vl_parametres[0].type = SYB#INT4_
	vl_parametres[0].data = va_NumAction+0
	vl_parametres[0].output = FALSE
	
	vl_parametres[1].type = SYB#DATETIME_
	vl_parametres[1].data = vl_Heure1
	vl_parametres[1].output = FALSE

	vl_parametres[2].type = SYB#DATETIME_
	vl_parametres[2].data = vl_Heure2
	vl_parametres[2].output = FALSE

	vl_parametres[3].type = SYB#INT1_
	vl_parametres[3].data = va_NumSequence+0
	vl_parametres[3].output = FALSE

        vl_parametres[4].type = SYB#CHAR_
        vl_parametres[4].data = SYSTEM_VAR@(va_NomSiteEchangeur)               ' Site equipement
        vl_parametres[4].output = FALSE

    IF COM05_SQL_Procedure (XZAC110_Commande_Seq_SIG,vl_parametres,vl_resultats,C_MODULE) <> COM_OK
      RETURN (COM_NOK)

	/*A retour OK */
	RETURN (COM_OK)

ENDMACRO


/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :	Retourne l'utilisation réelle d'un echangeur à une horodate donnée.
*
* ---------------------------------------------------------------------------*/

MACRO ITMA_TEC_Utilisation_Echangeur(va_NumEqt)

/*------------------------------------------------------------------------------
* ARGUMENTS EN ENTREE : 
*		va_NumEqt		:	le numero d'équipement du echangeur
*
* ARGUMENTS EN SORTIE : aucun
*
* CODE RETOUR		: COM_OK en cas d'execution correcte, COM_NOK sinon.
*
* CONDITION D'UTILISATION
*
* FONCTION
*   		Retourne l'utilisation réelle du echangeur à une horodate donnée.
*
---------------------------------------------------------------------------- */

	VAR FORMAT SQL_Procedure_Params@ vl_parametres
	VAR FORMAT SQL_Procedure_Result@ vl_resultats

	var	vl_heure			' heure courante
	var	vl_donnee			' donnee retournée

	vl_Heure = COM09_Date_Courante()

	/*A trace de l'appel de la procedure */
	vm_text = COM09_Date_Courante()++" ---> Appel de la procedure 'XZAT08_Utilisation_Echangeur' "
	COM01_Trace(0,vm_text)

	/*A parametrage de vl_parametres */
	vl_parametres[0].type = SYB#CHAR_
	vl_parametres[0].data = vl_Heure
	vl_parametres[0].output = FALSE
	
	vl_parametres[1].type = SYB#INT4_
	vl_parametres[1].data = va_NumEqt
	vl_parametres[1].output = FALSE

	vl_parametres[2].type = SYB#INT4_
	vl_parametres[2].data = 0		' DispoTube
	vl_parametres[2].output = TRUE

	vl_parametres[3].type = SYB#CHAR_
	vl_parametres[3].data = 0		' Sequence
	vl_parametres[3].output = TRUE

	vl_parametres[4].type = SYB#INT4_
	vl_parametres[4].data = 0		' NumEvt
	vl_parametres[4].output = TRUE

	vl_parametres[5].type = SYB#INT4_
	vl_parametres[5].data = 0		' Priorité
	vl_parametres[5].output = TRUE

	vl_parametres[6].type = SYB#INT4_
	vl_parametres[6].data = 0		' DistanceEvt
	vl_parametres[6].output = TRUE

IF COM05_SQL_Procedure (XZAT08_Utilisation_Echangeur,vl_parametres,vl_resultats,C_MODULE) <> COM_OK
    RETURN (COM_NOK)

	vl_donnee[0] = vl_resultats.return_parameters[0]
	vl_donnee[1] = vl_resultats.return_parameters[1]
	vl_donnee[2] = vl_resultats.return_parameters[2]
	vl_donnee[3] = vl_resultats.return_parameters[3]
	vl_donnee[4] = vl_resultats.return_parameters[4]

	if vm_Simulation { vl_donnee[1]="Ouverture Echangeur" }

	/*A retour OK */
	RETURN (vl_donnee)

ENDMACRO



/*X*/
/* ------------------------------------------------------------------------------
* SERVICE RENDU :	Permet de commander un ou plusieurs  panneaux.
*
* -------------------------------------------------------------------------------*/

MACRO ITMA_TEC_Pilote_panneau(va_NumEch,va_NumEqt,va_Position,va_Sequence)

/*-------------------------------------------------------------------------------
* ARGUMENTS EN ENTREE : 
*		va_NumEch		:	Numero de l'echangeur
*		va_NumEqt		:	La chaine des panneaux à piloter
*		va_Position		:	La chaine des positions à commander
*		va_Sequence		:	La sequence associé
*
* ARGUMENTS EN SORTIE : aucun
*
* CODE RETOUR	: COM_OK en cas d'execution correcte, COM_NOK sinon.
*
* CONDITION D'UTILISATION :
*   ITMA_TCA_pilotage_camera
*
* FONCTION :
*	Permet de commander un ou plusieurs panneaux.
* ------------------------------------------------------------------------------- */

	VAR vl_cmd
	VAR vl_text


	/*A test les droits d'acces à cette fonction */
	if NOT(COM04_Operateur_A_Le_Droit_De(XDC_FAM_EXPLOITATION_DISTRICT)) AND
		   NOT(COM04_Operateur_A_Le_Droit_De(XDC_FAM_EXPLOITATION_CI))
	{
		ITMA_TEC_Acces_interdit("ITMA_TEC_Pilote_panneau")
		RETURN(COM_NOK)
	}

	/*A trace de l'appel de procedure */
	vm_text = COM09_Date_Courante()  
	vm_text =  vm_text ++ " --> XZET01_Pilote_panneau "
	COM01_Trace(0,vm_text)

	/*B preparation de la requete pour le coupleur */
	vl_cmd[0]=MTAR_MSG_EXEC

	/*B num de commande pour retour. Non utilise ici */
	vl_cmd[1]=1			

	/*B fonction a executer */
	/* correction JBL */
	vl_cmd[2]=MTAR_FCT_XZET02

	/*B arguments */
	vl_cmd[3]= va_NumEch ++ MTAR_CAR_SEPAR ++ va_NumEqt ++ MTAR_CAR_SEPAR ++ va_Position ++ MTAR_CAR_SEPAR ++ va_Sequence

	/*B envoi de la commande a la tache ITMA_TAR01 */
	DB_SEND_POKE@(COM_CANAL_TAR01,vl_cmd)
	
	/*B trace de l'émmission */
	vl_text = COM09_Date_Courante() ++ " - DB_SEND_POKE@(COM_CANAL_TAR01," ++ vl_cmd[3] ++ ")"
	COM01_Trace(0,vl_text)

	/*B code retour OK */
	RETURN(COM_OK)

ENDMACRO

/*X*/
/* ------------------------------------------------------------------------------
* SERVICE RENDU :	Permet de commander un ou plusieurs  panneaux.
*
* -------------------------------------------------------------------------------*/

MACRO ITMA_TEC_Pilote_panneau_renov(va_NumEch,va_TypesEq,va_NumEqt,va_Position, va_Sequence)

/*-------------------------------------------------------------------------------
* ARGUMENTS EN ENTREE : 
*		va_NumEch		:	Numero de l'echangeur
*		va_NumEqt		:	La chaine des panneaux à piloter
*		va_Position		:	La chaine des positions à commander
*		va_Sequence		:	La sequence associé
*
* ARGUMENTS EN SORTIE : aucun
*
* CODE RETOUR	: COM_OK en cas d'execution correcte, COM_NOK sinon.
*
* CONDITION D'UTILISATION :
*   ITMA_TCA_pilotage_camera
*
* FONCTION :
*	Permet de commander un ou plusieurs panneaux.
* ------------------------------------------------------------------------------- */

	VAR vl_cmd
	VAR vl_text

	/*A test les droits d'acces à cette fonction */
	if NOT(COM04_Operateur_A_Le_Droit_De(XDC_FAM_EXPLOITATION_DISTRICT)) AND
		   NOT(COM04_Operateur_A_Le_Droit_De(XDC_FAM_EXPLOITATION_CI))
	{
		ITMA_TEC_Acces_interdit("ITMA_TEC_Pilote_panneau")
		RETURN(COM_NOK)
	}

	/*A trace de l'appel de procedure */
	vm_text = COM09_Date_Courante()  
	vm_text =  vm_text ++ " --> XZET01_Pilote_panneau "
	COM01_Trace(0,vm_text)

	/*B preparation de la requete pour le coupleur */
	vl_cmd[0]=MTAR_MSG_EXEC

	/*B num de commande pour retour. utilise ici (domaine)*/
	vl_cmd[1]=11			

	/*B fonction a executer */
	/* correction JBL */
	vl_cmd[2]=MTAR_FCT_XZET02
	
	/*B arguments */
	vl_cmd[3]= va_NumEch ++ MTAR_CAR_SEPAR ++ va_TypesEq ++ MTAR_CAR_SEPAR ++ va_NumEqt ++ MTAR_CAR_SEPAR ++ va_Position ++ MTAR_CAR_SEPAR ++ va_Sequence

	/*B envoi de la commande a la tache ITMA_TAR01 */
	DB_SEND_POKE@(COM_CANAL_TAR01,vl_cmd)
	
	/*B trace de l'émmission */
	vl_text = COM09_Date_Courante() ++ " - DB_SEND_POKE@(COM_CANAL_TAR01," ++ vl_cmd[0]++ ","++vl_cmd[1]++","++vl_cmd[2]++","++vl_cmd[3] ++ ")"
	COM01_Trace(0,vl_text)

	/*B code retour OK */
	RETURN(COM_OK)

ENDMACRO




/*X*/
/* ------------------------------------------------------------------------------
* SERVICE RENDU :	Permet de s'abonner à l'état des panneaux.
*
* -------------------------------------------------------------------------------*/

MACRO ITMA_TEC_Abt_Etat_Panneaux(va_Abonnement,va_NomSite)

/*-------------------------------------------------------------------------------
* ARGUMENTS EN ENTREE : 
*		va_Abonnement	:	Type d'abonnement (debut ou fin)
*		va_NomSite		:	Nom du site
*
* ARGUMENTS EN SORTIE : aucun
*
* CODE RETOUR	: COM_OK en cas d'execution correcte, COM_NOK sinon.
*
* CONDITION D'UTILISATION :
*   
*
* FONCTION :
*	Permet de s'abonner à l'état des panneaux.
* ------------------------------------------------------------------------------- */

	VAR vl_cmd
	VAR vl_text
	VAR vl_TypeEqt
	VAR vl_NomSite

	vl_TypeEqt = XDC_EQT_ECH
	if va_NomSite = XDC_NOM_SITE_CI
	{
		vl_NomSite = XDC_NOM_SITE_DN /*!!*/
	}
	else
	{
		vl_NomSite = va_NomSite
	}

	/*A trace de l'appel de procedure */
	vm_text = COM09_Date_Courante()  
	vm_text =  vm_text ++ " --> XZEA18_Abt_Etat_Panneaux "
	COM01_Trace(0,vm_text)

	/*B preparation de la requete pour le coupleur */
	vl_cmd[0]=MTAR_MSG_EXEC

	/*B num de commande pour retour. Non utilise ici */
	vl_cmd[1]=1			

	/*B fonction a executer */
	vl_cmd[2]=MTAR_FCT_XZEA18  

	/*B arguments */
	vl_cmd[3]= va_Abonnement ++ MTAR_CAR_SEPAR ++  vl_NomSite  ++ MTAR_CAR_SEPAR ++ vl_TypeEqt ++ MTAR_CAR_SEPAR ++ (vm_NumEch+0) 

	/*B envoi de la commande a la tache ITMA_TAR01 */
	DB_SEND_POKE@(COM_CANAL_TAR01,vl_cmd)
	
	/*B trace de l'émission */
	vl_text = COM09_Date_Courante() ++ " - DB_SEND_POKE@(COM_CANAL_TAR01," ++ vl_cmd[3] ++ ")"
	COM01_Trace(0,vl_text)
	
	/*B code retour OK */
	RETURN(COM_OK)

ENDMACRO


/*X*/
/* ------------------------------------------------------------------------------
* SERVICE RENDU :	Permet de s'abonner à l'état des panneaux GTC renovee.
*
* -------------------------------------------------------------------------------*/

MACRO ITMA_TEC_Abt_Etat_Panneaux_renov(va_Abonnement,va_NomSite)

/*-------------------------------------------------------------------------------
* ARGUMENTS EN ENTREE : 
*		va_Abonnement	:	Type d'abonnement (debut ou fin)
*		va_NomSite		:	Nom du site
*
* ARGUMENTS EN SORTIE : aucun
*
* CODE RETOUR	: COM_OK en cas d'execution correcte, COM_NOK sinon.
*
* CONDITION D'UTILISATION :
*   
*
* FONCTION :
*	Permet de s'abonner à l'état des panneaux.
* ------------------------------------------------------------------------------- */

	VAR vl_cmd
	VAR vl_text
	VAR vl_TypeEqt
	VAR vl_NomSite

	vl_TypeEqt = XDC_EQT_ECH
	if va_NomSite = XDC_NOM_SITE_CI
	{
		vl_NomSite = XDC_NOM_SITE_DN /*!!*/
	}
	else
	{
		vl_NomSite = va_NomSite
	}
	COM01_Trace(0, "Appel de ITMA_TEC_Abt_Etat_Panneaux_renov")

	/*A trace de l'appel de procedure */
	vm_text = COM09_Date_Courante()  
	vm_text =  vm_text ++ " --> XZEA18_Abt_Etat_Panneaux "
	COM01_Trace(0,vm_text)

	/*B preparation de la requete pour le coupleur */
	vl_cmd[0]=MTAR_MSG_EXEC

	/*B num de commande pour retour. Non utilise ici */
	vl_cmd[1]=11			

	/*B fonction a executer */
	vl_cmd[2]=MTAR_FCT_XZEA18  

	/*B arguments */
	vl_cmd[3]= va_Abonnement ++ MTAR_CAR_SEPAR ++  vl_NomSite  ++ MTAR_CAR_SEPAR ++ vl_TypeEqt ++ MTAR_CAR_SEPAR ++ (vm_NumEch+0) 

	/*B envoi de la commande a la tache ITMA_TAR01 */
	DB_SEND_POKE@(COM_CANAL_TAR01,vl_cmd)
	
	/*B trace de l'émmission */
	vl_text = COM09_Date_Courante() ++ " - DB_SEND_POKE@(COM_CANAL_TAR01," ++ vl_cmd[3] ++ ")"
	COM01_Trace(0,vl_text)
	
	/*B code retour OK */
	RETURN(COM_OK)

ENDMACRO



/*X*/
/* ------------------------------------------------------------------------------
* SERVICE RENDU :	Permet de s'abonner à l'état des alarmes.
*
* -------------------------------------------------------------------------------*/

MACRO ITMA_TEC_Abt_Telealarmes(va_Abonnement,va_NomSite)

/*-------------------------------------------------------------------------------
* ARGUMENTS EN ENTREE : 
*		va_Abonnement	:	Type d'abonnement (debut ou fin)
*		va_NomSite		:	Nom du site
*
* ARGUMENTS EN SORTIE : aucun
*
* CODE RETOUR	: COM_OK en cas d'execution correcte, COM_NOK sinon.
*
* CONDITION D'UTILISATION :
*   ITMA_TCA_pilotage_camera
*
* FONCTION :
*	Permet de s'abonner à l'état des alarmes.
* ------------------------------------------------------------------------------- */

	VAR vl_cmd
	VAR vl_text
	VAR vl_TypeEqt
	VAR vl_NomSite

	vl_TypeEqt = XDC_EQT_ECH
	if va_NomSite = XDC_NOM_SITE_CI
	{
		vl_NomSite = XDC_NOM_SITE_DN /*!!*/
	}
	else
	{
		vl_NomSite = va_NomSite
	}

	/*A trace de l'appel de procedure */
	vm_text = COM09_Date_Courante()  
	vm_text =  vm_text ++ " --> XZEA22_Abt_Telealarmes "
	COM01_Trace(0,vm_text)

	/*B preparation de la requete pour le coupleur */
	vl_cmd[0]=MTAR_MSG_EXEC

	/*B num de commande pour retour. Non utilise ici */
	vl_cmd[1]=1			

	/*B fonction a executer */
	vl_cmd[2]=MTAR_FCT_XZEA22  

	/*B arguments */
	vl_cmd[3]= va_Abonnement ++ MTAR_CAR_SEPAR ++ vl_NomSite  ++ MTAR_CAR_SEPAR ++ vl_TypeEqt ++ MTAR_CAR_SEPAR ++ (vm_NumEch+0) 


	/*B envoi de la commande a la tache ITMA_TAR01 */
	DB_SEND_POKE@(COM_CANAL_TAR01,vl_cmd)
	
	/*B trace de l'émmission */
	vl_text = COM09_Date_Courante() ++ " - DB_SEND_POKE@(COM_CANAL_TAR01," ++ vl_cmd[3] ++ ")"
	COM01_Trace(0,vl_text)

	/*B code retour OK */
	RETURN(COM_OK)

ENDMACRO




/*X*/
/* ------------------------------------------------------------------------------
* SERVICE RENDU :	Permet de s'abonner à l'état des sequences.
*
* -------------------------------------------------------------------------------*/

MACRO ITMA_TEC_Abt_Etat_Seq_Ech(va_Abonnement,va_NomSite)

/*-------------------------------------------------------------------------------
* ARGUMENTS EN ENTREE : 
*		va_Abonnement	:	Type d'abonnement (debut ou fin)
*		va_NomSite		:	Nom du site
*
* ARGUMENTS EN SORTIE : aucun
*
* CODE RETOUR	: COM_OK en cas d'execution correcte, COM_NOK sinon.
*
* CONDITION D'UTILISATION :
*   ITMA_TCA_pilotage_camera
*
* FONCTION :
*	Permet de s'abonner à l'état des sequences.
* ------------------------------------------------------------------------------- */

	VAR vl_cmd
	VAR vl_text
	VAR vl_NomSite

	if va_NomSite = XDC_NOM_SITE_CI
	{
		vl_NomSite = XDC_NOM_SITE_DN /*!!*/
	}
	else
	{
		vl_NomSite = va_NomSite
	}

	/*A trace de l'appel de procedure */
	vm_text = COM09_Date_Courante()  
	vm_text =  vm_text ++ " --> XZEA23_Abt_Etat_Seq_Ech "
	COM01_Trace(0,vm_text)

	/*B preparation de la requete pour le coupleur */
	vl_cmd[0]=MTAR_MSG_EXEC

	/*B num de commande pour retour. Non utilise ici */
	vl_cmd[1]=1			

	/*B fonction a executer */
	vl_cmd[2]=MTAR_FCT_XZEA24

	/*B arguments */
	vl_cmd[3]= va_Abonnement ++ MTAR_CAR_SEPAR ++ vl_NomSite ++ MTAR_CAR_SEPAR ++ (vm_NumEch+0) 


	/*B envoi de la commande a la tache ITMA_TAR01 */
	DB_SEND_POKE@(COM_CANAL_TAR01,vl_cmd)
	
	/*B trace de l'émmission */
	vl_text = COM09_Date_Courante() ++ " - DB_SEND_POKE@(COM_CANAL_TAR01," ++ vl_cmd[3] ++ ")"
	COM01_Trace(0,vl_text)

	/*B code retour OK */
	RETURN(COM_OK)

ENDMACRO


/*X*/
/* ------------------------------------------------------------------------------
* SERVICE RENDU :	Permet de s'abonner à l'état des sequences GTC renovee.
*
* -------------------------------------------------------------------------------*/

MACRO ITMA_TEC_Abt_Etat_Seq_Ech_renov(va_Abonnement,va_NomSite)

/*-------------------------------------------------------------------------------
* ARGUMENTS EN ENTREE : 
*		va_Abonnement	:	Type d'abonnement (debut ou fin)
*		va_NomSite		:	Nom du site
*
* ARGUMENTS EN SORTIE : aucun
*
* CODE RETOUR	: COM_OK en cas d'execution correcte, COM_NOK sinon.
*
* CONDITION D'UTILISATION :
*   ITMA_TCA_pilotage_camera
*
* FONCTION :
*	Permet de s'abonner à l'état des sequences.
* ------------------------------------------------------------------------------- */

	VAR vl_cmd
	VAR vl_text
	VAR vl_NomSite

	if va_NomSite = XDC_NOM_SITE_CI
	{
		vl_NomSite = XDC_NOM_SITE_DN /*!!*/
	}
	else
	{
		vl_NomSite = va_NomSite
	}
	COM01_Trace(0, "ITMA_TEC_Abt_Etat_Seq_Ech_renov")
	/*A trace de l'appel de procedure */
	vm_text = COM09_Date_Courante()  
	vm_text =  vm_text ++ " --> XZEA23_Abt_Etat_Seq_Ech "
	COM01_Trace(0,vm_text)

	/*B preparation de la requete pour le coupleur */
	vl_cmd[0]=MTAR_MSG_EXEC

	/*B num de commande pour retour. Non utilise ici */
	vl_cmd[1]=11		

	/*B fonction a executer */
	vl_cmd[2]=MTAR_FCT_XZEA24

	/*B arguments */
	vl_cmd[3]= va_Abonnement ++ MTAR_CAR_SEPAR ++ vl_NomSite ++ MTAR_CAR_SEPAR ++ (vm_NumEch+0) 


	/*B envoi de la commande a la tache ITMA_TAR01 */
	DB_SEND_POKE@(COM_CANAL_TAR01,vl_cmd)
	
	/*B trace de l'émmission */
	vl_text = COM09_Date_Courante() ++ " - DB_SEND_POKE@(COM_CANAL_TAR01," ++ vl_cmd[3] ++ ")"
	COM01_Trace(0,vl_text)

	/*B code retour OK */
	RETURN(COM_OK)

ENDMACRO



/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :	Lecture d'une action NAV à partir du n° de PA
*
*  ----------------------------------------------------------------------------
*/

MACRO ITMA_TEC_Lecture_PA_echangeur(va_NumPA,va_site)

/*
* ARGUMENTS EN ENTREE 	:
*   va_NumPA       	: N° du Plan d'action 
*   va_site    	: le numero du site 
*
*
* ARGUMENTS EN SORTIE	: 
*
*
* CODE RETOUR		: COM_OK en cas d'execution correcte, COM_NOK sinon.
*
*
* CONDITION D'UTILISATION
*   ITMA_TEC
*
*
---------------------------------------------------------------------------- */


	VAR	vl_lib_fmc		' libellé fmc
	VAR 	i,j				' index de boucle
	VAR	vl_retour

	VAR FORMAT SQL_Procedure_Params@ vl_parametres
	VAR FORMAT SQL_Procedure_Result@ vl_resultats
	

	/*A trace de l'appel de procedure */
	vm_text = COM09_Date_Courante()  
	vm_text =  vm_text ++ "--> XZAC43_Lire_Commande_Echangeur"
	COM01_Trace(0,vm_text)


	/*A Définition de vl_parametres */
	vl_parametres[0].type	= SYB#INT4_
	vl_parametres[0].data	= va_NumPA
	vl_parametres[0].output	= FALSE

	vl_parametres[1].type	= SYB#INT2_
	vl_parametres[1].data	= va_site
	vl_parametres[1].output	= FALSE

	vl_parametres[2].type	= SYB#INT4_
	vl_parametres[2].data	= 0			' NumEqt
	vl_parametres[2].output	= TRUE

	vl_parametres[3].type	= SYB#DATETIME_
	vl_parametres[3].data	= 0			' heure lancement
	vl_parametres[3].output	= TRUE

	vl_parametres[4].type	= SYB#DATETIME_
	vl_parametres[4].data	= 0			' heure fin lancement
	vl_parametres[4].output	= TRUE

	vl_parametres[5].type	= SYB#DATETIME_
	vl_parametres[5].data	= 0			' heure succes
	vl_parametres[5].output	= TRUE

	vl_parametres[6].type	= SYB#DATETIME_
	vl_parametres[6].data	= 0			' heure echec
	vl_parametres[6].output	= TRUE

	vl_parametres[7].type	= SYB#DATETIME_
	vl_parametres[7].data	= 0			' heure fin
	vl_parametres[7].output	= TRUE

	vl_parametres[8].type	= SYB#BIT_
	vl_parametres[8].data	= 0			' flag manuel
	vl_parametres[8].output	= TRUE

	vl_parametres[9].type	= SYB#INT1_
	vl_parametres[9].data	= 0			' scequence
	vl_parametres[9].output	= TRUE

	vl_retour[0] = COM_NOK
	
	/*A Exécution de la procedure XZAC43_Lire_Commande_Echangeur */
	IF COM05_SQL_Procedure (XZAC43_Lire_Commande_Echangeur,
							vl_parametres,vl_resultats,C_MODULE) <> COM_OK
	RETURN (vl_retour)


	/*A MAJ des retours de parametres */
	vl_retour[0]	=	vl_resultats.return_parameters[0]	' n° eqt
	vl_retour[1]	=	vl_resultats.return_parameters[6]	' manuel
	vl_retour[2]	=	vl_resultats.return_parameters[7]	' scequence

	if LEN@(vl_resultats.return_parameters[4])<= LEN@(vl_resultats.return_parameters[5])
	{	vl_retour[3] = "Horodate Echec : " ++ COM18_Date_SGBD_Formatee(vl_resultats.return_parameters[5]) }

	if LEN@(vl_resultats.return_parameters[5])<= LEN@(vl_resultats.return_parameters[4])
	{	vl_retour[3] = "Horodate Succes : " ++ COM18_Date_SGBD_Formatee(vl_resultats.return_parameters[4]) }
	
	if LEN@(TRIM@(vl_retour[3]))<20 {vl_retour[3] = " "}

	RETURN (vl_retour)

ENDMACRO

/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :	Lecture d'une action NAV à partir du n° de PA
*
*  ----------------------------------------------------------------------------
*/

MACRO ITMA_TEC_Lecture_PA_echangeur_renov(va_NumPA,va_site)

/*
* ARGUMENTS EN ENTREE 	:
*   va_NumPA       	: N° du Plan d'action 
*   va_site    	: le numero du site 
*
*
* ARGUMENTS EN SORTIE	: 
*
*
* CODE RETOUR		: COM_OK en cas d'execution correcte, COM_NOK sinon.
*
*
* CONDITION D'UTILISATION
*   ITMA_TEC
*
*
---------------------------------------------------------------------------- */


	VAR	vl_lib_fmc		' libellé fmc
	VAR 	i,j				' index de boucle
	VAR	vl_retour

	VAR FORMAT SQL_Procedure_Params@ vl_parametres
	VAR FORMAT SQL_Procedure_Result@ vl_resultats
	

	/*A trace de l'appel de procedure */
	vm_text = COM09_Date_Courante()  
	vm_text =  vm_text ++ "--> XZAC120_Lire_Commande_Signalisation"
	COM01_Trace(0,vm_text)


	/*A Définition de vl_parametres */
	vl_parametres[0].type	= SYB#INT4_
	vl_parametres[0].data	= va_NumPA
	vl_parametres[0].output	= FALSE

	vl_parametres[1].type	= SYB#INT2_
	vl_parametres[1].data	= va_site
	vl_parametres[1].output	= FALSE

	vl_parametres[2].type	= SYB#INT4_
	vl_parametres[2].data	= 0			' NumEqt
	vl_parametres[2].output	= TRUE

	vl_parametres[3].type	= SYB#DATETIME_
	vl_parametres[3].data	= 0			' heure lancement
	vl_parametres[3].output	= TRUE

	vl_parametres[4].type	= SYB#DATETIME_
	vl_parametres[4].data	= 0			' heure fin lancement
	vl_parametres[4].output	= TRUE

	vl_parametres[5].type	= SYB#DATETIME_
	vl_parametres[5].data	= 0			' heure succes
	vl_parametres[5].output	= TRUE

	vl_parametres[6].type	= SYB#DATETIME_
	vl_parametres[6].data	= 0			' heure echec
	vl_parametres[6].output	= TRUE

	vl_parametres[7].type	= SYB#DATETIME_
	vl_parametres[7].data	= 0			' heure fin
	vl_parametres[7].output	= TRUE

	vl_parametres[8].type	= SYB#BIT_
	vl_parametres[8].data	= 0			' flag manuel
	vl_parametres[8].output	= TRUE

	vl_parametres[9].type	= SYB#INT1_
	vl_parametres[9].data	= 0			' scequence
	vl_parametres[9].output	= TRUE

	vl_retour[0] = COM_NOK
	
	/*A Exécution de la procedure XZAC120_Lire_Commande_Signalisation */
	IF COM05_SQL_Procedure (XZAC120_Lire_Commande_Signalisation,
							vl_parametres,vl_resultats,C_MODULE) <> COM_OK
	RETURN (vl_retour)


	/*A MAJ des retours de parametres */
	vl_retour[0]	=	vl_resultats.return_parameters[0]	' n° eqt
	vl_retour[1]	=	vl_resultats.return_parameters[6]	' manuel
	vl_retour[2]	=	vl_resultats.return_parameters[7]	' scequence

	COM01_Trace(0, "Resultat de XZAC120_Lire_Commande_Signalisation :")
	COM01_Trace(0, "sequence = " ++ vl_retour[2])
	COM01_Trace(0, "manuel = " ++ vl_retour[1])
	COM01_Trace(0, "eqt = " ++ vl_retour[0])
	COM01_Trace(0, "Heure Echec = " ++ vl_resultats.return_parameters[4])
	COM01_Trace(0, "Heure Fin = " ++ vl_resultats.return_parameters[5])
	
/* modification ABE du 01-10-2008 
	pour correction FT 1924: anomalie pilotage échangeur: 
	reprise du code contenu dans
	ITMA_TTU_Lecture_PA_tunnel de ITMA_TTU_pilotage_tunnel.am
	pour remplacer le code utilisé ci-dessous 

	if LEN@(vl_resultats.return_parameters[4])<= LEN@(vl_resultats.return_parameters[5])
	{	vl_retour[3] = "Horodate Echec : " ++ COM18_Date_SGBD_Formatee(vl_resultats.return_parameters[5]) }

	if LEN@(vl_resultats.return_parameters[5])<= LEN@(vl_resultats.return_parameters[4])
	{	vl_retour[3] = "Horodate Succes : " ++ COM18_Date_SGBD_Formatee(vl_resultats.return_parameters[4]) }
	
	if LEN@(TRIM@(vl_retour[3]))<20 {vl_retour[3] = " "}
*/

	vl_retour[3] = " "

	if LEN@(TRIM@(vl_resultats.return_parameters[3]))<20 and LEN@(TRIM@(vl_resultats.return_parameters[4])) > 0
	{
		/* echec */
		vl_retour[3] = "Horodate Echec : " ++ COM18_Date_SGBD_Formatee(vl_resultats.return_parameters[4])
	}
	if LEN@(TRIM@(vl_resultats.return_parameters[3]))>=20 and LEN@(TRIM@(vl_resultats.return_parameters[4]))<20 
	{
		/* succes */
		vl_retour[3] = "Horodate Succes : " ++ COM18_Date_SGBD_Formatee(vl_resultats.return_parameters[3])
	}
	
	if LEN@(vl_resultats.return_parameters[5])>= 20
	{
		vl_retour[3] = "Horodate fin : " ++ COM18_Date_SGBD_Formatee(vl_resultats.return_parameters[5])
	}

	RETURN (vl_retour)

ENDMACRO


/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :	Lecture d'une action NAV à partir du n° de PA
*
*  ----------------------------------------------------------------------------
*/

MACRO ITMA_TEC_Lecture_Prop_PA_Ech(va_NumPA,va_ordre)

/*
* ARGUMENTS EN ENTREE 	:
*   va_NumPA       	: N° du Plan d'action 
*   va_ordre    	: le numero d'ordre 
*
*
* ARGUMENTS EN SORTIE	: 
*
*
* CODE RETOUR		: COM_OK en cas d'execution correcte, COM_NOK sinon.
*
*
* CONDITION D'UTILISATION
*   ITMA_TEC
*
*
---------------------------------------------------------------------------- */


	var vl_retour

	VAR FORMAT SQL_Procedure_Params@ vl_parametres
	VAR FORMAT SQL_Procedure_Result@ vl_resultats
	

	/*A trace de l'appel de procedure */
	vm_text = COM09_Date_Courante()  
	vm_text =  vm_text ++ "--> XZAP15_Lire_Prop_Echangeur"
	COM01_Trace(0,vm_text)

	/*B Numero du plan */
  	vl_parametres[0].type   = SYB#INT4_
	vl_parametres[0].data   = va_numPA
	vl_parametres[0].output = FALSE

	/*B rang de l'action dans la liste */
	vl_parametres[1].type   = SYB#INT2_
	vl_parametres[1].data   = va_ordre
 	vl_parametres[1].output = FALSE

	/*B appeler XZAP14_Lire_Prop_Echangeur */
	IF COM05_SQL_Procedure (XZAP15_Lire_Prop_Echangeur,
		vl_parametres,vl_resultats,C_MODULE) <> COM_OK
	RETURN (COM_NOK)

	vl_retour[0] = vl_resultats.select_results[0][0][1]	' NumEqt
	vl_retour[1] = vl_resultats.select_results[0][0][3]	' Num Sequence
	vl_retour[2] = vl_resultats.select_results[0][0][2]	' Explication
	vl_retour[3] = vl_resultats.select_results[0][0][0]	' Remarque
	vl_retour[4] = vl_resultats.select_results[0][0][4]	' Priorite
	vl_retour[5] = vl_resultats.select_results[0][0][5]	' DistanceEvt


	RETURN(vl_retour)

ENDMACRO





/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :	Lecture de l'etat d'un echangeur à une horodate donnée
*
*  ----------------------------------------------------------------------------
*/

MACRO ITMA_TEC_Lecture_Ech(va_NumEch)

/*
* ARGUMENTS EN ENTREE 	:
*   va_NumEch        	: N° d'eqt de l'Echangeur ;
*
*
* ARGUMENTS EN SORTIE	: 
*	va_etat	: 		etat de l'echangeur
*
*
* CODE RETOUR		: COM_OK en cas d'execution correcte, COM_NOK sinon.
*
*
* CONDITION D'UTILISATION
*   ITMA_TEC
*
*
* FONCTION
*   etat d'un echangeur à une horodate donnée.
*
---------------------------------------------------------------------------- */


	VAR	vl_lib_fmc		' libellé fmc
	VAR	vl_etat_null		' flag d'etat_PMV NULL
	VAR	vl_etat_num		' n° de l'etat_PMV correspondant
	VAR	i,j				' index de boucle
	var	vl_tptext			' zone de text tampon

	VAR FORMAT SQL_Procedure_Params@ vl_parametres
	VAR FORMAT SQL_Procedure_Result@ vl_resultats
	
	/*A trace de l'appel de procedure */
	vl_tptext = COM09_Date_Courante()  
	vl_tptext =  vl_tptext ++ "--> XZAT08_Utilisation_Echangeur"
	COM01_Trace(0,vl_tptext)


	/*A si n° Eqt du PMV nul : sortir */
	if va_NumEch=NULL or va_NumEch=0
	{
		vl_tptext = "ITMA_TPM_Lecture_Echangeur("++va_NumEch++") refusee"
		COM01_Trace(0,vl_tptext)
		RETURN(COM_NOK)
	}

	vm_Echangeur.NumEqt = va_NumEch+0

	/*A Définition de vl_parametres */
	vl_parametres[0].type	= SYB#DATETIME_
	vl_parametres[0].data	= XDC_DATE_NULLE
	vl_parametres[0].output	= FALSE

	vl_parametres[1].type	= SYB#INT1_
	vl_parametres[1].data	= vm_Echangeur.NumEqt+0
	vl_parametres[1].output	= FALSE

	vl_parametres[2].type	= SYB#INT2_
	vl_parametres[2].data	= 0			' Dispo Ech
	vl_parametres[2].output	= TRUE

	vl_parametres[3].type	= SYB#INT1_
	vl_parametres[3].data	= 0			' sequence
	vl_parametres[3].output	= TRUE

	vl_parametres[4].type	= SYB#INT4_
	vl_parametres[4].data	= 0			' N° Evt
	vl_parametres[4].output	= TRUE

	vl_parametres[5].type	= SYB#INT2_
	vl_parametres[5].data	= 0			' Clé Evt
	vl_parametres[5].output	= TRUE

	vl_parametres[6].type	= SYB#INT2_
	vl_parametres[6].data	= 0			' Priorité
	vl_parametres[6].output	= TRUE

	vl_parametres[7].type	= SYB#INT4_
	vl_parametres[7].data	= 0			' Distance Evt
	vl_parametres[7].output	= TRUE

	vl_parametres[8].type	= SYB#INT4_
	vl_parametres[8].data	= 0			' N° Action
	vl_parametres[8].output	= TRUE

	vl_parametres[9].type	= SYB#INT1_
	vl_parametres[9].data	= 0			' N° Site Action
	vl_parametres[9].output	= TRUE

	
	/*A Exécution de la procedure XZAT08_Utilisation_Echangeur */
	IF COM05_SQL_Procedure 
			(XZAT08_Utilisation_Echangeur,vl_parametres,vl_resultats,C_MODULE)
			 <> COM_OK
    			RETURN (COM_NOK)

	/*A MAJ de la table Echangeur avec les arguments de sorties */
	vm_Echangeur.Dispo	 		=	vl_resultats.return_parameters[0]
	vm_Echangeur.Sequence		=	vl_resultats.return_parameters[1]
	vm_Echangeur.NumEvt			=	vl_resultats.return_parameters[2]+0
	vm_Echangeur.CleEvt			=	vl_resultats.return_parameters[3]+0
	vm_Echangeur.Priorite		=	vl_resultats.return_parameters[4]
	vm_Echangeur.DistanceEvt		=	vl_resultats.return_parameters[5]
	vm_Echangeur.NumeroAction	=	vl_resultats.return_parameters[6]
	vm_Echangeur.NomSite		=	vl_resultats.return_parameters[7]+0

	vm_NumAction = vm_Echangeur.NumeroAction

	if vm_Echangeur.NumEvt<>0 and  vm_Echangeur.CleEvt<>0
	{
		/*A MAJ du libellé fmc */
		ITMA_COM_Lire_Evenement ( 
					vm_Echangeur.NumEvt,
					vm_Echangeur.CleEvt, 
					vl_lib_fmc, 
					C_MODULE)
		vm_Echangeur.fmc_liee = COM11_Libelle_FMC(vl_lib_fmc)
		if ( vm_appel <> "ITMA_TPA" )
		{
			vm_Echangeur.NumEvt = 0
			vm_Echangeur.CleEvt = 0 
		}
	}
	else	vm_Echangeur.fmc_liee = "Pas de libellé F.M.C. pour ce cas"

	
RETURN (COM_OK)

ENDMACRO


 
/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :	Lecture des équipements disponibles
*
*  ----------------------------------------------------------------------------
*/

MACRO ITMA_TEC_Liste_Eqt_Dispo(va_type,va_District,va_dispo)

/*
* ARGUMENTS EN ENTREE : 
*		va_type		:	le type d'équipement
*		va_District	:	le numero du district
*		va_dispo		:	le type de disponibilité
*
*
* ARGUMENTS EN SORTIE : 
*		ListeEqts		: la liste des équipements correspondants
*
*
* CODE RETOUR		: COM_OK en cas d'execution correcte, COM_NOK sinon.
*
*
* CONDITION D'UTILISATION
*   ITMA_TEC
*
*
* FONCTION
*   	Lecture des équipements en disponibilités.
*
---------------------------------------------------------------------------- */

	VAR FORMAT SQL_Procedure_Params@ vl_parametres
	VAR FORMAT SQL_Procedure_Result@ vl_resultats
	VAR FORMAT COM_Localisation vl_localisation

	var	vl_TypeEqt		' type d'équipement
	var	vl_Liste_select	' liste resultat du select SQL
	var	vl_Liste			' liste formattée
	var	i,j,k				' index de loop
	var	vl_taille			' taille de la table de resultat
	var vl_autoroutes		' listes des autoroutes
	var	vl_taille2		' taille d'une table
	var	vl_index			' index d'echangeur 


	vl_autoroutes = SYSTEM_VAR@(vg_les_autoroutes)

	vl_parametres[0].type	= SYB#INT1_
	vl_parametres[0].data	= va_type
	vl_parametres[0].output	= FALSE
	
	vl_parametres[1].type	= SYB#INT1_
if va_district = XDC_CI
	vl_parametres[1].data	= null
else

	vl_parametres[1].data	= va_District
	vl_parametres[1].output	= FALSE

	vl_parametres[2].type	= SYB#INT4_			' Conditions
	vl_parametres[2].data	= XDC_EQT_MINEUR+ XDC_EQT_MAJEUR + XDC_EQT_CRITIQUE
	vl_parametres[2].output	= FALSE

	vl_parametres[3].type	= SYB#INT4_			' Conditions niees
	vl_parametres[3].data	= XDC_EQT_MINEUR+ XDC_EQT_MAJEUR + XDC_EQT_CRITIQUE
	vl_parametres[3].output	= FALSE

	vl_parametres[4].type	= SYB#INT4_			' Exclusions
	vl_parametres[4].data	= XDC_EQT_HS + XDC_EQT_DESACTIVE + XDC_EQT_INHIBE
/*	vl_parametres[4].data	= XDC_EQT_HS + XDC_EQT_MAJEUR + XDC_EQT_CRITIQUE + XDC_EQT_DESACTIVE + XDC_EQT_INHIBE */
	vl_parametres[4].output	= FALSE

	vl_parametres[5].type	= SYB#INT4_			' Exclusions niees
	vl_parametres[5].data	= 0
	vl_parametres[5].output	= FALSE

	IF COM05_SQL_Procedure (XZAT01_Liste_Eqt_Dispo,
						vl_parametres,vl_resultats,C_MODULE) <> COM_OK
	RETURN (COM_NOK)

	/*A récuperation du select dans la liste 'vl_Liste_select' */
	vl_Liste_select = vl_resultats.select_results[0]
/*	if va_type = XDC_EQT_ECH { vm_liste_Ech = vl_Liste_select }*/
	vl_taille = ARRAY_SIZE@(vl_Liste_select) - 1	

	/*A Construction de la liste des équipements */
	k = 0
	if vl_taille>=0 
	{
	for i = 0 to vl_taille	

		/*A Format du n° d'equipement */
		if LEN@(vl_Liste_select[i,1]) = 1
		 { vl_Liste_select[i,1] = "00" ++ vl_Liste_select[i,1] }
		if LEN@(vl_Liste_select[i,1]) = 2
		 { vl_Liste_select[i,1] = "0" ++ vl_Liste_select[i,1] }

		vl_localisation.NumAuto = vl_Liste_select[i,3]
		vl_localisation.PR = vl_Liste_select[i,4]
		vl_localisation.sens_circulation = vl_Liste_select[i,5]

/*		vl_Liste[i] = "ECH" ++ COM10_Localisation(vl_localisation)*/

		/*A recherche du nom de l'echangeur  */
		vl_index= -1
		for j = 0 to ARRAY_SIZE@(vm_F_echangeur)-1
			if vm_F_echangeur[j,1] = vl_Liste_select[i,2] 
			{ vl_index = j }	
		next j
/*		if vl_index=-1		
		{
			vl_Liste[i] = vl_Liste[i] ++ "  : Non pilotable"
		}
		else
		{
			if vm_F_echangeur[vl_index,5]<1 
			{
				vl_Liste[i] = vl_Liste[i] ++ "  " ++ vm_F_echangeur[vl_index,2]
								++ "  : Non pilotable"
			}
		
			else
			{
				vl_Liste[i] = vl_Liste[i] ++ "  " ++ vm_F_echangeur[vl_index,2]
			}		
		}*/
		if vl_index<>-1 
		{
			if vm_F_echangeur[vl_index,5]>0
			{
				vl_Liste[k] = "ECH" ++ COM10_Localisation(vl_localisation)
				vl_Liste[k] = vl_Liste[k] ++ "  " ++ vm_F_echangeur[vl_index,2]
				if va_type = XDC_EQT_ECH 
				{
					pos = ARRAY_INDEX@(vm_noms_echangeurs_renoves, vm_F_echangeur[vl_index,2])
					/*  ABE 27-04-2015 : projet suppression ancienne GTC (GTCA) */
					/*
					if ( pos > -1) 
					{
						COM01_Trace(0, "L'echangeur " ++ vm_F_echangeur[vl_index,2] ++ " est renove")
						vl_Liste[k] = vl_Liste[k] ++ " (*** rénové ***)"
					}
					*/
					vm_liste_Ech[k] = vl_Liste_select[i] 
				}
				k = k + 1
			}
		}
		
	next i
	}
	else	{ vl_Liste = "" }

	RETURN (vl_Liste)

ENDMACRO



 
/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :	Retourne un message à l'operateur et trace l'accès interdit
*				à une macro.
*
* ----------------------------------------------------------------------------*/

MACRO ITMA_TEC_Acces_interdit(va_NomMacro)

/*-----------------------------------------------------------------------------
* ARGUMENTS EN ENTREE : 
*		va_NomMacro	:	le nom de la macro interdite
*
* ARGUMENTS EN SORTIE : aucun
*
* CODE RETOUR	: COM_OK en cas d'execution correcte, COM_NOK sinon.

* CONDITION D'UTILISATION :
*   appel d'une macro avec les droits d'accès insuffisant.
*
* FONCTION :
*	Retourne un message à l'operateur et trace l'accès interdit à une macro
*---------------------------------------------------------------------------- */

	/*A message d'info à l'opérateur */
	var		vl_tptext			' zone de text tampon
	
	vl_tptext = "L'utilisateur " ++vm_NomOperateur ++ " n'a pas les droits suffisants" ++ NUM_TO_STRING@(10) ++ "pour la fonction : " ++ va_NomMacro
	info_message@(vl_tptext)

	/*A trace de l'appel de procedure */
	vl_tptext = COM09_Date_Courante()  
	vl_tptext =  vl_tptext ++ " Accès Macro "
				 ++ va_NomMacro ++ " refusé pour " ++ vm_NomOperateur
	COM01_Trace(0,vl_tptext)

ENDMACRO


/* Chargement du fichier de configuration de l'echangeur renove */
MACRO ITMA_TEC_ChargerFichierRenove(va_code_echangeur)
var vl_F_tpm
var vl_taille
var vl_index
var i
var j
var vl_ligne
var vl_tab
var vl_taille2

	/*A Chargement du fichier de config equipement signalisation du tunnel */
	vm_Eqp_Signalisation = null
	vl_F_tpm = READ_ASCII_FILE@(REP_RENOVE ++ va_code_echangeur ++ "/ConfigEqtSignalisation_" ++ va_code_echangeur ++ ".cfg")
	COM01_Trace(0, "Chargement du fichier "++REP_RENOVE ++ va_code_echangeur ++ "/ConfigEqtSignalisation_" ++ va_code_echangeur ++ ".cfg");
	vl_taille = ARRAY_SIZE@(vl_F_tpm) -1
	vl_index = 0
	for i = 0 to vl_taille
	  vl_ligne = ARRAY_FROM_STRING@(vl_F_tpm[i],",")
	  vl_tab = ARRAY_SIZE@(vl_ligne)
	  if substring@(vl_F_tpm[i],1,1) <> "#" and vl_tab > 1
	  {
	    vl_taille2 = ARRAY_SIZE@(vl_ligne) -1
	    for j = 0 to vl_taille2
	  
	      if STRING_INDEX@(vl_F_tpm[i],  "->") <> 0
	      {
	          vm_Eqp_Signalisation[0,j]=TRIM@(TABS_TO_SPACES@(vl_ligne[j]))
	      }
	      else vm_Eqp_Signalisation[vl_index,j]=TRIM@(TABS_TO_SPACES@(vl_ligne[j]))
	    next j
	    vl_index = vl_index + 1
	  }
	next i
ENDMACRO


/* ----------------------------------------------------------------------------
* SERVICE RENDU : creation generique des equipements GTC renovee
*
*  ----------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TEC_creation_eqp_signalisation_renove()
var vl_taille
var i
var vl_num_eqp
var vl_type_eqp
var vl_numero
var vl_icon
var vl_xpos, vl_ypos, vl_xpos2, vl_ypos2
var vl_color
var vl_titre,vl_titre2,vl_titre3,vl_titre4

/*A Créer et positionner les panneaux */
vl_color[0] = 255
vl_color[1] = 0,0,0
vl_color[0] = 1
vl_color[1] = 255,255,255


vm_F_bouton = null
vl_taille = ARRAY_SIZE@(vm_Eqp_Signalisation) -1
for i = 1 to vl_taille
	vl_numero = i
	vl_num_eqp = vm_Eqp_Signalisation[vl_numero,4]
	vl_type_eqp = vm_Eqp_Signalisation[vl_numero,3]
	vm_F_bouton[vl_numero,0]	= 0					' le n° du picto associé
	vm_F_bouton[vl_numero,1]	= vm_Eqp_Signalisation[vl_numero,0] 'num eqt
	vm_F_bouton[vl_numero,2]	= vm_Eqp_Signalisation[vl_numero,14] 'picto par defaut
	vm_F_bouton[vl_numero,3]	= vm_Eqp_Signalisation[vl_numero,1]  'type (T ou E)
	vm_F_bouton[vl_numero,4]	= vm_Eqp_Signalisation[vl_numero,4]  'n° eqt en base
	vm_F_bouton[vl_numero,5]	= vm_Eqp_Signalisation[vl_numero,7] 'defaut critique
	vm_F_bouton[vl_numero,6]	= vm_Eqp_Signalisation[vl_numero,8] 'defaut majeur
	vm_F_bouton[vl_numero,7]	= vm_Eqp_Signalisation[vl_numero,9] 'defaut mineur
	vm_F_bouton[vl_numero,8]	= vm_Eqp_Signalisation[vl_numero,10] 'hors service
	vm_F_bouton[vl_numero,9]	= vm_Eqp_Signalisation[vl_numero,11] 'pas de defaut
	vm_F_bouton[vl_numero,10] = vm_Eqp_Signalisation[vl_numero,12] 'mode local
	vm_F_bouton[vl_numero,11] = vm_Eqp_Signalisation[vl_numero,13] 'mode distant
	vm_F_bouton[vl_numero,12] = vm_Eqp_Signalisation[vl_numero,3]	'type equipement (SAE)

	vl_icon 	= vm_Eqp_Signalisation[vl_numero,14]  'le picto à afficher par defaut
	vl_xpos 	= vm_Eqp_Signalisation[vl_numero,5]	' la position X
	vl_ypos 	= vm_Eqp_Signalisation[vl_numero,6]	' la position Y

	/* creation des objets cadre et mode local */
	vl_titre3 = "BP_cadre" ++ vl_numero
	DB_CREATE_CTRL@(vm_fenetre_TEC,6,vl_titre3,	vm_Eqp_Signalisation[vl_numero,11],vl_xpos-3,vl_ypos - 280-3,0)
	DB_CTRL_DISPLAY@(vm_fenetre_TEC,vl_titre3,FALSE)

	'' positionner le mode local en fonction du type de picto
	if STRING_INDEX@(vl_icon,"40_40") <> 0
	{
		vl_xpos2 = vl_xpos+50
		vl_ypos2 = vl_ypos - 250
	}
	else
	{
		vl_xpos2 = vl_xpos+100
		vl_ypos2 = vl_ypos - 250
	}

	vl_xpos2 = vl_xpos-7
	vl_ypos2 = vl_ypos - 300

	vl_titre4 = "BP_local" ++ vl_numero
	DB_CREATE_CTRL@(vm_fenetre_TEC,6,vl_titre4,	vm_Eqp_Signalisation[vl_numero,12],vl_xpos2,vl_ypos2,0)
	DB_CTRL_DISPLAY@(vm_fenetre_TEC,vl_titre4,FALSE)

	/* creation des objets BP commande et BP etat */
	vl_titre 	= "BP_cmd" ++ vl_numero
	vl_titre2 = "BP_panneau" ++ vl_numero
	DB_CREATE_CTRL@(vm_fenetre_TEC,3,vl_titre,vl_icon,vl_xpos,vl_ypos,0)
	DB_CREATE_CTRL@(vm_fenetre_TEC,6,vl_titre2,vl_icon,vl_xpos,vl_ypos - 280,0)
	DB_CTRL_BUTTON_TYPE@(vm_fenetre_TEC,"BP_panneau"++vl_numero,4)
	DB_CTRL_BUTTON_TYPE@(vm_fenetre_TEC,"BP_cmd"++vl_numero,4)
	DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_panneau"++vl_numero,True)

	/*!! Ajout des numeros de panneaux au dessus des cadres */
  	vl_titre  = "BP_Lib_Pan" ++ vl_numero	' libelle panneau
  	vl_titre2 = "BP_Lib_Cmd" ++ vl_numero	' libelle cmd panneau
	if ( vl_num_eqp > 100000 ) 
	{	vl_numero = vl_num_eqp - 1000	}
	else
	{	vl_numero = vl_num_eqp	}

 	DB_CREATE_CTRL@(vm_fenetre_TEC,3,vl_titre,vl_type_eqp ++ "-"++ vl_numero,vl_xpos+9,vl_ypos-296,0)
	DB_CTRL_WIDGET_COLOR@(vm_fenetre_TEC,vl_titre,vl_color)
	DB_CTRL_FONT@(vm_fenetre_TEC, vl_titre,"-adobe-courier-bold-r-normal--10-100-75-75-m-65-iso8859-1")
/*-adobe-courier-bold-r-normal--15-140-75-75-m-150-iso8859-1*/
	
  DB_CTRL_GRAYED@(vm_fenetre_TEC,vl_titre,True)

 	DB_CREATE_CTRL@(vm_fenetre_TEC,3,vl_titre2,vl_type_eqp ++ "-"++ vl_numero,vl_xpos+9,vl_ypos-16,0) 
 	DB_CTRL_WIDGET_COLOR@(vm_fenetre_TEC,vl_titre2,vl_color)
	DB_CTRL_FONT@(vm_fenetre_TEC, vl_titre2,"-adobe-courier-bold-r-normal--10-100-75-75-m-65-iso8859-1")
/*-adobe-courier-bold-r-normal--14-100-75-75-m-150-iso8859-1")*/
	DB_CTRL_GRAYED@(vm_fenetre_TEC,vl_titre2,True)

next i


RETURN

ENDMACRO


/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :	Choisir le picto suivant pour le panneau désiré
*
*  ----------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TEC_pix_suivant_renov(va_num)

/*
* ARGUMENTS EN ENTREE : 
*	va_num	: le N° du bouton
*
* ARGUMENTS EN SORTIE : Aucun
*
* CODE RETOUR         : COM_OK
*
* CONDITION D'UTILISATION
*   Clique sur un panneau dans le vue tunnel
*
* FONCTION
*    Choisir le picto suivant pour le panneau désiré
*
---------------------------------------------------------------------------- */

var	vl_titre
var	vl_objet
var i
var	vl_trouve
var vl_num_eqp
var vl_icon
var vl_xpos
var vl_ypos
var vl_tmp
var vl_pos
var vl_taille
var tl_eqp
var vl_index
var vl_id_eqp

vl_objet = "BP_cmd" ++ va_num
vl_trouve = false

/*A dégriser le bouton 'BP_executer' */
DB_CTRL_GRAYED@(vm_fenetre_TEC,"BP_executer",False)

/*A MAJ du mode manuel sur le bouton 'BP_manuel' */
'DB_CTRL_TITLE@(vm_fenetre_TEC,"BP_manuel","pix_manu")
DB_CTRL_DISPLAY@(vm_fenetre_TEC,"BP_manuel",TRUE)
/*A MAJ du mode manuel sur le bouton 'BP_manuel' */
DB_CTRL_TITLE@(vm_fenetre_TEC,"BP_manuel","pix_manu")

/*DB_DESTROY_CTRL@(vm_fenetre_TEC,"BP_manuel")*/
/*DB_CREATE_CTRL@(vm_fenetre_TEC,3,"BP_manuel","pix_manu",POSX_BP_INDIVIDUEL,POSY_BP_INDIVIDUEL,0)*/
/*DB_CTRL_BUTTON_TYPE@(vm_fenetre_TEC,"BP_manuel",4)*/

vl_tmp = NULL

vl_num_eqp = vm_F_bouton[va_num,1]
tl_eqp = ARRAY_COLUMN@(vm_Eqp_Signalisation, 0)
vl_index = ARRAY_INDEX@(tl_eqp, vl_num_eqp)
vl_tmp = vm_Eqp_Signalisation[vl_index]
vl_id_eqp = vm_Eqp_Signalisation[va_num,3]

vl_pos = vm_F_bouton[va_num,0] ''n° de position de l'icone
vl_titre = vm_F_bouton[va_num,2] ''nom de l'icone

vl_trouve = FALSE
WHILE (NOT vl_trouve)

	vl_pos = vl_pos + 1 ''incrementation de la position
	
	''verif du debordement
	vl_taille = ARRAY_SIZE@(vl_tmp)-14
	if vl_pos >= vl_taille
	{
		vl_pos = 0
	}
	''recuperation du nom de l'icone
	vl_titre = vl_tmp[vl_pos+14]

	'si le fichier pixel existet
	if( FILE_EXISTS@(REP_CONFIG ++ "pic/" ++vl_titre++".im"))
		vl_trouve = TRUE

WEND

vm_F_bouton[va_num,0]  = vl_pos ''n° de position de l'icone
vm_F_bouton[va_num,2]  = vl_titre ''nom de l'icone

/*A MAJ du bouton */
'DB_CTRL_TITLE@(vm_fenetre_TEC,vl_objet,vl_titre)
vl_icon 	= vl_titre	' le picto à afficher par defaut
vl_xpos = vm_Eqp_Signalisation[va_num,5]	' la position X
vl_ypos = vm_Eqp_Signalisation[va_num,6]	' la position Y
DB_CTRL_DISPLAY@(vm_fenetre_TEC,vl_objet,FALSE)
DB_DESTROY_CTRL@(vm_fenetre_TEC,vl_objet)
DB_CREATE_CTRL@(vm_fenetre_TEC,3,vl_objet,vl_icon,vl_xpos,vl_ypos,0)
DB_CTRL_BUTTON_TYPE@(vm_fenetre_TEC,vl_objet,4)

/*A MAJ du message status */
vl_titre = "Status : Modification du panneau " ++ vm_F_bouton[va_num,12] ++ "-" ++ vm_F_bouton[va_num,4]
DB_CTRL_TITLE@(vm_fenetre_TEC,"LI_status",vm_text)

/*A retour OK */
RETURN(COM_OK)

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :	Choisir une sequence de commande de panneaux
*
*  ----------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TEC_pix_select_renov(va_num,va_pos)

/*
* ARGUMENTS EN ENTREE : 
*	va_num	: le N° du bouton
*	va_pos	: le N° du picto désiré ( 0 :  neutre )
*
* ARGUMENTS EN SORTIE : Aucun
*
* CODE RETOUR         : COM_OK
*
* CONDITION D'UTILISATION
*
* FONCTION
*    Choisir une sequence de commande de panneaux
*
---------------------------------------------------------------------------- */

var	vl_titre
var	vl_objet
var	i
var	vl_trouve
var	vl_icon
var	vl_xpos
var	vl_ypos


vl_objet = "BP_cmd" ++ va_num
if vm_appel="ITMA_TMC"
{ vl_objet = "BP_panneau" ++ va_num }


/*a si la position est entre 0 & 10 */
if va_pos >=0 and va_pos<=10
{
	vl_titre =  vm_Eqp_Signalisation[va_num,va_pos+14]
	vm_F_bouton[va_num,0] = va_pos+0
	vm_F_bouton[va_num,2] = vl_titre

	/*A MAJ du bouton */
	vl_icon 	= vm_Eqp_Signalisation[va_num,va_pos+14]
	vl_xpos 	= vm_Eqp_Signalisation[va_num,5]
	vl_ypos 	= vm_Eqp_Signalisation[va_num,6]

	DB_CTRL_DISPLAY@(vm_fenetre_TEC,vl_objet,FALSE)
	DB_DESTROY_CTRL@(vm_fenetre_TEC,vl_objet)
	DB_CREATE_CTRL@(vm_fenetre_TEC,3,vl_objet,vl_icon,vl_xpos,vl_ypos,0)
	DB_CTRL_BUTTON_TYPE@(vm_fenetre_TEC,vl_objet,4)

	/*A retour OK */
	Return(COM_OK)
}
else
{
	Return(COM_NOK)
}

ENDMACRO



/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :	Choisir une sequence de commande de panneaux
*
*  ----------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TEC_sequence_renov(va_code_echangeur)

/*
* ARGUMENTS EN ENTREE : 
*	va_trig		: trigramme du tunnel
*
* ARGUMENTS EN SORTIE : Aucun
*
* CODE RETOUR         : la liste des etats des panneaux
*
* CONDITION D'UTILISATION
*   Selectionner le bouton 'Appel sequence' dans la vue tunnel
*
* FONCTION
*    Choisir une sequence de commande de panneaux
*
---------------------------------------------------------------------------- */


/*A Déclaration des variables statiques */
var		vl_fenetre_TEC
var		vl_fenetre_active
var		vl_controle_sortie
var		i,j				/* index de loop */
var		vl_taille		/* taille d'une table */
var 	vl_taille2		/* taille d'une table */
var		vl_rang			/* rang selectionné dans la liste */
var		vl_text			/* text à afficher dans le status */

var		vl_F_tpm		/* tableau tampon */
var		vl_F_seq		/* tableau tampon avec sequence */
var		vl_ligne		/* tableau d'une ligne */
var		vl_F_sequence	/* fichier de config des sequences */
var		vl_sequence		/* sequence selectionné dans la liste */

var		vl_icon 		/* graph à afficher dans l'objet */
var		vl_xpos 		/* position X de l'objet */
var		vl_ypos 		/* position Y de l'objet */ 
var		vl_titre  		/* titre du bouton */
var		vl_titre2  		/* titre de l'image digit */
var		vl_trouve
var		vl_longeur
var		vl_titre_fen
var		vl_tab
var		vl_index
var		pos

COM01_Trace(0, "Appel de ITMA_TEC_sequence_renov avec code echangeur = "++va_code_echangeur)

/*A Chargement du fichier de config sequence signalisation du tunnel */
vl_F_tpm = READ_ASCII_FILE@(REP_RENOVE ++ va_code_echangeur ++ "/ConfigSceSignalisation_" ++ va_code_echangeur ++ ".cfg")
vl_taille = ARRAY_SIZE@(vl_F_tpm) -1
vl_index = 0
for i = 0 to vl_taille
  vl_ligne = ARRAY_FROM_STRING@(vl_F_tpm[i],",")
  vl_tab = ARRAY_SIZE@(vl_ligne)
  if substring@(vl_F_tpm[i],1,1) <> "#"
  {
    vl_taille2 = ARRAY_SIZE@(vl_ligne) -1
  	for j = 0 to vl_taille2
  		vm_Sce_Signalisation[vl_index,j]=TRIM@(TABS_TO_SPACES@(vl_ligne[j]))
  	next j
  	vl_index = vl_index + 1
  }
next i

SET_SYSTEM_VAR@("Liste_Sequence",vm_Sce_Signalisation)

vl_F_tpm = null
for i = 1 to vl_index-1
	vl_F_tpm[i] = vm_Sce_Signalisation[i,1] 
	vl_F_seq[i] = vm_Sce_Signalisation[i]
next i

/*A Ouvertue de la liste des sequences */
vl_fenetre_TEC = DB_LOAD@("ITMA_TEC_liste_sequence")
vm_messages_acceptes[0] = COM_CANAL_FIN
DB_ACCEPT_POKES@ (vl_fenetre_TEC, vm_messages_acceptes)

/*A Positionnement de la fenetre & assignation de la fiche d'aide  
*   ------------------------------------------------------------- */
DB_XPOS@(vl_fenetre_TEC,COM_POS_X)
DB_YPOS@(vl_fenetre_TEC, COM_POS_y_FEN)
DEFINE_HELPFILE@("Liste des sequences", "./aid/ITMA_TEC_liste_sequence.aide")
DB_HELP_TOPIC@(vl_fenetre_TEC,"Liste des sequences")

DB_DISPLAY_ONLY@(vl_fenetre_TEC,True)
DB_DISPLAY@(vl_fenetre_TEC)
DB_DISPLAY_ONLY@(vl_fenetre_TEC,False)

DB_CTRL_RETURN_ON_CHANGE@(vl_fenetre_TEC,"BL_sequence",True)
DB_CTRL_STRINGS@(vl_fenetre_TEC,"BL_sequence",vl_F_tpm)
DB_CTRL_GRAYED@(vl_fenetre_TEC,"BP_valider",True)

/*A Boucle de capture des événements de la boite de dialogue  
*   -------------------------------------------------------- */
vl_fenetre_active = TRUE


/*A tant que la fenetre est active */
WHILE (vl_fenetre_active)

	/* affichage de la liste */
	DB_DISPLAY@(vl_fenetre_TEC)
	vl_titre_fen = DB_GET_TITLE@(vm_fenetre_TEC)
	''PROMOTE_DIALOG@(vl_titre_fen)

	/*A capture de l'evenement dans la BD TCA */
	vl_controle_sortie = DB_EXIT_CTRL@(vl_fenetre_TEC)

	/*A si l'evenement n'est pas un poke & verrou = vrai */
	if vl_controle_sortie<>"poke_" and SYSTEM_VAR@(vg_verrou)
		/*A reset de l'evenement */
		vl_controle_sortie = NULL 

	/* selon l'evenement */
	CASE OF vl_controle_sortie

	/*A sur action valider */
	CASE "BP_valider"

		/*A retour de la sequence */
		vl_fenetre_active=false

	/*A sur action quitter */
	CASE "BP_quitter"

		/*A Fermeture de la fenetre */
		vl_sequence[0] = -1
		vl_fenetre_active=false

	/*A sur action quitter */
	CASE "BL_sequence"

		/*A Capture du rang dans la liste des tunnels */
		vl_rang = DB_CTRL_GET_VALUE@(vl_fenetre_TEC,"BL_sequence")

		/*A Capture du libellé de la sequence choisie */
		vm_seq_select = vl_F_tpm[vl_rang]
		SET_SYSTEM_VAR@("sequence",vm_seq_select)
		SET_SYSTEM_VAR@("NumSequence",vl_F_seq[vl_rang,0])

		/*A si non existance d'une sequence pour cette selection */
		if vl_F_seq[vl_rang,2]<1 
		{
			/*A griser le bouton valider */
			DB_CTRL_GRAYED@(vl_fenetre_TEC,"BP_valider",True)
		}
		/*A sinon */
		else
		{
			/*A MAJ de vl_sequence */
		
			vl_F_tpm = vl_F_seq[vl_rang]

			''suppression des 2 premieres iterations
			vl_F_tpm = ARRAY_DELETE@(vl_F_tpm,0)
			vl_F_tpm = ARRAY_DELETE@(vl_F_tpm,0)

			vl_sequence = vl_F_tpm


			/*A trace de la sequence selectionné */
			COM01_Trace(0,"Choix sequence : " ++ vm_seq_select ++ " ---> " ++
					 vl_F_seq[vl_rang,0])

			/*A dégriser le bouton valider */
			DB_CTRL_GRAYED@(vl_fenetre_TEC,"BP_valider",False)
			/*A Fermeture de la fenetre */
			''RETURN(vl_sequence)
			vl_fenetre_active=false
		}		

	/*A sur reception de poke */
	CASE "poke_"
	
		/*A suivant le canal de reception de poke */
		CASE OF DB_GET_POKE@(vl_fenetre_TEC)

		/*A si poke de fin de canal : fermeture de fenetre */
		CASE COM_CANAL_FIN
			/*A la fenetre n'est plus active */
			vl_fenetre_active = FALSE

		ENDCASE

	ENDCASE

/*A fin tant que */
WEND

DB_CLOSE@(vl_fenetre_TEC)

RETURN(vl_sequence)

ENDMACRO

/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :	MAJ du panneau dans la vue actuelle
* 
*  ----------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TEC_MAJ_ID_renov(va_num,va_msg)

/*
* ARGUMENTS EN ENTREE : 
*	va_num	: le N° du panneau à modifier
*	va_msg	: msg recu
*
* ARGUMENTS EN SORTIE : Aucun
*
* CODE RETOUR         : COM_OK
*
* CONDITION D'UTILISATION
*   appel de cette procedure
*
* FONCTION
*    MAJ du panneau dans la vue actuelle
*
---------------------------------------------------------------------------- */

var	vl_picto, vl_picto_etat, vl_picto_mode
var	vl_objet, vl_objet_etat, vl_objet_mode
var	i
var	vl_size
var	vl_taille
var	vl_icon
var	vl_xpos
var	vl_ypos
var	vl_pos
var	vl_etat
var	vl_mode
var	vl_numeqp
var	vl_text

/* utilisation des cst pour les defaut equipement
XDC_NORMAL		0
XDC_EQP_DEF_CRIT	3
XDC_EQP_DEF_MAJEUR	2
XDC_EQP_DEF_MINEUR	1
XDC_EQP_HS		4
vl_mess[2]	type panneau (SAE)
vl_mess[3]	id panneau (SAE)
vl_mess[4]	position panneau
vl_mess[5]	etat defaut du panneau
vl_mess[6]	mode local /distant du panneau
*/


/*A si le bouton existe */
if vm_F_bouton[va_num,1] = ""
	Return(COM_NOK)

vl_numeqp = va_num
vl_pos = va_msg[4]
vl_etat =  va_msg[5]
vl_mode =  va_msg[6]

vl_xpos = vm_Eqp_Signalisation[vl_numeqp,5]
vl_ypos = vm_Eqp_Signalisation[vl_numeqp,6]

/* mode de l'equipement */
vl_objet_mode = "BP_local" ++ vl_numeqp 
if vl_mode = 0
{
	'mode distant
	DB_CTRL_DISPLAY@(vm_fenetre_TEC,vl_objet_mode,FALSE)
}
else
{
	'mode local
	vl_picto_mode = vm_Eqp_Signalisation[va_num,12]
	DB_CTRL_DISPLAY@(vm_fenetre_TEC,vl_objet_mode,TRUE)
}
/* selon l'état de l'equipement */
CASE OF vl_etat

/*A etat normal */
CASE XDC_EQP_DEF_CRIT
	vl_text = "Panneau "++vm_F_bouton[vl_numeqp,12]++"-"++vm_F_bouton[vl_numeqp,4]++" avec défaut critique !"
	vl_picto_etat = vm_Eqp_Signalisation[va_num,7]
CASE XDC_EQP_DEF_MAJEUR
	vl_text = "Panneau "++vm_F_bouton[vl_numeqp,12]++"-"++vm_F_bouton[vl_numeqp,4]++" avec défaut majeur !"
	vl_picto_etat = vm_Eqp_Signalisation[va_num,8]

CASE XDC_EQP_DEF_MINEUR
	vl_text = "Panneau "++vm_F_bouton[vl_numeqp,12]++"-"++vm_F_bouton[vl_numeqp,4]++" avec défaut mineur !"
	vl_picto_etat = vm_Eqp_Signalisation[va_num,9]

CASE XDC_EQP_HS
	vl_text = "Panneau "++vm_F_bouton[vl_numeqp,12]++"-"++vm_F_bouton[vl_numeqp,4]++" hors service !"
	vl_picto_etat = vm_Eqp_Signalisation[va_num,10]

CASE XDC_NORMAL
	vl_text = "Réception état panneau " ++vm_F_bouton[vl_numeqp,12]++"-"++vm_F_bouton[vl_numeqp,4]
	vl_picto_etat = vm_Eqp_Signalisation[va_num,11]

ENDCASE

if vm_Appel<>"ITMA_TPA"
    DB_CTRL_TITLE@( vm_fenetre_TEC,"LI_status",vl_text)


vl_objet_etat = "BP_cadre" ++ vl_numeqp 
DB_DESTROY_CTRL@(vm_fenetre_TEC,vl_objet_etat)
DB_CREATE_CTRL@(vm_fenetre_TEC, 6, vl_objet_etat, vl_picto_etat, vl_xpos-3, vl_ypos-280-3, 0)

/*A construction du nom de l'objet vl_objet */
vl_objet = "BP_panneau" ++ vl_numeqp

/*A lecture du picto disponible à cette position dans vl_picto */
vl_picto = vm_Eqp_Signalisation[vl_numeqp,vl_pos+14]
COM01_Trace (0, "Pictogramme : " ++ vl_picto)
/*A si le picto existe pour cette position : MAJ du bouton */
if TRIM@(vl_picto) <>  ""
{  
	DB_DESTROY_CTRL@(vm_fenetre_TEC, vl_objet)
	DB_CREATE_CTRL@(vm_fenetre_TEC, 3, vl_objet, vl_picto, vl_xpos, vl_ypos-280, 0)
	DB_CTRL_BUTTON_TYPE@(vm_fenetre_TEC, vl_objet, 4)
	DB_CTRL_GRAYED@(vm_fenetre_TEC, vl_objet, True)
}

Return(COM_OK)

ENDMACRO

/* Retourne le code de l'echangeur a partir du nom */
MACRO ITMA_TEC_GetTrigrammeEchangeurRenove(va_nom_ech)
	var pos
	var code
	code = "XXX"
	pos = ARRAY_INDEX@(vm_noms_echangeurs_renoves, va_nom_ech)
	if ( pos > -1)
	{
		code = vm_codes_echangeurs_renoves[pos]
	} 
ENDMACRO
