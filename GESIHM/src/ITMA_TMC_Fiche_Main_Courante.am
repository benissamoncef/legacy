/* Fichier : $Id: ITMA_TMC_Fiche_Main_Courante.am,v 1.266 2021/10/29 12:00:00 pc2dpdy Exp $     $Revision: 1.266 $        $Date: 2021/10/29 12:00:00 $
------------------------------------------------------
* STERIA *  PROJET MIGRAZUR
------------------------------------------------------
* SOUS-SYSTEME  GESIHM
------------------------------------------------------
* MODULE MTMC * FICHIER ITMA_TMC_Fiche_Main_Courante.am
------------------------------------------------------
* DESCRIPTION DU MODULE :
*
* Fiche de consultation et de mise a jour des operations
* et evenements.
*
*  Cf. DCG §2.4.52
*
------------------------------------------------------
* HISTORIQUE :
*
* NOEL	07 Sep 1994	: Creation
* NOEL  14 Oct 1994	: Mise en config pour partager le fichier
*			  non teste								V1.1
* Guilhou 16 dec 1994 	: configuration des voies			V1.6
* Guilhou	20 dec 1994	: config des voies pour basculement	V1.9
* Guilhou	22 dec 1994	: coherence pr tete et queue de bouchon	V1.10
* Guilhou	26 dec 1994	: repositionnement					V1.12
* Guilhou	26 dec 1994	: amelioration fonction config des voies   V1.13
* Guilhou	27 dec 1994	: ne plus afficher les controles specifiques
*					  a un type s'ils le sont deja		V1.14
* Guilhou	27 dec 1994	: ajout fonction surcharge			V1.15
* Guilhou	29 dec 1994	: correction recup cause				V1.16
* Guilhou	29 dec 1994	: appel depuis fiche alerte			V1.17
* Guilhou	30 dec 1994	: ajout libelle alerte dans fmc
* Guilhou	03 jan 1994	: ajout controle presence nouvelles actions
* Guilhou	26 jan 1994	: modif appel visualisation action PMV		V1.21
* Lecrivain	29 jan 1995	: Ajout de la longueur a la validation		V1.23
* Noel		01 Fev 1995	: initialisation de vm_local_ok a true si appel
*					depuis MTSE				V1.25
* Lecrivain	13 Fev 1995	: Prise en compte de l'appel depuis le synoptique V1.26
* Lecrivain	21 Fev 1995	: Suppression du bouton "Trafic FM"               V1.27
* Lecrivain	11 Avr 1995	: Changement du bouton option echangeurs en liste V1.30
* Lecrivain	14 Avr 1995	: Inhibition du lancement de plusieurs PA         V1.31
* Lecrivain	26 Avr 1995	: Changement poste : idem fin de poste            V1.34
* Lecrivain	03 Mai 1995	: Loc sur pt car. : sens circul = liste complete  V1.35
* Guilhou	24 Mai 1995	: Mode de calcul PA en mode formation		  V1.36
* Lecrivain	06 Jun 1995	: Autorisations sur activation depuis MTSE        V1.37
* Lecrivain	08 Jun 1995	: Reprise traitement des points caracteristiques V1.38
* Torregrossa   13 Jun  1995    : Ajout de la configuration terrain 
*                                  (V1.38 : confirmee)
* Torregrossa   23 Jun  1995    : Changement des etats des actions fax et appels V1.39
* Torregrossa   27 Jun  1995  : Envoi de poke sur ouverture ou validation fmc et
*                                 correction commentaire fmc V1.40
* Torregrossa   04 Jul  1995  : Modif de l'ordre icones de config de voie,
*                                 modif interface ihm description vehicule,
*                                 suppression enrichir, ajout annulation 
*                                 travaux        V1.41
* Torregrossa   10 Jul  1995  : Modif libelles actions realisees V1.42
* Torregrossa   10 Jul  1995  : Modif localisation et signale V1.43
* Torregrossa   17 Jul  1995  : Correction lecture commentaire bouchon V1.43
*                               et localisation bouchon
* Torregrossa   24 Jul  1995  : Correction point car sur fmc ferm ech V1.45
* Torregrossa   01 Aou  1995  : Supprimer positionnement en voie bloquee 
*                               pour travaux  V1.46
* Guilhou		03 Aou  1995  : correction controle sens		V1.47 
* Torregrossa	08 Aou  1995  : Ajout controle sur local. pour bouchon sur 2 
*                             autoroutes  et init numero vehicule pour fiche veh
*                                               		V1.52
* Torregrossa	22 Sep  1995  : Correction du sens pour la localisation sur aire fermee V1.53
* Torregrossa	29 Sep  1995  : Proposer la creation des travaux discontinus pour le jour suivant sur le site de creation V1.55
* Torregrossa	09 Oct  1995  : Correction test code d'erreur sur appel a xzae66 (V 1.56)
* Torregrossa	12 Oct  1995  : Decalage de la BAU (V 1.57)
* Torregrossa	13 Oct  1995  : Recherche la liste des actions realisees a 
*                               l'ouverture de la fmc a cause de la purge des 
*                               compteurs d'actions (V 1.58)
* Torregrossa	16 Oct  1995  : Afficher les bretelles de l'echangeur pour la 
*                               localisation sur echangeur (V 1.59)
* Torregrossa	18 Oct  1995  : Correction format des dates de commentaires lus en base (V 1.60) 
* Torregrossa	24 Oct  1995  : Prise en compte des sens des autoroutes au niveau des
*                               tests de coherence des PR (A57) (V1.61) 
* Torregrossa	15 Nov  1995  : Init d'une variable de retour pour sortir de la fmc sur achever (1.62,1.63)
* Torregrossa	21 Nov  1995  : Correction creation de travaux discontinus suite a achever (1.64)
* Torregrossa	22 Nov  1995  : Ajout test sur la localisation d'un bouchon a la 
*                               validation (1.65)
* Torregrossa	23 Nov  1995  : La veracite est controlee a la validation (1.66) 
* Torregrossa	27 Nov  1995  : La densite de trafic est controlee a la validation (1.67) 
* Torregrossa	05 Dec  1995  : Correction positionnement veracite dans le cas signale (1.68)
* Noel B.		12 Dec  1995  : Initialisation des positions sur echangeur (afficher_localisation )(1.69)
* Torregrossa	09 Jan  1996 	: Griser bouton plan d'action pour fmc operateur et 
*                     	        supprimer bouton fin de poste (V 1.70)
* Torregrossa	22 Jan  1996 	: FMC sous concessionnaire et meteo peuvent etre signalees (V 1.71)
* Torregrossa	23 Jan 1996	: ajout position entre parametre de sortie de XZAE40 
*                                 (V 1.72)
* Torregrossa	24 Jan 1996	: Proposer la liste des aires ayant un concessionnaire  
*                                 pour fmc sous concessionnaire (V 1.73)
* Torregrossa	26 Jan 1996	: Modif libelle sens non precise par 0 pour le libellle (1.74)
* Noel		29 Jan 1996	: "grisage" de BP_Surcharge jusqu'a la première validation (DEM676) 	V1.75
* Torregrossa	01 Fev 1996	: Grisage du bouton valider lors pour FMC en prevision consultee par 
*                                 synthese evenement par un site non createur de la FMC V1.76
* Torregrossa	01 Fev 1996	: Correction sur achever fermeture fenetre (V 1.77)
* Torregrossa	02 Fev 1996	: Correction pour fmc sous conces. pas de config voie 
*                               et revue modif liste des aires pour ce type de fmc (V1.78)
* Torregrossa	05 Fev 1996	: Correction pour fmc sous conces. du sens dans la 
*                               localisation (V 1.79)
* Torregrossa	08 Fev 1996	: Suppression de la fenetre de confirmation de fermeture fmc (V1.80)
* Torregrossa	08 Fev 1996	: Ajout controle sur la validation d'une fmc 
*                               de fermeture d'echangeur et réinit acces 
*                               inexistant                (V1.81)
* Noel		26 Fev  1996	: (DEM 831) On ne passe plus dans ITMA_TMC_valide 
*							pour un bouchon (V1.82)
*
* Torregrossa	04 Mar 1996	: Suppression des horodates prevues pour fmc operateur (V1.83) 
* Torregrossa	08 Mar 1996	: Ajout le transfert des FMC au poste voisin sur changer
*                                 de poste (V1.84)
* Guilhou	27 Mar 1996	: On ne peut lier une fiche avec elle meme V1.86 (DEM 990)
* Torregrossa	06 Mai 1996	: Correction validation de la queue de bouchon au niveau des voies de config (987) V1.87
* Torregrossa	05 Jui 1996	: Correction du sens de la fmc de type aire fermee ou sous concessionnaire (1127) V1.88
* Torregrossa	06 Jui 1996	: Modification ordre des icones de voies suivant type fmc (678) V1.89
* Torregrossa 18 Jui 1996 : Ajout grisage du bouton "ajouter comment." si FMC close 
*                           et non enrichissable (V1.90)
* Verdier     18 Jul 1996 : Mise a jour pour prise en compte appel a depanneur DEM76 (V1.91)
* Verdier	   15 Aou	1996 : Ajout bouton "Annuler FMC" (V1.92) (DEM1165)
* Guilhou	2& aou 1996 	: Modif localisation sur aire (DEM 1157) V1.93
* Verdier	   22 Aou 1996  : Ramener le delai d'affichage des FMC en prevision de 24h a 10h  (V1.94) (DEM1163)
* Guilhou	10 Sep 1996 	: suppression dump_array					(V1.95)
* Verdier  Ven 13 Sep 1996 : Correction sauve vehicule
* Torregrossa 23 Sep 1996 : Ajout bouton de recuperation des droits 
*                           d'enrichir pour fmc operateur (V1.98)(EVOL CONF4)
* Torregrossa 23 Sep 1996 : Affichage du bouton de recuperation des droits 
*                           et ajout degats domaines dans les fmc de type
*                           accident, agression, altercations usagers, animal 
*                           errant, autre evenement, chaussee deterioree, convoi 
*                           exceptionnel, eboulement, flaque d'huile, greve,
*                           holdup/vol, incendie vegetation, sous concess., 
*                           inondations,manif., obstacle, meteo, vehicule 
*                           arrete,vehicule en feu, vehicule en panne  
*                           ajout type de fmc pour l'interface de ITMA_TMC_vhl
*                           (V1.99)(EVOL CONF4+FMC10+FMC6)
* Torregrossa 30 Sep 1996 : Retypage d'une fmc (FMC3) (V1.100-101)
*                           et correction de l'affichage du site de creation des fmc de classe vehicule
*                           et modif annulation des fmc (DEM1233) 
* Torregrossa 15 Oct 1996 : Ajout controle sur saisie vitesse vehicule lent a la validation (V1.102)
* Torregrossa 15 Oct 1996 : Correction sur retypage d'une fmc (FMC3) (V1.103)
* Torregrossa 16 Oct 1996 : Ajout controle sur date de debut prevu pour fmc travaux,convoi mil et excep (DEM/1241 )(V1.104)
* Guilhou     17 oct 1996 : affinage des controles mis en place ds la version 1.104 (DEM/1241) (1.105)
* Guilhou     22 oct 1996 : config des voies sur bouchon (DEM/1249) (FMC13) 1.106 
* Torregrossa 22 Oct 1996 : ajout l'envoi d'un fax (IHM7:1250) (V1.107)
* Guilhou	    25 oct 1996 : pas de config terrain tant que la localisation de la  
*                           queue n'a pas ete saisie (DEM/1249) (FMC13) 1.108
* Niepceron   29 oct 1996 : Qualification du mesg TFM ajoutee (dem/1248) v1.109
* Torregrossa 04 nov 1996 : ajout fausse alerte (FMC18) (V1.110)
* Guilhou     05 nov 1996 : verif du format saisi des horodates (DEM/1274) (1.111)
* Guilhou     05 nov 1996 : gestion du sens pour une FMC fermeture echangeur (DEM/1180) (1.112)
* Guilhou	    06 nov 1996 : correction format des hoodates (DEM/1274) (1.113)
* Torregrossa 06 nov 1996 : ajout fausse alerte suite et fin(FMC18) (V1.114)
* Guilhou     07 nov 1996 : confirmation sur annuler FMC (DEM/1269) (1.115)
* Torregrossa 12 nov 1996 : ajout msg de confirmation sur annuler fmc en 
*                           prevision(1269) (V1.116)
* Torregrossa 13 nov 1996 : ajout configuration BAU etroite (SAD4) (V1.117)
* Guilhou     27 nov 1996 : voies bloquees par defaut pour FMC bouchon (DEM/1249) 1.118
* Torregrossa 02 dec 1996 : Suppression envoi poke COM_CANAL_MTLT_VALIDATION_FMC 
*                           pour optimiser liste a traiter (680) (V1.119)
* Guilhou 04 dec 1996 : supprimer le site de creation des vehicules (DEM/1256) 1.120
* Torregrossa 12 dec 1996 : Correction validation de localisation (XZAE66) (1330) 1.121
* Torregrossa 13 dec 1996 : Correction pb de requalification de FMC et suppression 
*                           du plan d'action sur fmc en fausse alerte (1323-1324) (V1.122)
* Torregrossa 11 dec 1996 : ajout longueur pour fmc escargot (FMC7) 1.123
* Torregrossa 16 dec 1996 : modif interface d'appel a la main courante
*                           par TMT et  (FMC9) 1.123
* Guilhou	23 dec 1996 : archivage longueur de bouchon 1.124
* Guilhou	13 jan 1997 : droit d'enrichir transmis a fiche depanneur 1.126 (DEM/1358)
* Guilhou	13 jan 1997 : tableau de neutralisation des voies pour basculement IHM5 (DEM/1372) 1.127
*			      en fait pour la fmc travaux ANA64 (DEM/1394) 1.128
* Guilhou	15 mai 1997 : creation auto fmc basculement sur fmc travaux
*				si une voie est neutralisee (DEM/1394)	1.129
* Guilhou	26 mai 1997 : maj icone de voie dans neutralisations de voies (DEM/1394) 1.130
* Guilhou	28 mai 1997: on prend le PR de la FMC si le PR de tete est nul quand on cree
*				un basculement consequence de travaux 1.131
* Guilhou	03 oct 1997 : liste des FMC cause a le m look que celle des FMC a traiter (ana/65) 1.132
* Guilhou	07 nov 1997 : appel depuis une fiche situation strada (dem/strada) 1.133
* Torregrossa 15 dec 1997 : ajout gestion de fmc degrade (1531) V1.134
* Torregrossa 08 jan 1998 : modif interface XZAE40, format ITMA_TMC (1532) V1.135
* Torregrossa 29 jan 1998 : Ajout appel fonction piltage PAL,FAC,FAU (1539) V1.136
* Guilhou	19 dev 1998 : correction FMC basculement/travaux 1.137
* Torregrossa 26 fev 1998 : ajout proposition de valuer fmc initiale a 
*                           l'achevement au CI (1583) + erreur fmc bouchon (1592)  1.138
* Guilhou	02 mar 1998 : ajout sit_origine dans la liste des actions realisees (dem/1605) 1.138
* Torregrossa 14 avr 1998 : Correction ajout annuler fmc pour pc niveau 2 1.139 (1637)
* Torregrossa 28 Avr 1998 : suppression de gestion de fmc degrade (1638) V1.140
*  Niepceron    18 Mai 1998 : Supprssion du lien cause a la creation des trv discontinus v 1.142
*  Niepceron    25 Mai 1998 : Supprssion de la recup de la desc veh lors de la validation v 1.143
*  Niepceron    27 Mai 1998 : Modification du 1er msg de confirmation de fin de poste au PC2 (DEM/1665) v 1.144
*  Niepceron    04 Jun 1998 : Test date hist. pour appel XZAC21 v1.145
* Niepceron	07 Sep 1998 : Localisation sur lit d'arret si alerte lit d'arret v1.145
* Niepceron     28 Oct 1998 : Suppression bt faxer et plan d'actions pour PC simplifié v1.146 dem/1718
* Niepceron	21 Jan 1999	: modifs intergestionnaire dem/1723
							decalage vers le bas de la fenetre pour demasquer  les icones (1727) 1.147
* Niepceron	19 Mar 1999 : Modif intergest dem/1750 1746 1.150
* ESCOTA        25 03 1999 : Gestion des icones dans la fiche travaux 1.151
* ESCOTA        25 03 1999 : Gestion du champ origine predefini 1.152
* ESCOTA        26 03 1999 : Precision du champ action realisee pour intervenants
* Guilhou	10 09 1999 : ne jamais afficher le bouton BP_config_terrain 1.152
* Guilhou	09 02 2000 : gestion optimisee des reveils 1.153
* Guilhou	24 02 2000 : creation de FMC Meteo partout (SAE52)
*			     creation de FMC salage sur une aire (SAE61) 1.154
* Cluchague     11 04 2000 : ligne 8215 l'heure de debut du basculement induit est l'heure courante. De plus on ne remet plus à jour automatiquement la config actuelle des voies (SAE72) 1.155
* Cluchague     22 08 2000 : ligne 7340 On met un message d'erreur si l'operateur met une horodate de fin pour des travaux dont toutes les icones ne sont pas au verti (SAE120) 1.158
* Cluchague     21 12 2000 : ligne 3748 message d'erreur sur travaux dont le pr de tete est non renseigne
* Hilmarcher    10 09 2003 : rajout bouton de fermetures des voies L2864 v1.160
* Hilmarcher    04 12 2003 : operation coup de poing: creation fmc avec elements pre-rensignes v1.161
* Hilmarcher    18/05/2004 : rajout demande 'photo systeme' v1.162
* Hilmarcher    07/06/2004 : lecture des FMC >1 mois directement depuis SQL_HIS (COM05 --> COM41) v1.163 
* Hilmarcher    18/11/2004 : impossible de creer une fiche travaux sur aire Peypin DEM352 v1.164
* Hilmarcher    14/02/2005 : Realisation petites evol pastre v1.165
*		             1. Pre-renseigner l'origine ESCOTA dans les FMC prevision chantiers DEM415
*                            2. Pouvoir localiser un pieton sur chaussee sur aire DEM417
* 			     3. Degats domaine pour VH en feu DEM418
*			     4. Proposer un plan d'action pour les FMC fausses alertes DEM419
*                            5. Rendre toujours actif le bouton "Transmettre FMC" DEM420
* Niepceron	14/03/2005  : Ajour d'un arg XZAE66 pour DEM439   v1.166
* Niepceron	29/03/2005  : Bouchons pre-definis  pour DEM451 v1.167
* Lizot         08 03 2004 : prise en compte des action DATEX (SAGA) v1.168
* Lizot         14 04 2004 : gestion du droit de propriete ESCOTA/DDE83 (SAGA) v1.169
* JMG		05 09 2005 : correction msg nombre de vehicules si FMC DATEX (SAGA) 1.169
* CHI		28/09/2005: FMC Obstacle animal DEM487 v1.170
* PNI		29/09/2005 : Controle lien Cause DEM497 v1.171
* JMG		11/10/05 : ajout PMVA BAF BAD 1.172
* PNI		13/06/06 : ajout msg de confirmation en cas de saisie hors réseau pour DC & DA DEM 555
* PNI		03/10/06 : ajout de la création d'une ligne dans le tableau 'Neutralisation voies' pour bouton BP_trv_vm1_i dem589 v1.174
* JPL		25/01/2007 : Position pixmaps de FAV (reorg. fiche FMC DEM607) v1.175
* JPL		06/02/2007 : Fenêtre dédiée pour saisie localisation (DEM613) v1.176
* JPL		09/02/2007 : Restriction au site faite en fenetre de saisie de localisation (DEM614) v1.177
* JPL		12/02/2007 : N'utilise plus de données de localisation site v1.178
* JPL		13/02/2007 : Gère les secondes en date de début réel (DEM615) v1.179
* JPL		14/02/2007 : Achèvement Accident: plus de message de contrôle description véhicules (DEM623) v1.180
* JPL		14/02/2007 : Gère les secondes en date de fin réelle (suite à DEM615) v1.181
* JPL		15/02/2007 : Achever FMC: contrôle de saisie date de fin réelle (DEM622) v1.182
* JPL		19/02/2007 : A l'init, assurer que la fiche tete bouchon a le bon type; nettoyage v1.183
* JPL		21/02/2007 : Sur validation localisation queue de bouchon, valuer la tete; gestion libelle v1.184
* JPL		22/02/2007 : Homogeneisation des arguments dans les differents cas d'appel v1.185
* JPL		26/02/2007 : Gestion du bouton Consequence (DEM 624) v1.186
* JPL		02/03/2007 : FMC Travaux: Clone, dates discontinus, contrôle Pr tête (DEM 627) v1.187
* JPL		06/03/2007 : Véracité par défaut "Signalée"; config des voies pour aire v1.188
* JPL		01/04/2007 : Gestion changement de classe fmc Vehicule <--> Accident (DEM 637) v1.190
* JPL		19/04/2007 : Libellé "2 sens" pour Météo, Inondation et Trait. chaussées (DEM 638) v1.191
* JPL		20/04/2007 : Ajout type FMC "Vehicule en marche arriere" (DEM 643) v1.192
* JPL		26/04/2007 : Ajout "Traitement chaussees", "Chaussee glissante" (DEM 644,646) v1.193
* JPL		27/04/2007 : Ajout "Echangeur deconseille" (DEM 645) v1.194
* JPL		21/05/2007 : Suppression des traitements sur champs de travaux mobiles (DEM 608) v1.195
* JPL		23/05/2007 : Visualisation des config de voies separee des traitements v1.196
* JPL		29/05/2007 : Gestion separee des config. de voies generiques et specifiques v1.197
* JPL		29/05/2007 : Gestion separee des config. de voies Basculement et Travaux (DEM 647) v1.198
* JPL		29/05/2007 : Ajout du type "Basculement pour travaux" (DEM 647) v1.199
* JPL		08/06/2007 : Libelle voies et message d'erreur pour Echangeur deconseille v1.200
* JPL		26/06/2007 : Restauration creation basculement a l'achevement de travaux v1.201
* JPL		28/08/2007 : Formatage date validation d'une FMC en prevision ou close (DEM 692) 1.202
* JPL		28/08/2007 : Restructuration macro de validation 1.203
* JPL		17/10/2007 : Ajout appel par MTCP pour "coup de poing" (DEM 706) 1.204
* JPL		29/10/2007 : Retypage: action prealable sur donnees specifiques; ordre ecriture (DEM 720) 1.205
* PNI		19/12/2007 : Appel pour recup droit enrichir DEM737 1.206; Correction 1.207
* JBL		Nov 2007   : DEM 665 1.208
* JBL		Mai 2008   : DEM 665 Ajout GTC_ECH 1.209
* JPL		27/08/2008 : Envoi message a MTLT a la fermeture de la fiche (DEM 721) 1.210
* JPL		03/09/2008 : Validation: fonction separee de controles de validite 1.211
* JPL		10/09/2008 : Validation bouchon: appel pilotage camera avec Pr queue si demande (DEM 807) 1.212
* JPL		24/09/2008 : Envoi parametre de creation de fiche a MTLT (suite DEM 721) 1.213
* JPL		13/10/2008 : Controle du Pr de tete delegue aux modules specifiques (DEM 814) 1.214
* JPL		17/11/2008 : Gestion complete du compte-rendu de la saisie  1.215
* JMG		03/12/08 : ajout schema ecoulement dans accident 1.216 DEM/853
* JPL		12/01/2009 : Modifications mineures; version identique a la precedente  1.217
* JPL		12/01/2009 : Gestion des droits d'enrichissement partages sur le site (DEM 848) 1.218
* PNI		12/03/2009 : possibilite de déclarer des horodates pour une BAU roulante dans le tableau des neutralisation de voies DEM864 v1.219
* JPL		19/03/2009 : Choix de cause: en creation, ne pas verifier les boucles de consequences (DEM 112) 1.220
* JPL		20/03/2009 : Controles des donnees avant la validation (Fmc Vehicule seulement) 1.221
* JPL		03/06/2009 : Rafraichissement donnees vehicules a la fermeture fiche depanneur (poke) 1.222
* JMG		xx/09/2009 : Sectorisation 1.223
* JPL		21/09/2009 : Fixer plus tot la cause de la tete et ne pas modifier la fiche generique (DEM 911) 1.224
* JPL		24/09/2009 : Ignorer plan d'action et msg. TFM du SAD sur FMC autre (ex. tete bouchon) (DEM 906) 1.225
* JPL		16/10/2009 : Autoriser une date nulle pour lire la liste des actions (ouverture fiche) (DEM 916) 1.226
* JPL		20/11/2009 : Visu. schemas d'ecoulement sur action bouton pour tout type Fmc (DEM 919) 1.227
* PNI		05/07/2010 : Suppression de la mise à jour de l'horodate reçu pour les bouchons lors d'un appel venant de MTSE.DEM940 1.228
* JPL		26/07/2010 : Prise en compte FMC Zone de Stockage (DEM 942) 1.229
* JMG		15/02/2011 : correction actions radio 1.230
* JPL		07/03/2011 : Envoi message a la fenetre de pilotage rapide pour associer camera (DEM 949)  1.231
* LCL		19/07/2011 : Gestion rappel client 1.232, 1.233  DEM 1000
* JPL		29/09/2011 : Visu. schemas d'ecoulement au PR en section courante pour evenements sur bretelles (DEM 991)  1.234
* JPL		10/10/2011 : Transmission donnees fiche completes a MTFX dans tous les cas (DEM 995)  1.235
* LCL		15/11/2011 : Correction problème affichage FMC vehicule  1.236
* LCL		23/11/2011 : Gestion vitesse et vitesse opposee (DEM 1015)  1.237
* JPL		06/01/2012 : Changement libelles 'message Trafic FM" en "message RVA" (DEM 1007)  1.238
* JPL		12/01/2012 : Conserver en donnees publiques les valeurs d'origine Fmc lues en base  1.239
* JPL		16/01/2012 : Champ "Origine" de la Fmc = libelle du bouton + texte libre (DEM 1012)  1.240
* PNI		07/03/2012 : Poratge Linux pour schema ecoulement en pdf 1.241
* PNI		26/03/2012 : Ajout calcul de vitesse du BT_voiesret 1.242 DEM1030
* JMG		29/05/2012 : communautaire 1.243
* JMG		04/06/2012 : Regulation DEM/1016  1.244
* JPL		10/09/2012 : Prise en compte de la classe Incendie (DEM 1037)  1.245
* JPL		22/10/2012 : Gestion des conditions de conduite hivernale pour les Fmc Meteo (DEM 1032)  1.246
* PNI		10/11/2014 : Ecoulement : Supression de mode preview pour la visualisation en cascade des fichiers ecoul 1.247 1.248 DEM1124
* JMG		26/04/2016 : ajout actions pilotage SAGA 1.249
* JMG		29/11/16 : ajout majeur lot 23 1.250
* JMG		09/03/18 : multi autoroutes 1.251 + CTRL_FEUX DEM1284
* JMG		14/06/18 : correction multi 1.252
* JMG		16/08/18 : correction qualif multi auto 1.253
* JPL		31/08/18 : Ecrire poste et horodates d'ouverture/fermeture fiche si profil exploitation (DEM 1300)  1.255
* JMG		09/10/18 : Ajout SMS LOT25 DEM1301 1.256
* JPL		04/04/19 : Lire / ecrire l'indicateur d'écoulement avec les données de validation historisées (DEM 1326)  1.257
* JMG		20/05/19 : modif multi autoroutes 1.258
* RGR		28/05/19 : vérification des conditions lors de l'achèvement de la FMC	1.259
* RGR		11/06/19 : DEM1329 - Correction conditions pour travaux         1.260
* RGR		03/07/19 : DEM1342 - Evolution FSE pour les aires		1.260
* PNI		18/07/19 : DEM1345 - Ajout Bouton Camera			1.260
* JPL		25/09/19 : Basculement pour Travaux: forcer l'absence de bouchon mobile à la validation si FMC terminée
*		            et en début / fin de circulation inversée en VR_I    (DEM 1346)  1.261
* LCL   	22/04/20 : MOVIS Ajout site local pilotage DEM-SAE93
* CGR		13/01/21 : Ajout IMU DEM-SAE155 1.263
* CGR           03/04/21 : Ajout SONO PAU DEM-SAE244 1.264
* ABE		15/10/21 : Ajout Configuration TOPS pour appel fiche ecoulement DEM-SAE228 1.265
* ABE		28/10/21 : Ajout num écran du fichier tops dans la commande DEM-SAE228 1.266
----------------------------------------------------------------------------------*/

include 	"dbase_.am"

include 	"XDMICG/inc/xdc_ax.h"
include 	"XDMICG/inc/xdf_ax.h"
include 	"XDMICG/inc/xzic_ax.h"
include 	"XDMICG/inc/xzaec_ax.h"
include 	"XDMICG/inc/xzaac_ax.h"

include 	"GESIHM/inc/ITMA_COM.h"
include 	"GESIHM/inc/ITMA_TDO.h"
include 	"GESIHM/inc/ITMA_TAR.h"
include 	"GESIHM/inc/ITMA_TFL.h"
include 	"GESIHM/inc/ITMA_TMC.h"
include 	"GESIHM/inc/ITMA_TRG.h"

include 	"GESIHM/inc/xzac21sp.h"
include 	"XDMICG/inc/xzac27sp.h"
include 	"GESIHM/inc/xzae40sp.h"
include 	"GESIHM/inc/xzae110sp.h"
include 	"GESIHM/inc/xzae66sp.h"
include 	"XDMICG/inc/xzae95sp.h"
include 	"GESIHM/inc/xzae154sp.h"
include 	"GESIHM/inc/xzao22sp.h"
include    	"GESIHM/inc/xzae551.h"  /* Ajout SAGA */
include    	"GESIHM/inc/xzae68sp.h" 
include    	"GESIHM/inc/xzae209sp.h" 
include    	"GESIHM/inc/xzae210sp.h" 
include 	"GESIHM/inc/xzai601sp.h"


define 	C_MODULE	"MTMC"


/* pictogrammes associes aux commentaires*/
DEFINE	C_PICTO_ENRICHIR	"pix_crayon"
DEFINE	C_PICTO_PAR_DEFAUT	"pix_designer"

/*
 * Categories de voies et bau 
 * --------------------------
 */
DEFINE	TMC_VOIE_CIRCULEE	0
DEFINE	TMC_VOIE_CIRC_INV	1
DEFINE	TMC_VOIE_BAU		2
DEFINE	TMC_VOIE_BAU_INV	3


/* Frequence du timer attache a la fenetre */
DEFINE	C_FREQUENCE_TIMER	5
DEFINE	C_DUREE_INHIB_PA	40

/* position des libelles et des valeurs dans la table des valeurs de veracite */
DEFINE	C_LIB_VERACITE	0
DEFINE	C_VAL_VERACITE	1

/* differents modes de la fmc */
define	MODE_CREATION	0
define	MODE_MODIF	1
define	MODE_CLOS	2

DEFINE	COL_LIB		3
DEFINE	COL_EXP		4

FORMAT	localisation
		NumAutoroute,
		NomAutoroute,
		Pr,
		Sens,
		LibSens,
		PtCar,
		NomPtCar,
		Position,
		NomPosition


FORMAT TMC_actions
	numero,
	site,
	site_origine,
	type,
	heure,
	etat,
	sous_type_astreinte

FORMAT TMC_actionFiche
	numero_fiche,
	cle_fiche,
	numero_action,
	cle_action,
	libelle_fiche,
	heure_action,
	etat_action,
    domaine_action


/*
 * Définition des variables globales
 * ---------------------------------
 */

/*
 * Données générales, constantes et indépendantes du type de FMC
 * -------------------------------------------------------------
 */

VAR vm_site			'numero du site local

/* Données de localisation */
VAR FORMAT TDO_District tm_sites

VAR FORMAT TDO_Autoroute	tm_autoroutes
VAR FORMAT TDO_Sens_Circulation	tm_sens_echangeur

VAR FORMAT TDO_Echangeur	tm_echangeurs
VAR FORMAT TDO_Gare		tm_gares
VAR FORMAT TDO_Aire		tm_aires
VAR FORMAT TDO_Lit_Arret	tm_lits_arret

VAR 				tm_etats_actions

VAR FORMAT TMC_multi_auto	tm_multi, vm_multi

/* Icones des fav, position et taille dans le tableau des icones */
VAR tm_pix_fav, tm_pix_bau, tm_pix_fav_inv, tm_pix_bau_inv

VAR tm_veracite				' table des valeurs de veracite

VAR FORMAT TDO_Libelle_Predefini tm_origines, tm_choix_origine
VAR FORMAT TDO_Libelle_Predefini tm_code_matiere, tm_code_matiere_valide

VAR FORMAT TDO_Type_FMC tm_types_fmc	'table de tous les types

VAR tm_icones_voies		'tableau des ordres des icones de voie par type fmc

VAR tm_macro_specifique		' Table des macros gerant les donnees specifiques par type fmc


/*
 * Données génériques de la FMC
 * ----------------------------
 */

VAR FORMAT COM_Identifiant_FMC tm_num_evt	'num et cle de l'evt courant
VAR vm_type_fmc			'type de la fiche main courante ACTUELLEMENT CHOISI
VAR vm_fenetre			'id de la boite de dialogue
VAR FORMAT TMC_fmc vm_fiche	'fiche main courante
VAR tm_donnees_specifiques	'tampon(s) des donnees specifiques au type d'evenement

VAR vm_horodate

VAR tm_config			' liste des configurations de voies

VAR vm_compteurActions
VAR FORMAT TMC_actions 	tm_actions
VAR FORMAT TMC_comment	tm_comment
VAR tm_liste_causes

VAR FORMAT TDO_Type_FMC tm_ListeTypesFMC	/* liste des types possibles pour le retypage de fmc*/


/*
 * Données spécifiques au type de la FMC
 * -------------------------------------
 */

VAR vm_nb_vehicules		' Nombre de vehicules impliques dans un accident

/* Tampons des données spécifiques au type de FMC */
VAR FORMAT TMC_accident		vm_tampon_accident
VAR FORMAT TMC_bascul		vm_tampon_bascul
VAR FORMAT TMC_bouchon		vm_tampon_bouchon
VAR FORMAT TMC_delestage	vm_tampon_delestage
VAR FORMAT TMC_echangeur	vm_tampon_echangeur
VAR FORMAT TMC_manif		vm_tampon_manif
VAR FORMAT TMC_meteo		vm_tampon_meteo
VAR FORMAT TMC_nature		vm_tampon_nature
VAR FORMAT TMC_operateur	vm_tampon_operateur
VAR FORMAT TMC_sousconce	vm_tampon_sousconce
VAR FORMAT TMC_travaux		vm_tampon_trv
VAR FORMAT TMC_veh_lent		vm_tampon_vhl
VAR FORMAT TMC_regul		vm_tampon_regul
VAR FORMAT TMC_incendie		vm_tampon_incendie
VAR FORMAT TMC_Fiche_Vehicule		tm_vehicules

/* spécifiques aux bouchons */
VAR FORMAT COM_Identifiant_FMC tm_num_queue,tm_num_tete
VAR FORMAT COM_Identifiant_FMC tm_num_queue2,tm_num_tete2
VAR FORMAT TMC_fmc vm_fiche_tete,vm_fiche_queue
VAR FORMAT TMC_fmc vm_fiche_queue_inter
VAR FORMAT TMC_fmc vm_fiche_tete_inter
VAR vm_flag_bouchon
VAR vm_enrichir_queue,vm_enrichir_tete
VAR vm_local_tete_ok
VAR tm_config_tete
VAR FORMAT localisation	vm_local_tete 'localisation de la tete de bouchon

/* spécifiques aux basculements et travaux */
VAR tm_config_bascul		' liste des configurations de voies pour basculement
VAR tm_config_trv		' liste des configurations de voies pour travaux


/*
 * Variables d'état
 * ----------------
 */

VAR vm_etat_fmc		'etat prevision, traiter ou clos
VAR vm_mode_appel	'mode creation ou mode modification
VAR vm_mode_formation

VAR vm_enrichir

VAR vm_fiche_vehicule
VAR vm_fiche_echangeur
VAR vm_fiche_operateur
VAR vm_fiche_aire
VAR vm_fiche_frontiere
VAR vm_fiche_regulation

VAR vm_local_ok			'indique qu'une localisation a ete saisie

VAR 	vm_appelant		/* nom du module appelant */


/*
 * Variables utilitaires
 * ---------------------
 */

VAR vm_heure_ouverture_fiche
VAR vm_intitule					/* intitule de la FMC (texte) */
VAR vm_calcul_pa
VAR vm_delai_PA					/* Delai a ecouler avant le lancement d'un nouveau PA */
VAR vm_reference_strada
VAR FORMAT TDO_NIV_LIB vm_liste_niveaux

VAR FORMAT localisation	vm_local	'localisation



/*----------------------------------------------------------------------------------
* SERVICE RENDU :
* Fiche de consultation et de mise a jour des operations
* et evenements.
------------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TMC_Fiche_Main_Courante (va_appelant, va_1, va_enrichir, va_etat, va_4, va_ref_strada)

/*
* ARGUMENTS EN ENTREE :
* va_appelant		identifiant de la macro appelante
* va_enrichir		definit si l'operateur a le droit ou pas d'enrichir la fiche
* va_1			suivant appelant:
*     MTLT,MTMC,MTCP	intitule fiche main courante
*		MTSE	type FMC, date, numero, cle FMC
*     MTMT,MTLL,MTES	type FMC, cause, cle cause, libelle cause
*		MTBP	type FMC, véracité,type_point_caract,point_caract,autoroute,PR,sens,VR,VM2,VM1,VL,BAU,longr,niveau
*		MTFP	type FMC, numero et type du plan d'actions, localisation
*		MSOP	numero, cle FMC ; numero, cle action ; type evt. SYNOPTIQUE
* va_etat		prevision, traiter, clos
* va_4			suivant appelant:
*  		MTLL	infos de l'alerte qui a provoque la creation de la fiche
*  		MTFP	infos du plan de secours
*
* ARGUMENTS EN SORTIE :
* neant
*
* CODE RETOUR :
*   COM_OK ou COM_NOK selon que la fiche a été validée ou non.
*
* CONDITION D'UTILISATION
*
----------------------------------------------------------------------------------*/

	VAR	vl_message		/* message envoye a un autre module */
	VAR	vl_cr			/* compte rendu d'execution */

vm_appelant = "M" ++ SUBSTRING@ (va_appelant, 6, 3)

/* en cas d'appel depuis le synoptique*/
IF vm_appelant = "MSOP"
{
	vl_message = { va_1[0], va_1[1] }
	DB_SEND_POKE@ (COM_CANAL_MTLT_FMC, vl_message)
	RETURN (COM_OK)
}


/* recuperer le mode d'ouverture de la fiche*/
vm_etat_fmc=va_etat


/* initialiser le mode de saisie (creation ou modification) selon l'appelant */
CASE OF vm_appelant
	CASE "MTMT", "MTLL", "MTFP", "MTES", "MTBP"
		vm_mode_appel = MODE_CREATION

	DEFAULT
		/* appel depuis MTSE, MTLT, MTMC (surcharge), MTCP (coup de poing) ou MTSC (formation)*/
		vm_mode_appel = MODE_MODIF
ENDCASE


/* Mémoriser la consultation de la fiche et son horodate */
vm_heure_ouverture_fiche = COM09_Date_Courante(TRUE)
SET_SYSTEM_VAR@ (vg_fmc_ouverte, TRUE)


vl_cr = ITMA_TMC_Saisie_FMC (va_1, va_enrichir, va_4, va_ref_strada)

/* demande la disparition du Plan d'action eventuellement associe */
DB_SEND_POKE@ (COM_CANAL_MTPA, "FIN")
DB_SEND_POKE@ (COM_CANAL_FIN_MSG)


/* Tracer la consultation de la fiche, sauf si elle n'est pas créée */
IF vl_cr <> COM_QUITTE {
	ITMA_TMC_Tracer_Consultation (tm_num_evt.numero, tm_num_evt.cle)
}


/* une Fmc A_TRAITER et validee (mode MODIFication) doit etre restituee */
/* des lors qu'elle n'a pas ete achevee ou transmise a un autre site */
/* (restituer aussi un bouchon dont la tete a ete transmise a un autre site) */
IF (vm_mode_appel = MODE_MODIF) AND (vm_etat_fmc = XDC_FMC_ETAT_TRAI) AND
   (vm_type_fmc <> XZAEC_FMC_PosteOperateur) AND
   (vm_enrichir <> 0  OR  vm_type_fmc = XZAEC_FMC_QueueBouchon)
{
	TMC_Reserver_Fmc (tm_num_evt.numero, tm_num_evt.cle, XDC_NON)
}


/* si la saisie d'une autre fmc n'est pas lancee, indiquer la fin aux autres modules */
IF vl_cr <> COM_VALIDE
{
	/* demander a MTLT de rafraichir la liste */
	DB_SEND_POKE@ (COM_CANAL_MTLT_RAF)

	SET_SYSTEM_VAR@ (vg_fmc_ouverte, FALSE)
}

IF (vl_cr = COM_OK) OR (vl_cr = COM_VALIDE) {
	RETURN (COM_OK)
} ELSE {
	vl_cr[0]=COM_NOK
	DB_SEND_POKE@(COM_CANAL_COMMU,vl_cr)
	RETURN (COM_NOK)
}

ENDMACRO





/*----------------------------------------------------------------------------------
* SERVICE RENDU :
*  Saisie d'une fiche main courante existante ou d'une nouvelle fiche.
------------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TMC_Saisie_FMC (va_1, va_enrichir, va_4, va_ref_strada)

/*
* ARGUMENTS EN ENTREE :
*   Voir ITMA_TMC_Fiche_Main_Courante.
*
* ARGUMENTS EN SORTIE :
* neant
*
* CODE RETOUR :
*   COM_OK		Terminaison normale, (fiche validee au moins une fois) ;
*   COM_NOK		Terminaison anormale (fiche non lue ou non creee) ;
*   COM_QUITTE		Saisie abandonnee (fiche non creee) ;
*   COM_VALIDE		Saisie non terminee (fiche validee, saisie autre fiche) ;
*   COM_SUPPRIME	Saisie terminee, fiche supprimee.
*
* CONDITION D'UTILISATION
*   ITMA_TMC_Fiche_Main_Courante
*
----------------------------------------------------------------------------------*/

	var	vl_evt			/* evenement en entrée de boucle principale 	*/
	var	vl_cr			/* compte rendu d'execution */
	var	vl_message		/* message a envoyer à la tache relais */
	var	vl_liste_canaux		/* liste des canaux en reception autorisés */
	var	vl_nom
	var  tl_numFiche		/*numero de la fiche fmc*/
	var	tl_pokeData		/*donnees du poke recu*/
	var tl_retour			/*valeurs de retour de macro*/
	var	vl_nom_macro		/*nom de la macro a executer*/
	var vl_horodate			/*horodate courante*/
	var tl_titres			/*colonnes de la liste des actions realisees*/
	var	vl_longueur		/* Longueur associee si basculement, meteo, travaux */
	var	vl_nouveau_type_fmc	/* type de la fiche main courante choisi */
	var vl_action_sel
	var tl_data
	var vl_sel
	var vl_mode
	var vl_ordre_icone_voie
	var vl_date
	var vl_val, vl_val2
	var vl_etat_voie
	var 	vl_indice
	var	vl_index, vl_index2
	var	i, j
	var	vl_installer_traitement_erreur

	var FORMAT TMC_fmc	vl_fiche

	var FORMAT TMC_Fiche_Vehicule	tl_vehicules
	var FORMAT TMC_neutral		tl_neutral

	var FORMAT TFL_Donnees_Alerte	tl_infoAlerte
	var FORMAT COM_Intitule_FMC	vl_intitule_fmc	/*intitule de la fmc*/
	var FORMAT COM_Localisation	vl_loc		/*localisation de l'evt*/
	var FORMAT TDO_Evt_Cause	tl_liste_causes
	var FORMAT TMC_actionFiche	vl_ficheAction
	var FORMAT TMC_fmc_a_creer	tl_type_fmc
	var FORMAT COM_Identifiant_FMC	tl_num_evt
	var FORMAT T_zone		tl_zones
	var tl_types_bouchon, tl_types_bouchon_valide
    VAR FORMAT TDO_Type_Astreinte vl_type_astreinte
	var vl_numero_appel
	VAR vl_arguments /* liste d'arguments pour ouverture fenetre appel telephonique */


/*
 * Traitements en cas d'erreur durant l'initialisation :
 * informer l'operateur, tracer l'erreur et abandonner
 * -----------------------------------------------------
 */
/*
ON ERROR {
    ERROR_BOX@
    COM01_Trace (COM_WARNING, COM03_Message_Erreur (C_MODULE))
    RETURN (COM_NOK)
}*/


SET_SYSTEM_VAR@ (vg_datex, XDC_FAUX)
SET_SYSTEM_VAR@ (vg_datex_propriete,XDC_VRAI) /* Ajout SAGA */
SET_SYSTEM_VAR@ (vg_datex_propriete_queue,XDC_VRAI) /* Ajout SAGA */


/* Rechercher le site local */
IF (SYSTEM_VAR@(vg_surcharge)=TRUE) {
	vm_site = SYSTEM_VAR@ (vg_site_surcharge)
} ELSE {
	vm_site = SYSTEM_VAR@ (vg_site)
}


/* Initialiser les données générales */
TMC_Init_Donnees_Globales ()

/* chargement de la config multi autoroutes*/
TMC_charge_multi()

/* charger la fenetre et la positionner sur l'écran */
vm_fenetre = DB_LOAD@("ITMA_TMC")
DB_XPOS@ (vm_fenetre, 0)
DB_YPOS@ (vm_fenetre, 105)

/* fenetre d'aide */
COM02_Attacher_Aide (vm_fenetre, "ITMA_TMC_Fiche_Main_Courante")


/* S'abonner aux canaux de reception */
vl_liste_canaux = {
	COM_CANAL_TEST,
	COM_CANAL_FIN,
	COM_CANAL_MTMC,
	COM_CANAL_MTMC_TFM,
	COM_CANAL_MTMC_PA,
	COM_CANAL_VEH_FINI
}
DB_ACCEPT_POKES@(vm_fenetre,vl_liste_canaux)


/* initialiser les valeurs des objets et rendre actifs certains */
DB_CTRL_DISPLAY@(vm_fenetre, "BP_Annuler_FMC", FALSE)

DB_TABLE_SET_MARKER_WIDTH@(vm_fenetre,"TA_comment",25)
DB_TABLE_ALLOW_COLUMN_RESIZING@(vm_fenetre,"TA_comment",FALSE)
DB_CTRL_HORIZ_SCROLL@(vm_fenetre,"TA_comment",TRUE)
DB_CTRL_RETURN_ON_CHANGE@(vm_fenetre,"TA_comment",TRUE)

DB_TABLE_ALLOW_COLUMN_RESIZING@(vm_fenetre,"TA_actions_realisees",TRUE)
DB_CTRL_HORIZ_SCROLL@(vm_fenetre,"TA_actions_realisees",FALSE)
DB_CTRL_RETURN_ON_CHANGE@(vm_fenetre,"TA_actions_realisees",TRUE)

DB_CTRL_RETURN_ON_CHANGE@(vm_fenetre,"BA_FausseAlerte",TRUE)
DB_CTRL_RETURN_ON_CHANGE@(vm_fenetre,"BA_majeur",TRUE)

DB_CTRL_STRINGS@ (vm_fenetre, "BO_veracite",
                    { COM_LIB_FMC_SIGNALEE, COM_LIB_FMC_CONFIRMEE })
DB_CTRL_RETURN_ON_CHANGE@(vm_fenetre,"BO_veracite",TRUE)

DB_CTRL_HORIZ_SCROLL@ (vm_fenetre, "TA_neutral_trv", FALSE)

DB_CTRL_HORIZ_SCROLL@ (vm_fenetre, "TA_CCH_Prec", FALSE)
DB_CTRL_HORIZ_SCROLL@ (vm_fenetre, "TA_CCH", FALSE)



/* La date et les valeurs de localisation sont NULLes par defaut */
vm_horodate=null

vl_loc.NumAuto = 0
vl_loc.Pr = 0
vl_loc.sens_circulation = 0
vl_loc.type_point_caract = 0
vl_loc.point_caract = ""
vl_loc.Position = 0

vm_fiche_tete.type=XZAEC_FMC_TeteBouchon

vm_compteurActions=NULL
vm_calcul_pa=TRUE

/* un evenement est signale par defaut*/
vm_fiche.confirme=XZAEC_FMC_SIGNALEE
vm_fiche.majeur = FALSE

/* suivant l'appelant */
CASE OF vm_appelant
	/* appel depuis MTSE*/
	CASE "MTSE"
		/* type*/
		vm_fiche.type=va_1[0]
		vm_type_fmc=vm_fiche.type

		/* parametres d'appel*/
		vm_horodate=COM18_Date_SGBD_Formatee(va_1[1])

		tm_num_evt.numero=va_1[2]
		tm_num_evt.cle=va_1[3]

		vl_intitule_fmc.idfmc.numero=tm_num_evt.numero
		vl_intitule_fmc.idfmc.cle=tm_num_evt.cle
		vl_intitule_fmc.Numtype=vm_type_fmc


		/* La localisation est supposee bonne */
		vm_local_ok=TRUE
		vm_local_tete_ok=TRUE


		/* Determination des droits d'enrichir */
		vm_enrichir = va_enrichir
		IF vm_type_fmc = XZAEC_FMC_QueueBouchon
		{
			vm_flag_bouchon=TRUE
			vm_enrichir_tete=va_enrichir
			vm_enrichir_queue=va_enrichir
		}

		IF vm_enrichir = 0
		{
			DB_CTRL_GRAYED@(vm_fenetre,"BP_valider",TRUE)
			DB_CTRL_GRAYED@(vm_fenetre,"BP_Annuler_FMC",TRUE)
		}


		/* griser tous les controles autres que fermer*/
		DB_CTRL_GRAYED@(vm_fenetre,"BP_achever",TRUE)
		DB_CTRL_DISPLAY@(vm_fenetre,"BP_transmettre",FALSE)
		DB_CTRL_DISPLAY@(vm_fenetre,"BP_transmettre_fmc",FALSE)
		DB_CTRL_GRAYED@(vm_fenetre,"BP_plan_actions",TRUE)
		DB_CTRL_DISPLAY@(vm_fenetre,"BP_changer_poste",FALSE)
		DB_CTRL_DISPLAY@(vm_fenetre,"BP_Recup_Droits",FALSE)
		DB_CTRL_DISPLAY@(vm_fenetre,"BP_surcharge",FALSE)

		/* si le mode est clos*/
		IF (vm_etat_fmc=XDC_FMC_ETAT_CLOS)
		{
			/* je grise encore d'autres boutons*/
			DB_CTRL_GRAYED@(vm_fenetre,"BP_horodebut_reelle",TRUE)
			DB_CTRL_GRAYED@(vm_fenetre,"BP_horodebut_prevue",TRUE)
			DB_CTRL_GRAYED@(vm_fenetre,"BP_horofin_reelle",TRUE)
			DB_CTRL_GRAYED@(vm_fenetre,"BP_horofin_prevue",TRUE)
			DB_CTRL_GRAYED@(vm_fenetre,"BP_cause",TRUE)
			DB_CTRL_GRAYED@(vm_fenetre,"BP_autres_causes",TRUE)

			/* on ne peut plus perimer les commentaires*/
			DB_CTRL_RETURN_ON_CHANGE@(vm_fenetre,"TA_comment",TRUE)
		}


	/* appel depuis MTLT, MTMC (surcharge), MTCP (coup de poing) ou MTSC (formation)*/
	CASE "MTLT","MTMC","MTCP","MTSC"
		/* recupere libelle et type de fmc*/
		vl_intitule_fmc=va_1

		vm_type_fmc=vl_intitule_fmc.NumType
		vm_fiche.type=vm_type_fmc

		tm_num_evt=vl_intitule_fmc.IdFMC
		vm_fiche.numero=tm_num_evt.numero
		vm_fiche.cle=tm_num_evt.cle


		vm_local_ok=TRUE


		/* Determination des droits d'enrichir */
		vm_enrichir = va_enrichir

		/* en MODIFication, une Fmc A_TRAITER doit etre reservee pour etre enrichie */
		IF (vm_mode_appel = MODE_MODIF) AND (vm_etat_fmc = XDC_FMC_ETAT_TRAI) AND
		   (vm_type_fmc <> XZAEC_FMC_PosteOperateur) AND
		   (vm_enrichir <> 0)
		{
			IF (TMC_Reserver_Fmc (tm_num_evt.numero, tm_num_evt.cle, XDC_OUI) <> COM_OK)
			{
				vm_enrichir = 0
			}
		}


		/*! si surcharge*/
		IF vm_appelant = "MTMC"
		{
			vm_calcul_pa=FALSE

			DB_CTRL_GRAYED@(vm_fenetre,"BP_achever",TRUE)
			DB_CTRL_DISPLAY@(vm_fenetre,"BP_transmettre",FALSE)
			DB_CTRL_DISPLAY@(vm_fenetre,"BP_transmettre_fmc",FALSE)
			DB_CTRL_GRAYED@(vm_fenetre,"BP_plan_actions",TRUE)
			DB_CTRL_GRAYED@(vm_fenetre,"BP_surcharge",TRUE)
			DB_CTRL_GRAYED@(vm_fenetre,"BP_valider",FALSE)
			DB_CTRL_GRAYED@(vm_fenetre,"BP_Annuler_FMC",FALSE)
		}
		/*! sinon si c'est un "coup de poing" */
		ELSE IF vm_appelant = "MTCP"
		{
			/* Ajout du commentaire "COUPURE AUTOROUTE" */
			tm_comment[0].numero = NULL
			tm_comment[0].texte = "COUPURE AUTOROUTE"
			tm_comment[0].fin = XDC_DATE_NULLE
			tm_comment[0].validation = XDC_DATE_NULLE
			tm_comment[0].site = vm_site
		}
		/*! sinon si je suis en formation*/
		ELSE IF vm_appelant = "MTSC"
		{
			vm_horodate=SYSTEM_VAR@(vg_horodate_formation)
			vm_mode_formation=TRUE
			DB_CTRL_GRAYED@(vm_fenetre,"BP_achever",TRUE)
			DB_CTRL_GRAYED@(vm_fenetre,"BP_valider",TRUE)
			DB_CTRL_GRAYED@(vm_fenetre,"BP_Annuler_FMC",TRUE)
			DB_CTRL_GRAYED@(vm_fenetre,"BP_ajout_comment",TRUE)
			DB_CTRL_DISPLAY@(vm_fenetre,"BP_transmettre",FALSE)
			DB_CTRL_DISPLAY@(vm_fenetre,"BP_transmettre_fmc",FALSE)
			DB_CTRL_GRAYED@(vm_fenetre,"BP_surcharge",TRUE)
			DB_CTRL_GRAYED@(vm_fenetre,"BP_autres_causes",TRUE)
		}

		/*! si c'est un bouchon*/
		IF (vl_intitule_fmc.NumType=XZAEC_FMC_QueueBouchon)
		{
			vm_flag_bouchon=TRUE

			tm_num_queue=tm_num_evt
			vm_fiche_queue.numero=tm_num_queue.numero
			vm_fiche_queue.cle=tm_num_queue.cle

			vm_local_tete_ok=TRUE

			/*! determine les droits d'enrichir pour la tete et la queue*/
			CASE OF vm_enrichir
				CASE 0
					vm_enrichir_tete=0
					vm_enrichir_queue=0
					DB_CTRL_GRAYED@(vm_fenetre,"BA_FausseAlerte",TRUE)
					DB_CTRL_GRAYED@(vm_fenetre,"BP_valider",TRUE)
					DB_CTRL_GRAYED@(vm_fenetre,"BP_Annuler_FMC",TRUE)
					DB_CTRL_DISPLAY@(vm_fenetre,"BP_transmettre",FALSE)

				CASE 1
					vm_enrichir_tete=0
					vm_enrichir_queue=1
					DB_CTRL_GRAYED@(vm_fenetre,"BA_FausseAlerte",TRUE)
					DB_CTRL_GRAYED@(vm_fenetre,"BP_valider",FALSE)
					DB_CTRL_GRAYED@(vm_fenetre,"BP_Annuler_FMC",FALSE)
					ITMA_TMC_enrichir()										
					DB_CTRL_TITLE@(vm_fenetre,"BP_valider","Valider queue")
				CASE 2
					vm_enrichir_tete=1
					vm_enrichir_queue=0
					DB_CTRL_GRAYED@(vm_fenetre,"BA_FausseAlerte",TRUE)
					DB_CTRL_GRAYED@(vm_fenetre,"BP_valider",FALSE)
					DB_CTRL_GRAYED@(vm_fenetre,"BP_Annuler_FMC",FALSE)
					ITMA_TMC_enrichir()										
					DB_CTRL_TITLE@(vm_fenetre,"BP_valider","Valider tête")

				CASE 3
					vm_enrichir_tete=1
					vm_enrichir_queue=1
					DB_CTRL_GRAYED@(vm_fenetre,"BP_valider",FALSE)
					DB_CTRL_GRAYED@(vm_fenetre,"BP_Annuler_FMC",FALSE)
					ITMA_TMC_enrichir()										
					DB_CTRL_TITLE@(vm_fenetre,"BP_valider","Valider")
ENDCASE
		}
		ELSE
		{
			vm_flag_bouchon=FALSE

			/* grise les controles si pas le droit d'enrichir*/
			IF (vm_enrichir=0)
			{
				DB_CTRL_GRAYED@(vm_fenetre,"BA_FausseAlerte",TRUE)

				DB_CTRL_DISPLAY@(vm_fenetre,"BP_transmettre",FALSE)
				DB_CTRL_GRAYED@(vm_fenetre,"BP_valider",TRUE)
				DB_CTRL_GRAYED@(vm_fenetre,"BP_Annuler_FMC",TRUE)
			}
		}


	/*ppel depuis MTMT ou MTLL ou MTFP ou MTES ou MTBP*/
	CASE "MTMT", "MTLL", "MTFP", "MTES", "MTBP"
		/* on ne peut pas achever la fiche ni la transmettre ni demander la surcharge*/
		DB_CTRL_GRAYED@(vm_fenetre,"BP_achever",TRUE)
		DB_CTRL_DISPLAY@(vm_fenetre,"BP_transmettre",FALSE)

		DB_CTRL_DISPLAY@(vm_fenetre,"BP_transmettre_fmc",FALSE)
		DB_CTRL_GRAYED@(vm_fenetre,"BP_plan_actions",TRUE)
		DB_CTRL_GRAYED@(vm_fenetre,"BP_surcharge",TRUE)

		/* recupere le type de fiche main courante*/
		vm_type_fmc=va_1[0] 
		vm_fiche.type=vm_type_fmc

		/*Prise en cpte des données du bouchon predefini DEM451*/
		IF vm_appelant = "MTBP"
		{
			vm_fiche.confirme=va_1[1]	
			vm_fiche.longueur=va_1[12]

			/*localisation de la fiche*/
			vm_fiche.autoroute= va_1[4]
			vm_fiche.pr       = va_1[5]
			vm_fiche.sens	  = va_1[6]
			vm_fiche.position = null
			vm_fiche.point_car = va_1[2]
			vm_fiche.num_point_car = va_1[3]
			vm_fiche.nom_point_car = ""
			if (vm_fiche.point_car = XDC_POINT_CARACT_ECHANGEUR)
			{
				vl_indice = COM45_IndexEnColonne (tm_echangeurs,0,
				                                   vm_fiche.num_point_car)
				if vl_indice > -1
					vm_fiche.nom_point_car = tm_echangeurs[vl_indice].nom
			}

			vm_local.PtCar=vm_fiche.point_car
			vm_local.NomPtCar = vm_fiche.nom_point_car
			vm_local_tete=vm_local

			vm_fiche_queue=vm_fiche
			vm_fiche_tete=vm_fiche
			vm_fiche_tete.type=XZAEC_FMC_TeteBouchon

			vm_local_ok=TRUE
			vm_local_tete_ok=TRUE

			/* Prise en cpte du niveau de trafic du bouchon */
			COM37_Lit_Libelles_Predefinis(XDC_LIB_TYPE_BOUCHON,tl_types_bouchon,tl_types_bouchon_valide)
			IF va_1[13] = null
				i=1
			ELSE
				i = COM45_IndexEnColonne (tl_types_bouchon, 1, va_1[13])
			if i=-1 then    i=1

			DB_CTRL_VALUE@(vm_fenetre, "BO_typetrafic", i)
		}

		IF vm_appelant = "MTFP"
		{
			/*! j'affiche numero et nom du plan de secours*/
			DB_CTRL_VALUE@(vm_fenetre,"BS_num_plan",va_4[1])
			DB_CTRL_TITLE@(vm_fenetre,"LI_val_nomplan_del",va_4[2])

			/*localisation par defaut de la fiche*/
			IF (va_4[3]<>NULL) 	{
				vm_fiche.nom_point_car=va_4[3]
				vm_fiche.point_car=XDC_POINT_CARACT_ECHANGEUR
				vm_fiche.autoroute=va_4[5]
				vm_fiche.pr=va_4[6]
				vm_fiche.sens=va_4[7]
				vm_local.NomPtCar=vm_fiche.nom_point_car
				vm_local.PtCar=vm_fiche.point_car
			}		
		}
		ELSE IF vm_appelant = "MTES"
		{
			/*origine*/
			vm_fiche.origine = TRIM@ (va_ref_strada)
			vm_reference_strada=true
		}

		vm_fiche.fausse_alerte=XDC_FAUX
		DB_CTRL_GRAYED@(vm_fenetre, "BA_FausseAlerte", TRUE)

		/* si c'est un bouchon*/
		IF (vm_type_fmc=XZAEC_FMC_QueueBouchon)
		{
			vm_flag_bouchon=TRUE

			vm_enrichir_tete=1
			vm_enrichir_queue=1
			vm_enrichir=3
			vm_local_tete_ok=FALSE

			vm_fiche_queue.fausse_alerte=XDC_FAUX
			vm_fiche_tete.fausse_alerte=XDC_FAUX

			/*je suis en train d'enrichir*/
			DB_CTRL_DISPLAY@(vm_fenetre,"BP_libenrichir",TRUE)
		}
		ELSE
		{
			vm_flag_bouchon=FALSE
			vm_enrichir=1
			vm_local_ok=FALSE

			/*je suis en train d'enrichir*/
			DB_CTRL_DISPLAY@(vm_fenetre,"BP_libenrichir",TRUE)
		}

		/* si je suis une fiche a traiter*/
		IF (vm_etat_fmc=XDC_FMC_ETAT_TRAI)
		{
			/* recupere l'heure courante et la formate*/
			vl_date = COM09_Date_Courante(TRUE)

			COM24_Afficher_Horodate(vl_date,vm_fenetre,
								"BS_jour_debut_reel",
								"BS_mois_debut_reel",
								"BS_annee_debut_reel",
								"BS_heure_debut_reel",
								"BS_minute_debut_reel",
								"BS_seconde_debut_reel")

		}
ENDCASE


DB_CTRL_DISPLAY@(vm_fenetre,"LI_datex",FALSE)
DB_CTRL_DISPLAY@(vm_fenetre,"BA_majeur",FALSE)

/*! si la fiche est en prevision*/
IF (vm_etat_fmc=XDC_FMC_ETAT_PREV)
{
	/* ne plus afficher horodates debut et fin reels*/
	ITMA_TMC_visible("Date debut", FALSE)
	ITMA_TMC_visible("Date fin", FALSE)

	DB_CTRL_DISPLAY@(vm_fenetre,"BP_transmettre",FALSE)
	DB_CTRL_DISPLAY@(vm_fenetre,"BP_transmettre_fmc",FALSE)
	DB_CTRL_DISPLAY@(vm_fenetre,"BP_config_terrain",FALSE)
}
/* ELSE IF (vm_etat_fmc=XDC_FMC_ETAT_TRAI)
{
	IF (vm_mode_appel=MODE_CREATION) {
		DB_CTRL_GRAYED@(vm_fenetre,"BP_config_terrain",TRUE)
	}
	DB_CTRL_DISPLAY@(vm_fenetre,"BP_config_terrain",TRUE)
} */
ELSE
{
	DB_CTRL_DISPLAY@(vm_fenetre,"BP_config_terrain",FALSE)
}


/* Ne pas afficher le bouton de config terrain pour certains types de fmc */
IF (vm_type_fmc = XZAEC_FMC_PosteOperateur OR
   vm_type_fmc = XZAEC_FMC_Manifestation OR
   vm_type_fmc = XZAEC_FMC_GreveESCOTA OR
   vm_type_fmc = XZAEC_FMC_Escargot OR
   vm_type_fmc = XZAEC_FMC_FermetureEch OR
   vm_type_fmc = XZAEC_FMC_EchDeconseille OR
   vm_type_fmc = XZAEC_FMC_Incendie OR
   vm_type_fmc = XZAEC_FMC_Inondation OR
   vm_type_fmc = XZAEC_FMC_HoldUpVol OR
   vm_type_fmc = XZAEC_FMC_MalaiseUsager OR
   vm_type_fmc = XZAEC_FMC_AltercationUsager OR
   vm_type_fmc = XZAEC_FMC_Meteo OR
   vm_type_fmc= XZAEC_FMC_Regulation)
		DB_CTRL_DISPLAY@(vm_fenetre,"BP_config_terrain",FALSE)

/* Ne pas afficher le bouton coupure autoroute pour certains types de fmc*/
IF (vm_type_fmc = XZAEC_FMC_Delestage OR
   vm_type_fmc = XZAEC_FMC_Deviation OR
   vm_type_fmc = XZAEC_FMC_PosteOperateur OR
   vm_type_fmc = XZAEC_FMC_Cirque OR
   vm_type_fmc = XZAEC_FMC_ConvoiExc OR
   vm_type_fmc = XZAEC_FMC_ConvoiMil OR
   vm_type_fmc = XZAEC_FMC_VehLent OR
   vm_type_fmc = XZAEC_FMC_GreveESCOTA OR
   vm_type_fmc = XZAEC_FMC_Basculement OR
   vm_type_fmc = XZAEC_FMC_Travaux OR
   vm_type_fmc = XZAEC_FMC_IncSsConces OR
   vm_type_fmc = XZAEC_FMC_QueueBouchon OR
   vm_type_fmc = XZAEC_FMC_FermetureEch OR
   vm_type_fmc = XZAEC_FMC_EchDeconseille OR
   vm_type_fmc = XZAEC_FMC_FrontiereFermee OR
   vm_type_fmc = XZAEC_FMC_AltercationUsager OR
   vm_type_fmc = XZAEC_FMC_Agression OR
   vm_type_fmc = XZAEC_FMC_MalaiseUsager OR
   vm_type_fmc = XZAEC_FMC_AireFermee OR
   vm_type_fmc = XZAEC_FMC_Salage OR
   vm_type_fmc = XZAEC_FMC_HoldUpVol OR
   vm_type_fmc = XZAEC_FMC_TeteBouchon OR
   vm_type_fmc = XZAEC_FMC_PietonChaussee OR
   vm_type_fmc = XZAEC_FMC_ZoneStockage OR
   vm_type_fmc = XZAEC_FMC_BasculTravaux OR
   vm_type_fmc= XZAEC_FMC_Regulation)
		DB_CTRL_DISPLAY@(vm_fenetre,"BP_coupure_aut",FALSE)

/* si je ne suis pas au CI*/
/*Rendre actif le bouton 'Transmettre FMC' --> mise en commentaire, DEM420 */
/*IF (vm_site<>XDC_CI)*/
	/* je ne peux pas transmettre la fmc*/
	/*DB_CTRL_DISPLAY@(vm_fenetre,"BP_transmettre_fmc",FALSE)*/



/* traitements specifique suivant le type de la fmc*/
CASE OF (vm_type_fmc)
	/* accident*/
	CASE XZAEC_FMC_Accident
		/* charger le module de gestion des vehicules */
		vm_fenetre = ITMA_TMC_veh (vm_fenetre, XZAEC_FMC_VehFeu, FALSE)

		/* ne plus afficher horodates debut prevue*/
		ITMA_TMC_visible("Date debut prevue", FALSE)

	/* delestage ou deviation*/
	CASE XZAEC_FMC_Delestage, XZAEC_FMC_Deviation
		/*! le delestage ne peut etre que sur echangeur*/
		vm_fiche.point_car=XDC_POINT_CARACT_ECHANGEUR

		/* confirme par defaut*/
		vm_fiche.confirme=XZAEC_FMC_CONFIRMEE

		/* ne plus afficher le bouton veracite*/
		DB_CTRL_DISPLAY@(vm_fenetre,"BO_veracite",FALSE)
		DB_CTRL_DISPLAY@(vm_fenetre,"LI_veracite",FALSE)

		/* ne pas afficher le bouton fausse alerte*/
		DB_CTRL_DISPLAY@(vm_fenetre,"BA_FausseAlerte",FALSE)


	/* vehicule a contresens, en marche arriere */
	/* vehicule arrete, en panne, en feu */
	CASE XZAEC_FMC_Contresens, XZAEC_FMC_VehMarcheArr
	CASE XZAEC_FMC_VehArrete, XZAEC_FMC_VehPanne, XZAEC_FMC_VehFeu
		vm_fiche_vehicule = TRUE

		/* ne plus afficher horodates debut prevue*/
		ITMA_TMC_visible("Date debut prevue", FALSE)


		IF vm_type_fmc = XZAEC_FMC_Contresens
		{
			vm_fiche.majeur = TRUE
  			DB_CTRL_DISPLAY@(vm_fenetre,"BA_majeur",TRUE)
			DB_CTRL_VALUE@(vm_fenetre,"BA_majeur",TRUE)
		}

	/* cirque, convoi exceptionnel ou militaire, vehicule lent*/
	CASE XZAEC_FMC_Cirque, XZAEC_FMC_ConvoiExc, XZAEC_FMC_ConvoiMil, XZAEC_FMC_VehLent
		/* convoi militaire ou exceptionnel en confirme */
		IF vm_type_fmc = XZAEC_FMC_ConvoiExc OR vm_type_fmc = XZAEC_FMC_ConvoiMil
		{
			/* confirme par defaut*/
			vm_fiche.confirme=XZAEC_FMC_CONFIRMEE

			/* ne plus afficher le bouton veracite*/
			DB_CTRL_DISPLAY@(vm_fenetre,"BO_veracite",FALSE)
			DB_CTRL_DISPLAY@(vm_fenetre,"LI_veracite",FALSE)
		}


	/* fermeture echangeur*/
	CASE XZAEC_FMC_FermetureEch, XZAEC_FMC_EchDeconseille
		vm_fiche_echangeur=TRUE

		/* charger le module de gestion des donnees echangeur */
		/* (les voies etant gerees ailleurs, en mode Modif il ne le serait pas) */
		ITMA_TMC_ech (vm_fenetre, XZAEC_FMC_FermetureEch, FALSE)

		/*! la fermeture echangeur ne peut etre que sur echangeur*/
		vm_fiche.point_car=XDC_POINT_CARACT_ECHANGEUR
		vm_fiche.sens=XDC_SENS_INCONNU

		/* confirme par defaut*/
		vm_fiche.confirme=XZAEC_FMC_CONFIRMEE

		/* ne plus afficher le bouton veracite*/
		DB_CTRL_DISPLAY@(vm_fenetre,"BO_veracite",FALSE)
		DB_CTRL_DISPLAY@(vm_fenetre,"LI_veracite",FALSE)

		/* ne pas afficher le bouton fausse alerte*/
		DB_CTRL_DISPLAY@(vm_fenetre,"BA_FausseAlerte",FALSE)

		/* modifier le texte du libelle selon le type evenement */
		IF vm_type_fmc = XZAEC_FMC_EchDeconseille
			DB_CTRL_TITLE@ (vm_fenetre, "LI_acces_ech", "Accès déconseillés")


	/* eboulement*/
	CASE XZAEC_FMC_Eboulement
		/* ne plus afficher horodates debut prevue*/
		ITMA_TMC_visible("Date debut prevue", FALSE)


	/* aire fermee, sous concessionnaire*/
	CASE XZAEC_FMC_AireFermee, XZAEC_FMC_IncSsConces
		vm_fiche_aire=TRUE

		/*! ce type d'evenement ne peut etre que sur aire*/
		vm_fiche.point_car=XDC_POINT_CARACT_AIRE

		/* aire fermee est confirmee par defaut */
		IF vm_type_fmc = XZAEC_FMC_AireFermee
		{
			/* confirme par defaut*/
			vm_fiche.confirme=XZAEC_FMC_CONFIRMEE

			/* ne plus afficher le bouton veracite*/
			DB_CTRL_DISPLAY@(vm_fenetre,"BO_veracite",FALSE)
			DB_CTRL_DISPLAY@(vm_fenetre,"LI_veracite",FALSE)

			/* ne pas afficher le bouton fausse alerte*/
			DB_CTRL_DISPLAY@(vm_fenetre,"BA_FausseAlerte",FALSE)
		}


	/* basculement*/
	CASE XZAEC_FMC_Basculement
		/*! le basculement n'est que sur section courante*/
		vm_fiche.point_car=0

		/* confirme par defaut*/
		vm_fiche.confirme=XZAEC_FMC_CONFIRMEE

		/* ne plus afficher le bouton veracite*/
		DB_CTRL_DISPLAY@(vm_fenetre,"BO_veracite",FALSE)
		DB_CTRL_DISPLAY@(vm_fenetre,"LI_veracite",FALSE)

		/* ne pas afficher le bouton fausse alerte*/
		DB_CTRL_DISPLAY@(vm_fenetre,"BA_FausseAlerte",FALSE)

	CASE XZAEC_FMC_Regulation
		/*! la regulation n'est que sur section courante*/
		vm_fiche.point_car=0

		vm_fiche_regulation=true

		/* confirme par defaut*/
		vm_fiche.confirme=XZAEC_FMC_CONFIRMEE

		/* ne plus afficher le bouton veracite*/
		DB_CTRL_DISPLAY@(vm_fenetre,"BO_veracite",FALSE)
		DB_CTRL_DISPLAY@(vm_fenetre,"LI_veracite",FALSE)

		/* ne pas afficher le bouton fausse alerte*/
		DB_CTRL_DISPLAY@(vm_fenetre,"BA_FausseAlerte",FALSE)
		DB_CTRL_GRAYED@(vm_fenetre,"BP_localisation",TRUE)
		
		/* Griser l'horodate de debut */
		DB_CTRL_GRAYED@(vm_fenetre,"BS_jour_debut_reel",TRUE)
		DB_CTRL_GRAYED@(vm_fenetre,"BS_mois_debut_reel",TRUE)
		DB_CTRL_GRAYED@(vm_fenetre,"BS_annee_debut_reel",TRUE)
		DB_CTRL_GRAYED@(vm_fenetre,"BS_heure_debut_reel",TRUE)
		DB_CTRL_GRAYED@(vm_fenetre,"BS_minute_debut_reel",TRUE)

		/*pas de prevision*/
		ITMA_TMC_visible("Date debut prevue", FALSE)
		ITMA_TMC_visible("Date fin prevue", FALSE)
	
		DB_CTRL_GRAYED@(vm_fenetre,"BP_horodebut_reelle",TRUE)

	/* travaux*/
	CASE XZAEC_FMC_Travaux
		/*je dois charger le module de gestion des basculements*/
		INSTALL_FILE@("ITMA_TMC_bascul.elo")

		/*griser les icones de config de voies*/
		for vl_indice=0 to (ARRAY_SIZE@(tm_config)-1)
			DB_CTRL_GRAYED@(vm_fenetre, tm_config[vl_indice][0], TRUE)
		next vl_indice

		/* confirme par defaut*/
		vm_fiche.confirme=XZAEC_FMC_CONFIRMEE

		/* ne plus afficher le bouton veracite*/
		DB_CTRL_DISPLAY@(vm_fenetre,"BO_veracite",FALSE)
		DB_CTRL_DISPLAY@(vm_fenetre,"LI_veracite",FALSE)

		/* ne pas afficher le bouton fausse alerte*/
		DB_CTRL_DISPLAY@(vm_fenetre,"BA_FausseAlerte",FALSE)

		/* afficher le bouton clone FMC sauf FMC en prevision*/
		IF vm_etat_fmc = XDC_FMC_ETAT_TRAI
			DB_CTRL_DISPLAY@(vm_fenetre,"BP_Clone",TRUE)
		IF vm_enrichir = 0
			DB_CTRL_GRAYED@(vm_fenetre,"BP_Clone",TRUE)


	/* zone de stockage */
	CASE XZAEC_FMC_ZoneStockage
		/*griser les icones de config de voies*/
		for vl_indice=0 to (ARRAY_SIZE@(tm_config)-1)
			DB_CTRL_GRAYED@(vm_fenetre, tm_config[vl_indice][0], TRUE)
		next vl_indice

		/* confirme par defaut*/
		vm_fiche.confirme=XZAEC_FMC_CONFIRMEE

		/* ne plus afficher le bouton veracite*/
		DB_CTRL_DISPLAY@(vm_fenetre,"BO_veracite",FALSE)
		DB_CTRL_DISPLAY@(vm_fenetre,"LI_veracite",FALSE)

		/* ne pas afficher le bouton fausse alerte*/
		DB_CTRL_DISPLAY@(vm_fenetre,"BA_FausseAlerte",FALSE)

		/* changer le libelle de la case a cocher representant de demarrage */
		DB_CTRL_TITLE@ (vm_fenetre, "BT_voiesret", "Stockage démarré")


	/* basculement pour travaux*/
	CASE XZAEC_FMC_BasculTravaux
		/*! le basculement n'est que sur section courante*/
		vm_fiche.point_car=0

		/*griser les icones de config de voies*/
		FOR vl_indice=0 to (ARRAY_SIZE@(tm_config)-1)
			DB_CTRL_GRAYED@(vm_fenetre, tm_config[vl_indice][0], TRUE)
		NEXT vl_indice

		/* confirme par defaut*/
		vm_fiche.confirme=XZAEC_FMC_CONFIRMEE

		/* ne plus afficher le bouton veracite*/
		DB_CTRL_DISPLAY@(vm_fenetre,"BO_veracite",FALSE)
		DB_CTRL_DISPLAY@(vm_fenetre,"LI_veracite",FALSE)

		/* ne pas afficher le bouton fausse alerte*/
		DB_CTRL_DISPLAY@(vm_fenetre,"BA_FausseAlerte",FALSE)


	/* bouchon*/
	CASE XZAEC_FMC_QueueBouchon
		DB_CTRL_TITLE@(vm_fenetre,"BP_localisation","Localisation Queue")


	/* fiche operateur*/
	CASE XZAEC_FMC_PosteOperateur
		vm_fiche_operateur=TRUE

		/* confirme par defaut*/
		vm_fiche.confirme=XZAEC_FMC_CONFIRMEE

		/* ne plus afficher le bouton veracite*/
		DB_CTRL_DISPLAY@(vm_fenetre,"BO_veracite",FALSE)
		DB_CTRL_DISPLAY@(vm_fenetre,"LI_veracite",FALSE)

		/* ne plus afficher horodates debut prevue*/
		ITMA_TMC_visible("Date debut prevue", FALSE)
		ITMA_TMC_visible("Date fin prevue", FALSE)

		/* griser les controles inutiles*/
		DB_CTRL_GRAYED@(vm_fenetre,"BP_localisation",TRUE)
		DB_CTRL_GRAYED@(vm_fenetre,"BP_cause",TRUE)
		DB_CTRL_GRAYED@(vm_fenetre,"BP_autres_causes",TRUE)
		DB_CTRL_DISPLAY@(vm_fenetre,"BP_transmettre",FALSE)
		DB_CTRL_DISPLAY@(vm_fenetre,"BP_transmettre_fmc",FALSE)
		DB_CTRL_DISPLAY@(vm_fenetre,"BP_Recup_Droits",FALSE)
		DB_CTRL_GRAYED@(vm_fenetre,"BP_achever",TRUE)
		DB_CTRL_GRAYED@(vm_fenetre,"BP_valider",TRUE)
		DB_CTRL_GRAYED@(vm_fenetre,"BP_Annuler_FMC",TRUE)
/*		DB_CTRL_GRAYED@(vm_fenetre,"BP_plan_actions",TRUE)*/
		IF vm_enrichir=0
		{
			DB_CTRL_GRAYED@(vm_fenetre,"BP_changer_poste",TRUE)
			DB_CTRL_GRAYED@(vm_fenetre,"BP_Recup_Droits",TRUE)
		}

		/* ne pas afficher le bouton fausse alerte*/
		DB_CTRL_DISPLAY@(vm_fenetre,"BA_FausseAlerte",FALSE)


	/* frontiere fermee*/
	CASE XZAEC_FMC_FrontiereFermee
		vm_fiche_frontiere=TRUE
		vm_local_ok=TRUE

		/*! la frontiere fermee n'est que sur section courante*/
		vm_fiche.point_car=0

		vm_fiche.pr=XDC_PR_FRONTIERE
		vm_fiche.autoroute=1
		vm_fiche.sens=null

		/* griser les controles inutiles*/
		DB_CTRL_GRAYED@(vm_fenetre,"BP_localisation",TRUE)

		/* ne pas afficher le bouton fausse alerte*/
		DB_CTRL_DISPLAY@(vm_fenetre,"BA_FausseAlerte",FALSE)


	/* Traitement chaussees, salage*/
	CASE XZAEC_FMC_TraitChaussees, XZAEC_FMC_Salage
		/* confirme par defaut*/
		vm_fiche.confirme=XZAEC_FMC_CONFIRMEE

		/* ne plus afficher le bouton veracite*/
		DB_CTRL_DISPLAY@(vm_fenetre,"BO_veracite",FALSE)
		DB_CTRL_DISPLAY@(vm_fenetre,"LI_veracite",FALSE)

		/* ne pas afficher le bouton fausse alerte*/
		DB_CTRL_DISPLAY@(vm_fenetre,"BA_FausseAlerte",FALSE)
ENDCASE


IF (vm_fiche_operateur <> TRUE)
{
	/* ne plus afficher changer de poste et recupere droits d'enrichir */
	DB_CTRL_DISPLAY@(vm_fenetre,"BP_changer_poste",FALSE)
	DB_CTRL_DISPLAY@(vm_fenetre,"BP_Recup_Droits",FALSE)

	/* afficher surcharge et consequence */
	DB_CTRL_DISPLAY@(vm_fenetre, "BP_surcharge", TRUE)
	DB_CTRL_DISPLAY@(vm_fenetre, "BP_Consequence", TRUE)

	IF vm_etat_fmc <> XDC_FMC_ETAT_TRAI OR (vm_enrichir = 0 AND vm_enrichir_queue = 0)
		DB_CTRL_GRAYED@(vm_fenetre, "BP_Consequence", TRUE)
}


/*si on est au CI ou sur PC simplifie*/
IF (SYSTEM_VAR@(vg_site)=XDC_CI) OR (SYSTEM_VAR@(vg_type_machine)=XDC_TYPEM_PCS) 
	DB_CTRL_DISPLAY@(vm_fenetre,"BP_surcharge",FALSE)

/*u PC simplifie*/
IF (SYSTEM_VAR@(vg_type_machine)=XDC_TYPEM_PCS) {
	DB_CTRL_DISPLAY@(vm_fenetre,"BP_changer_poste",FALSE)
	DB_CTRL_DISPLAY@(vm_fenetre,"BP_Recup_Droits",FALSE)
	DB_CTRL_DISPLAY@(vm_fenetre,"BP_autres_causes",FALSE)
	DB_CTRL_DISPLAY@(vm_fenetre,"BP_Faxer",FALSE)
	DB_CTRL_DISPLAY@(vm_fenetre,"BP_plan_actions",FALSE)
}


/* Affichage ou non de l'annulation de FMC*/
IF ((vm_mode_appel <> MODE_CREATION) and 
	((vm_fiche.type = XZAEC_FMC_AireFermee) or
	 (vm_fiche.type = XZAEC_FMC_Basculement) or
	 (vm_fiche.type = XZAEC_FMC_Delestage) or
	 (vm_fiche.type = XZAEC_FMC_Deviation) or
	 (vm_fiche.type = XZAEC_FMC_FermetureEch) or
	 (vm_fiche.type = XZAEC_FMC_EchDeconseille) or
	 (vm_fiche.type = XZAEC_FMC_Salage) or
	 (vm_fiche.type = XZAEC_FMC_TraitChaussees) or
	 (vm_fiche.type = XZAEC_FMC_Travaux) or
	 (vm_fiche.type = XZAEC_FMC_ZoneStockage) or
	 (vm_fiche.type = XZAEC_FMC_BasculTravaux) or
	 (vm_fiche.type = XZAEC_FMC_ConvoiMil) or
	 (vm_fiche.type = XZAEC_FMC_ConvoiExc)))
	{	
		IF ((COM04_Operateur_A_Le_Droit_De(XDC_FAM_EXPLOITATION_DISTRICT))
			OR (COM04_Operateur_A_Le_Droit_De(XDC_FAM_EXPLOITATION_PC2))
			OR (COM04_Operateur_A_Le_Droit_De(XDC_FAM_EXPLOITATION_CI)))
		{	
			IF (DB_CTRL_GET_DISPLAY@(vm_fenetre,"BP_annuler_FMC_prevue") = FALSE)
				DB_CTRL_DISPLAY@(vm_fenetre, "BP_Annuler_FMC", TRUE)
		}
		ELSE
			DB_CTRL_DISPLAY@(vm_fenetre, "BP_Annuler_FMC", FALSE)
	}
ELSE
	{
		DB_CTRL_DISPLAY@(vm_fenetre, "BP_Annuler_FMC", FALSE)
	}


/* suppression : si on est en creation sur un PC niveau 2 en mode degrade avec le CI alors afficher les widgets pour la FMC origine *
IF	(((SYSTEM_VAR@(vg_comm_CI) <> XDC_OK) AND 
	(SYSTEM_VAR@(vg_type_machine) = XDC_TYPE_PCNIVEAU2)) and (vm_mode_appel=MODE_CREATION)) OR
	(vm_fiche.degrade = XDC_OUI)
{
	* afficher les widgets FMC origine *
	DB_CTRL_DISPLAY@(vm_fenetre,"BS_Com_FMC_Init",TRUE)
	DB_CTRL_DISPLAY@(vm_fenetre,"LI_FMC_Initiale",TRUE)
	DB_CTRL_DISPLAY@(vm_fenetre,"TAB_FMC_Initiale",TRUE)
	vm_fiche.degrade = XDC_OUI
}
*/


/* Affichage ou non de l'envoi de fax */
IF (vm_mode_appel=MODE_CREATION)
{	
	DB_CTRL_GRAYED@(vm_fenetre, "BP_Faxer", TRUE)
}
ELSE IF (vm_etat_fmc=XDC_FMC_ETAT_CLOS)
	DB_CTRL_DISPLAY@(vm_fenetre, "BP_Faxer", FALSE)



/* Afficher la fenetre pour pouvoir definir les colonnes des tables */
DB_DISPLAY_ONLY@(vm_fenetre, TRUE)
DB_DISPLAY@(vm_fenetre)

/* initialiser la table des commentaires*/
tl_titres[0]="Numéro", 70
tl_titres[1]="Horodate", 140
tl_titres[2]="Périmé", 50
tl_titres[3]="Texte", 500
DB_TABLE_SET_DATA@(vm_fenetre,"TA_comment",NULL,tl_titres,NULL)

/* initialisation des colonnes de la liste des actions realisees*/
tl_titres[0]="Numéro", 55
tl_titres[1]="Site", 30
tl_titres[2]="Origine", 50
tl_titres[3]="Type", 120
tl_titres[4]="Horodate", 123
tl_titres[5]="Etat", 80
DB_TABLE_SET_DATA@(vm_fenetre,"TA_actions_realisees",NULL,tl_titres,NULL)

/* Initialisation des code matieres dangereuses */
tl_titres = null
tl_titres[0] = "Libelle",100
tl_titres[1] = "Explication",450
tl_data = null
DB_CTRL_RETURN_ON_CHANGE@(vm_fenetre,"TA_Code_matiere",TRUE)
for i=0 to ARRAY_SIZE@(tm_code_matiere_valide)-1
	tl_data[i][0] = tm_code_matiere_valide[i].libelle
	tl_data[i][1] = tm_code_matiere_valide[i].explication
next i
DB_TABLE_SET_DATA@(vm_fenetre,"TA_Code_matiere",tl_data,tl_titres,null)
DB_CTRL_TITLE@(vm_fenetre, "BS_matiere", "")


/* Initialisation du bouton origine */
DB_CTRL_STRINGS@(vm_fenetre, "BO_Origine", ARRAY_COLUMN@(tm_choix_origine,TDO_TEXTE_LIBELLE))
DB_CTRL_RETURN_ON_CHANGE@(vm_fenetre,"BO_Origine", TRUE)

/*Pre-renseigner l'origine ESCOTA dans les FMC prevision chantier DEM415*/
IF (vm_etat_fmc = XDC_FMC_ETAT_PREV) and
   ((vm_type_fmc = XZAEC_FMC_Travaux) or
    (vm_type_fmc = XZAEC_FMC_ZoneStockage) or
    (vm_type_fmc = XZAEC_FMC_BasculTravaux))
{
	vl_indice = COM45_IndexEnColonne (tm_choix_origine, TDO_TEXTE_LIBELLE, "ESCOTA")
} ELSE {
	vl_indice = COM45_IndexEnColonne (tm_choix_origine, TDO_TEXTE_LIBELLE, "")
}
DB_CTRL_VALUE@(vm_fenetre, "BO_Origine", vl_indice)


IF (vm_type_fmc = XZAEC_FMC_FrontiereFermee)
	/* memorise et affiche le libelle de la localisation de la queue*/
	ITMA_TMC_genere_local()


/*Prise en cpte des données du bouchon predefini DEM451*/
IF vm_appelant = "MTBP"
{
	/*generation de la localisation*/
	/*Initialiser_Point_Caract_Fiche(vm_fenetre, vm_fiche)*/
	ITMA_TMC_genere_local(1)
	ITMA_TMC_genere_local()

	/*verification de la localisation*/
	vl_loc.numauto=vm_fiche.autoroute
	vl_loc.pr=vm_fiche.pr
	vl_loc.sens_circulation=vm_fiche.sens

	vl_loc.type_point_caract=vm_fiche.point_car
	vl_loc.point_caract=vm_fiche.num_point_car
	vl_loc.position=vm_fiche.position
	vl_loc.position=null

	ITMA_TMC_verif_localisation(vl_loc,0,XDC_FAUX)
	ITMA_TMC_verif_localisation(vl_loc,1,XDC_FAUX)
	
	/*ffichage de la configuration des voies: coupure autoroute*/
 	tm_config[5][1] = va_1[11]
 	tm_config[6][1] = va_1[10]
 	tm_config[7][1] = va_1[9]
 	tm_config[8][1] = va_1[8]
 	tm_config[9][1] = va_1[7]

	ITMA_TMC_config_voies()
	
	/* veracite*/
	i = COM45_IndexEnColonne (tm_veracite, C_VAL_VERACITE, vm_fiche.confirme)
	DB_CTRL_VALUE@ (vm_fenetre, "BO_veracite", i)

	vl_horodate=COM09_Date_Courante(TRUE)

}


IF vm_appelant = "MTFP"
{
	/*generation de la localisation*/
	Initialiser_Point_Caract_Fiche(vm_fenetre, vm_fiche)
	ITMA_TMC_genere_local()

	/*verification de la localisation*/
	vl_loc.numauto=vm_fiche.autoroute
	vl_loc.pr=vm_fiche.pr
	vl_loc.sens_circulation=vm_fiche.sens
	vl_loc.type_point_caract=XDC_POINT_CARACT_ECHANGEUR
	vl_loc.point_caract=va_4[4]
	vl_loc.position=null
	ITMA_TMC_verif_localisation(vl_loc,0,XDC_FAUX)

	/*ffichage de la configuration des voies*/
	ITMA_TMC_config_voies()
}


/* si la fiche existe (appel depuis la liste à traiter, surcharge, synthese ou coup de poing) */
IF vm_mode_appel = MODE_MODIF
{
	MACRO_WINS_BUSY@()

	/* Construire l'intitule de la fiche et l'afficher*/
	vm_intitule = COM11_Libelle_FMC (vl_intitule_fmc)
	DB_CTRL_TITLE@(vm_fenetre, "LI_intitulé_fmc",vm_intitule)

	/*! si c'est un bouchon*/
	IF (vm_flag_bouchon=TRUE)
	{
		/*! lire les fiches tete et queue et mettre a jour les champs*/
		tl_retour=PEND_FOR_NEW_TASK@("ITMA_TMC_lire_bouchon",
								vm_fenetre,
								vm_horodate,
								tm_num_evt)
		IF (tl_retour[0]<>COM_OK) {
			RETURN (COM_NOK)
		}

		/*! recupere les donnees*/
		vm_fiche_tete=tl_retour[1]
		vm_fiche_queue=tl_retour[2]
		vm_fenetre=tl_retour[3]
		tm_comment=tl_retour[4]

		/*! determine les droits d'enrichir pour la tete et la queue en mode clos*/
		IF vm_etat_fmc = XDC_FMC_ETAT_CLOS AND vm_enrichir <> 0
		{
			IF (vm_fiche_tete.validation <> vm_horodate)
			{
				DB_CTRL_TITLE@(vm_fenetre,"BP_valider","Valider queue")
				DB_CTRL_GRAYED@(vm_fenetre,"BP_local_tetebou",TRUE)
				if vm_appelant <> "MTSE"
					vm_horodate = vm_fiche_queue.validation /* ???????????????????? */

			}		
			ELSE	IF (vm_fiche_queue.validation <> vm_horodate)
			{
				DB_CTRL_TITLE@(vm_fenetre,"BP_valider","Valider tête")
				DB_CTRL_GRAYED@(vm_fenetre,"BP_localisation",TRUE)
				if vm_appelant <> "MTSE"
					vm_horodate = vm_fiche_tete.validation
			}		
		}		

		tm_num_tete.numero=vm_fiche_tete.numero
		tm_num_tete.cle=vm_fiche_tete.cle
		tm_num_queue.numero=vm_fiche_queue.numero
		tm_num_queue.cle=vm_fiche_queue.cle

		/*! determine le num du point caracteristique en fonction du nom*/
		/*! bug applix: if faut extraire les 25 premiers caracteres*/
		vl_nom=TRIM@(SUBSTRING@(vm_fiche_queue.nom_point_car,1,25))
		vm_local.NomPtCar=vl_nom
		vm_local.PtCar=vm_fiche_queue.point_car

		/* Recherche du numero du point caracteristique */
		Initialiser_Point_Caract_Fiche(vm_fenetre, vm_fiche_queue)

		/*! meme operation pour la tete de bouchon*/
		/*! determine le num du point caracteristique en fonction du nom*/
		/*! bug applix: if faut extraire les 25 premiers caracteres*/
		vl_nom=TRIM@(SUBSTRING@(vm_fiche_tete.nom_point_car,1,25))
		vm_local_tete.NomPtCar=vl_nom
		vm_local_tete.PtCar=vm_fiche_tete.point_car

		/* Recherche du numero du point caracteristique */
		Initialiser_Point_Caract_Fiche(vm_fenetre, vm_fiche_tete)

		/*! on force la fiche generique vm_fiche a la queue de bouchon*/
		vm_fiche=vm_fiche_queue
		tm_num_evt=tm_num_queue

		/*! affecte la cause de la tete dans la fiche generique*/
		vm_fiche.numero_cause=vm_fiche_tete.numero_cause
		vm_fiche.cle_cause=vm_fiche_tete.cle_cause

		/* memorise et affiche le libelle de la localisation de la queue*/
		ITMA_TMC_genere_local()

		/* memorise et affiche le libelle de la localisation de la tete*/
		ITMA_TMC_genere_local(1)

		/* affiche la configuration des voies*/
		ITMA_TMC_config_voies()

		/* affiche la liste des actions realisees*/
		ITMA_TMC_actions_realisees(vm_horodate)

		/* affiche la liste des commentaires*/
		ITMA_TMC_formater_date_comment()
		ITMA_TMC_affiche_comment()

		/* Traitement FMC DATEX */
		/* Ajout SAGA : TMC_DATEX() est appele dans tous les cas pour gerer le droit de propriete */
		/*if (vm_fiche_queue.datex= XDC_VRAI)*/
			TMC_DATEX()
		
	}
	ELSE
	{
		/* lire le contenu de la fiche et mettre a jour les champs*/
		IF (TMC_Lire_Fiche()<>COM_OK) {
			RETURN (COM_NOK)
		}
	}

	/* Construire l'intitule complet de la fiche et l'afficher*/
	vm_intitule = TMC_libelle_fiche (vm_fiche)
	DB_CTRL_TITLE@(vm_fenetre, "LI_intitulé_fmc",vm_intitule)

	/* JPL 02/03/07 pour bug appel MSOP -> MTSE -> MTMC avec type NULL */
	vm_type_fmc = vm_fiche.type
}


/* si appel depuis MTSE*/
IF vm_appelant = "MTSE"
{
	/* Proposer l'annulation de la Fmc en prevision */
	/*  si la date de prevu est > maintenant + 10 h */
	if vm_etat_fmc = XDC_FMC_ETAT_PREV AND 
	    (vm_fiche.type = XZAEC_FMC_Travaux OR
		vm_fiche.type = XZAEC_FMC_ZoneStockage OR
		vm_fiche.type = XZAEC_FMC_BasculTravaux OR
		vm_fiche.type = XZAEC_FMC_ConvoiExc OR
		vm_fiche.type = XZAEC_FMC_ConvoiMil)
	{
		DB_CTRL_DISPLAY@(vm_fenetre,"BP_annuler_FMC_prevue",TRUE)

		/* recupere horodate courante*/
		vl_horodate=COM09_Date_Courante(TRUE)
		vl_date=COM18_Date_SGBD_Formatee(vm_fiche.debut_prevu)

		IF (COM17_Difference_Dates(vl_date, vl_horodate) > 10 * 60) 
			DB_CTRL_GRAYED@(vm_fenetre,"BP_annuler_FMC_prevue",FALSE)
		ELSE	DB_CTRL_GRAYED@(vm_fenetre,"BP_annuler_FMC_prevue",TRUE)
	}

	/* griser le bouton valider pour une fmc close et finie depuis plus de 31 jours */
	if vm_etat_fmc = XDC_FMC_ETAT_CLOS AND vm_enrichir = 0
	{
		DB_CTRL_GRAYED@(vm_fenetre,"BP_ajout_comment",TRUE)
	}
}
/*sinon si appel depuis mtll*/
ELSE IF vm_appelant = "MTLL"
{
	/* ne plus afficher l'origine*/
	DB_CTRL_DISPLAY@(vm_fenetre,"BS_origine",FALSE)
	DB_CTRL_DISPLAY@(vm_fenetre,"BO_Origine",FALSE)

	/* afficher l'alerte*/
	DB_CTRL_DISPLAY@(vm_fenetre,"ta_alerte",TRUE)
	DB_CTRL_DISPLAY@(vm_fenetre,"LIB_alerte",TRUE)
	DB_CTRL_DISPLAY@(vm_fenetre,"LI_alerte",TRUE)

	tl_infoAlerte = va_4

	/* affiche l'horodate de l'alerte*/
	COM24_Afficher_Horodate(tl_infoAlerte.date_debut,
						vm_fenetre,
						"BS_jour_debut_reel",
						"BS_mois_debut_reel",
						"BS_annee_debut_reel",
						"BS_heure_debut_reel",
						"BS_minute_debut_reel",
						"BS_seconde_debut_reel")

	/* localisation*/
	IF (tl_infoAlerte.autoroute<>null) AND
		(tl_infoAlerte.autoroute<>XDC_AUT_INCONNUE)
	{
		vm_fiche.autoroute=tl_infoAlerte.autoroute
		vm_fiche.pr=tl_infoAlerte.pr
		vm_fiche.sens=tl_infoAlerte.sens_circul
		IF ( tl_infoAlerte.num_type_equip = XDC_EQT_LIT)
		{
			vl_indice=ARRAY_INDEX@(ARRAY_COLUMN@(tm_lits_arret,0),
							tl_infoAlerte.num_equip)
			vm_fiche.point_car=XDC_POINT_CARACT_LIT_ARRET
			vm_fiche.nom_point_car=tm_lits_arret[vl_indice].nom
		}
		ELSE
		{	vm_fiche.point_car=null
			vm_fiche.nom_point_car=null
		}
		/* memorise et affiche le libelle de la localisation de la queue*/
		ITMA_TMC_genere_local()
		vl_loc.numauto=vm_fiche.autoroute
		vl_loc.pr=vm_fiche.pr
		vl_loc.sens_circulation=vm_fiche.sens
		IF ( tl_infoAlerte.num_type_equip = XDC_EQT_LIT)
		{
			vl_loc.type_point_caract=XDC_POINT_CARACT_LIT_ARRET
			vl_loc.point_caract=tl_infoAlerte.num_equip
		}
		ELSE
		{
			vl_loc.type_point_caract=null
			vl_loc.point_caract=null
		}
		vl_loc.position=null
		ITMA_TMC_verif_localisation(vl_loc,0,XDC_FAUX)
		vm_local_ok=TRUE
	}
	ELSE
	{
		vm_local_ok=FALSE
	}

	/* libelle de l'alerte*/
	vm_fiche.numero_alerte=tl_infoAlerte.numero
	vm_fiche.site_alerte=tl_infoAlerte.sit
	vm_fiche.horo_alerte=tl_infoAlerte.date_debut
	vm_fiche.type_alerte=tl_infoAlerte.nom_type

	if vm_fiche.datex = XDC_VRAI
	{
		DB_CTRL_TITLE@(vm_fenetre,"LIB_alerte",tl_infoAlerte.numero++" "++
								vm_fiche.origine++" "++
								tl_infoAlerte.date_debut)
	}
	ELSE
	{
		DB_CTRL_TITLE@(vm_fenetre,"LIB_alerte",tl_infoAlerte.numero++" "++
								tl_infoAlerte.nom_type++" "++
								tl_infoAlerte.date_debut)
	}
}



/* initialisation de la fmc a partir de la fmc cause */
IF (vm_appelant = "MTLL") OR (vm_appelant = "MTMT") OR (vm_appelant = "MTFP")
{
	/* initialisation de la fmc avec une cause et la localisation */
	/* si compatible avec le type de fmc a creer */
	IF va_1[1] <> NULL AND  va_1[2] <> NULL
	{
		tl_retour = ITMA_TMC_Preinitialiser_Fiche(vm_fenetre, va_1, vm_fiche)
		IF tl_retour <> NULL
		{
		   vm_fiche = tl_retour[0]

		   /* affichage de la veracite */
		   i = COM45_IndexEnColonne (tm_veracite, C_VAL_VERACITE, vm_fiche.confirme)
		   DB_CTRL_VALUE@ (vm_fenetre, "BO_veracite", i)

		   /* affichage de la localisation et de la configuration des voies */
		   /* si la fmc a une localisation */
		   IF vm_fiche.autoroute <> NULL
		   {		
			/* memorise et affiche le libelle de la localisation*/
			vm_local.NomPtCar = TRIM@(SUBSTRING@(vm_fiche.nom_point_car, 1,25))
			vm_local.PtCar=vm_fiche.point_car
			ITMA_TMC_genere_local()

			IF (vm_type_fmc=XZAEC_FMC_QueueBouchon)
			{
				vm_local_tete = vm_local
				vm_fiche_queue = tl_retour[0]
				vm_fiche_tete = tl_retour[1]
				if vm_fiche_queue.datex=XDC_VRAI OR vm_fiche_tete.datex=XDC_VRAI
				{
					vm_local_ok=FALSE
				}
				vm_fiche_queue.datex=XDC_FAUX
				vm_fiche_tete.datex=XDC_FAUX
				/* Recherche du numero du point caracteristique */
				Initialiser_Point_Caract_Fiche(vm_fenetre, vm_fiche_tete)
				ITMA_TMC_genere_local(1)
			}

			/*verification de la localisation*/
			vl_loc.type_point_caract=vm_fiche.point_car
			vl_loc.point_caract=vm_fiche.num_point_car
			vl_loc.position=vm_fiche.position
			IF vm_fiche.num_point_car = NULL
			{		
				/* sur la section courante */
				vl_loc.numauto=vm_fiche.autoroute
				vl_loc.pr=vm_fiche.pr
				vl_loc.sens_circulation=vm_fiche.sens
			}
			ELSE	
			{
				/* sur un point caracteristique */
				IF vl_loc.type_point_caract = XDC_POINT_CARACT_ECHANGEUR OR
				   vl_loc.type_point_caract = XDC_POINT_CARACT_PEAGE {
					vl_loc.sens_circulation=vm_fiche.sens
				}
				vl_loc.pr=XDC_PR_INCONNU
			}

			IF vm_fiche.datex=XDC_VRAI
			{
				vm_local_ok=FALSE
				vm_fiche.autoroute=XDC_AUT_INCONNUE
				vm_fiche.point_car=NULL
			}
			ELSE
			{
				IF (vm_mode_appel=MODE_CREATION AND vm_etat_fmc = XDC_FMC_ETAT_TRAI) {
					ITMA_TMC_verif_localisation(vl_loc,XDC_FAUX,XDC_VRAI)
				} ELSE {
					ITMA_TMC_verif_localisation(vl_loc,XDC_FAUX,XDC_FAUX)
				}
			}

			vm_fiche.datex=XDC_FAUX
		   }
		}
	}
}


/* Afficher l'origine FMC si elle existe (modif fiche existante, ou preinitialisee) */
IF (vm_fiche.origine <> "")
{
	/* Chercher si une origine predefinie est prefixe de l'origine FMC */
	vl_nom = UPPERCASE@ (vm_fiche.origine)
	vl_index = -1
	FOR i = 0  TO ARRAY_SIZE@ (tm_choix_origine) - 1
		vl_val = UPPERCASE@ (tm_choix_origine[i].libelle)
		IF (vl_val <> "")  AND  (SUBSTRING@ (vl_nom, 1, LEN@ (vl_val)) = vl_val)
		{
			vl_index = i
			BREAK i
		}
	NEXT i

	IF (vl_index >= 0)
	{
		DB_CTRL_VALUE@ (vm_fenetre, "BO_Origine", vl_index)
		DB_CTRL_VALUE@ (vm_fenetre, "BS_origine", TRIM@ (SUBSTRING@ (vm_fiche.origine, LEN@(vl_val) + 1)))
	} ELSE {
		DB_CTRL_VALUE@ (vm_fenetre, "BS_origine", vm_fiche.origine)
	}
}

if (vm_fiche.majeur = 1) 
{
  DB_CTRL_DISPLAY@(vm_fenetre,"BA_majeur",TRUE)
  DB_CTRL_VALUE@(vm_fenetre,"BA_majeur",TRUE)
}
 
  if (vm_fiche.confirme=XZAEC_FMC_CONFIRMEE) {
                        if (vm_fiche.type= XZAEC_FMC_Accident or
                                vm_fiche.type=XZAEC_FMC_Eboulement or
                                vm_fiche.type= XZAEC_FMC_Incendie or
                                vm_fiche.type=XZAEC_FMC_Inondation or
                                vm_fiche.type=XZAEC_FMC_VehFeu or
                                vm_fiche.type=XZAEC_FMC_Contresens)
  DB_CTRL_DISPLAY@(vm_fenetre,"BA_majeur",TRUE)
}

  if (vm_fiche.type=XZAEC_FMC_Contresens) {
  DB_CTRL_DISPLAY@(vm_fenetre,"BA_majeur",TRUE)
  DB_CTRL_VALUE@(vm_fenetre,"BA_majeur",TRUE)
}
if (tm_config[6][1]=XDC_VOIE_BLOQUEE or
	 tm_config[7][1]=XDC_VOIE_BLOQUEE or
	 tm_config[8][1]=XDC_VOIE_BLOQUEE or
	 tm_config[9][1]=XDC_VOIE_BLOQUEE ) {
if ( (tm_config[6][1]=XDC_VOIE_BLOQUEE or tm_config[6][1]=XDC_VOIE_INEXISTANTE) and
                    (tm_config[7][1]=XDC_VOIE_BLOQUEE or tm_config[7][1]=XDC_VOIE_INEXISTANTE) and
                    (tm_config[8][1]=XDC_VOIE_BLOQUEE or tm_config[8][1]= XDC_VOIE_INEXISTANTE) and
                    (tm_config[9][1]=XDC_VOIE_BLOQUEE or tm_config[9][1]=XDC_VOIE_INEXISTANTE) and
                    vm_fiche.confirme=XZAEC_FMC_CONFIRMEE)
    DB_CTRL_DISPLAY@(vm_fenetre, "BA_majeur",TRUE)
}

/* puis si aucune origine predefinie n'est choisie, proposer l'origine vide */
IF (DB_CTRL_GET_VALUE@ (vm_fenetre, "BO_Origine") < 0)
{
	vl_index = COM45_IndexEnColonne (tm_choix_origine, TDO_TEXTE_LIBELLE, "")
	DB_CTRL_VALUE@ (vm_fenetre, "BO_Origine", vl_index)
}


/* Afficher les champs specifiques au type de la FMC */ 
ITMA_TMC_Visu_Champs_Specifiques (vm_type_fmc, TRUE)

/* recuperer le numero d'appel iPhone pour rappel client */
IF (vm_type_fmc = XZAEC_FMC_VehArrete) OR (vm_type_fmc = XZAEC_FMC_VehPanne) OR (vm_type_fmc=XZAEC_FMC_VehFeu)
{
	IF (tl_infoAlerte.num_type = XZAAC_APPEL_IPHONE) 
	{
			IF (SUBSTRING@(tl_infoalerte.texte,1,3)="TEL")
				/* positionne le texte de l'alerte dans le champ complement client, sans les 4 premiers caractères (TEL=) */
				DB_CTRL_VALUE@ (vm_fenetre, "BS_complement_rappel", SUBSTRING@(tl_infoalerte.texte,6))
			ELSE
				/* positionne le texte de l'alerte dans le champ complement client, sans NON ABOUTIL TEL=*/
				 DB_CTRL_VALUE@ (vm_fenetre, "BS_complement_rappel",  
						SUBSTRING@(tl_infoalerte.texte,16))	
			/* positionne le bouton en 'numero client', donc affiche le BS_complement_rappel */
			DB_CTRL_VALUE@ (vm_fenetre, "BO_rappel", XZAEC_TYP_RAP_NUM_CLIENT)			
	}
}

/* Afficher les donnees specifiques de la FMC si elle existe */ 
IF (vm_mode_appel <> MODE_CREATION)
	ITMA_TMC_Lire_Donnees_Specifiques (vm_type_fmc)

if (vm_type_fmc = XZAEC_FMC_Regulation) {
	if (tl_infoAlerte.num_type = XZAAC_ALERTE_REGULATION) {
		TMC_reg_choix_zone(vm_fenetre,
					tl_infoAlerte.num_equip,
					tl_infoAlerte.texte)	
	}
}



/* Initialisation de la liste des types de Fmc proposes */
tm_ListeTypesFMC = TMC_AffichageListeTypesFMC (vm_fenetre, vm_type_fmc, vm_fiche.confirme,
                                                  tm_types_fmc, vm_etat_fmc, vm_mode_appel, vm_enrichir)

/* Affichage type precedent de la fmc */
IF (vm_mode_appel<> MODE_CREATION)
	TMC_AffichageTypePrecedentFMC (vm_fenetre, vm_type_fmc, vm_fiche.type_precedent,
	                                  tm_types_fmc, vm_mode_formation)



/* si la fiche n'est pas close*/
IF (vm_etat_fmc<>XDC_FMC_ETAT_CLOS) {
	/* on arme un timer de 5 s*/
	DB_TIMER@(vm_fenetre,C_FREQUENCE_TIMER)

	/* si la fmc existe deja prevenir la liste des fiches a traiter */
	/* de son ouverture                                             */
	/*!! les dates sont au format SGBD dans vm_fiche a ce moment !!! */
	IF (vm_mode_appel=MODE_MODIF) AND
		(SYSTEM_VAR@(vg_surcharge)<>TRUE){
		tl_data = {
			vm_fiche.numero,
			vm_fiche.cle,
			COM18_Date_SGBD_Formatee(vm_fiche.debut),
			COM18_Date_SGBD_Formatee(vm_fiche.debut_prevu),
			COM18_Date_SGBD_Formatee(vm_fiche.fin),
			COM18_Date_SGBD_Formatee(vm_fiche.fin_prevu)
		}
		DB_SEND_POKE@(COM_CANAL_MTLT_OUVERTURE_FMC, tl_data)
	}
}



/*
 * Traitements en cas d'erreur durant la visualisation :
 * informer l'operateur et selon la nature et la gravite
 * de l'erreur la tracer ou non, continuer ou abandonner
 * -----------------------------------------------------
 */

vl_installer_traitement_erreur = TRUE
WHILE vl_installer_traitement_erreur
	vl_installer_traitement_erreur = FALSE

	ON ERROR {
		ERROR_BOX@ (ERROR_NUMBER@(), ERROR_STRING@())
		vl_installer_traitement_erreur = TRUE
	}
WEND



/* Boucle principale sur evenements concernant la fenetre */
WHILE 1
	/* afficher la fenetre*/
	DB_DISPLAY_ONLY@(vm_fenetre,FALSE)
	DB_DISPLAY@(vm_fenetre)
	DB_DISPLAY_ONLY@(vm_fenetre,TRUE)

	/* attente d'un evenement*/
	vl_evt = DB_EXIT_CTRL@(vm_fenetre)

	/* si IHM verrouillee ne pas interpreter les actions opérateur */
    	IF (vl_evt<>"poke_") and (vl_evt<>"timer_") and SYSTEM_VAR@(vg_verrou)
		vl_evt = NULL


	/* suivant le type de l'action operateur*/
	CASE OF vl_evt

	/* appui sur le bouton surcharge*/
	CASE "BP_surcharge"
		vl_cr=PEND_FOR_NEW_TASK@("ITMA_TMC_demande_surcharge",
							vm_fiche.numero,
							vm_fiche.cle,
					DB_CTRL_GET_TITLE@(vm_fenetre,"LI_intitulé_fmc"),
							vm_enrichir)

		/* si la surcharge est acceptee*/
		IF (vl_cr=COM_OK)
		{
			RETURN (COM_OK)
		}



	/* Selectionner le type FMC */
	CASE "BO_TypeFMC"
		/* Modification du type de fmc avant validation */
		vl_index = DB_CTRL_GET_VALUE@ (vm_fenetre, "BO_TypeFMC")
		vl_nouveau_type_fmc = tm_ListeTypesFMC[vl_index].numero

		/* Si un nouveau type de fmc est choisi */
		IF vl_nouveau_type_fmc <> vm_type_fmc {
			vl_cr = COM_OK
			vl_index2 = COM45_IndexEnColonne (tm_ListeTypesFMC,
			                                     TDO_NUMERO_FMC, vm_type_fmc)

			/* sur retypage d'accident en evenement vehicule */
			IF (tm_ListeTypesFMC[vl_index2].classe = XZAEC_ClasseAccident) AND
			       (tm_ListeTypesFMC[vl_index].classe = XZAEC_ClasseVehicule)
			{
				/* si des véhicules ont été saisis récupérer le premier */
				tl_vehicules = { }
				IF (vm_mode_appel <> MODE_CREATION) {
					vl_cr = ITMA_TMC_Lire_Vehicules (tm_num_evt, vm_horodate, tl_data)
					IF vl_cr = COM_OK {
						tm_vehicules = { }
						tl_vehicules = tl_data
						IF ARRAY_SIZE@ (tl_vehicules) > 0 {
							vl_index = 0
							vl_val = tl_vehicules[vl_index].num_veh
							FOR i = 1 TO ARRAY_SIZE@ (tl_vehicules) - 1
								IF tl_vehicules[i].num_veh < vl_val {
									vl_index = i
									vl_val = tl_vehicules[i].num_veh
								}
							NEXT i
							tm_vehicules = SUBARRAY@(tl_vehicules,vl_index,1)
							ITMA_TMC_veh_affiche (vm_fenetre, tm_vehicules[0], null, vl_nouveau_type_fmc)
						}
					}
				}
				IF (vl_cr = COM_OK) AND (ARRAY_SIZE@ (tl_vehicules) = 0) {
					/* récupérer l'info Véhicule Escota */
					DB_CTRL_VALUE@ (vm_fenetre, "BT_escota",
					   DB_CTRL_GET_VALUE@(vm_fenetre,"BT_vehi_escota"))
				}
				IF (vl_cr = COM_OK)
					vm_fiche_vehicule = TRUE
			}
			ELSE IF (tm_ListeTypesFMC[vl_index2].classe=XZAEC_ClasseVehicule) AND
			           (tm_ListeTypesFMC[vl_index].classe = XZAEC_ClasseAccident)
			{
				/* sur retypage d'evenement vehicule en accident */
				/* si c'est un accident existant alors recharger sa fiche */
				IF (vm_mode_appel <> MODE_CREATION)  AND
				      (vm_fiche.type = XZAEC_FMC_Accident) {
					ITMA_TMC_Lire_Donnees_Specifiques (vm_fiche.type)
				}

				/* récupérer les infos Véhicule Escota, Matières dangereuses */
				DB_CTRL_VALUE@ (vm_fenetre, "BT_vehi_escota",
				                DB_CTRL_GET_VALUE@(vm_fenetre,"BT_escota"))
				DB_CTRL_VALUE@ (vm_fenetre, "BT_mat_dangereuse",
				                DB_CTRL_GET_TITLE@(vm_fenetre,"BS_matiere") <> NULL)
				vm_fiche_vehicule = FALSE
			}

			IF vl_cr = COM_OK {
				/* afficher les champs de saisie specifiques du nouveau type */
				ITMA_TMC_Visu_Champs_Specifiques (vm_type_fmc, FALSE)
				ITMA_TMC_Visu_Champs_Specifiques (vl_nouveau_type_fmc, TRUE)

				vm_type_fmc = vl_nouveau_type_fmc
		DB_CTRL_DISPLAY@(vm_fenetre,"BA_majeur",FALSE)
		if (vm_fiche.confirme=XZAEC_FMC_CONFIRMEE) {
			if (vm_type_fmc= XZAEC_FMC_Accident or
				vm_type_fmc=XZAEC_FMC_Eboulement or
				vm_type_fmc= XZAEC_FMC_Incendie or
				vm_type_fmc=XZAEC_FMC_Inondation or
				vm_type_fmc=XZAEC_FMC_VehFeu or
				vm_type_fmc=XZAEC_FMC_Contresens)
				DB_CTRL_DISPLAY@(vm_fenetre,"BA_majeur",TRUE)
		}
		else if (vm_type_fmc=XZAEC_FMC_Contresens)
		  DB_CTRL_DISPLAY@(vm_fenetre,"BA_majeur",TRUE)
			}
		}



	/* appui sur le bouton faxer */
	CASE "BP_Faxer"
		MACRO_WINS_BUSY@()
		ITMA_TMC_Envoi_Fax(vm_fenetre, vm_fiche, tm_donnees_specifiques)



	/* appui sur le bouton annuler fmc prevue par un conducteur d'operations */
	CASE "BP_annuler_FMC_prevue"
		IF (PEND_FOR_NEW_TASK@( "ITMA_TCF_Demande_Confirmation",
						"Voulez-vous annuler la FMC ?") = XDC_OK) {
			/*! je recupere son horodate de validation*/
			vl_horodate=vm_fiche.validation

			/* annulation des travaux ou des convois militaires ou except. */
			vl_cr=ITMA_TMC_annuler_fmc_prevue (vl_horodate, vm_fiche,vm_etat_fmc,tm_config)
			IF vl_cr=COM_OK {
				DB_SEND_POKE@(COM_CANAL_MTLT_TRV)
				RETURN (COM_SUPPRIME)
			}
		}



	/* appui sur le bouton Consequence */
	CASE "BP_Consequence"
		/* valider la FMC sans proposition de plan d'actions */
		MACRO_WINS_BUSY@()
		vl_cr = TMC_Valide_FMC (FALSE)

		/* si la FMC est validee, proposer le choix du type de consequence */
		IF (vl_cr = COM_OK) {
			tl_type_fmc = PEND_FOR_NEW_TASK@ ("ITMA_TMC_choix_type_fmc",
			                                     XDC_FMC_ETAT_TRAI, FALSE)

			/* et si un type est saisi, ouvrir une FMC de ce type */
			/* en creation avec la FMC actuelle pour cause et terminer */
			IF (tl_type_fmc <> NULL) {
				tl_type_fmc.cause = vm_fiche.numero;
				tl_type_fmc.cle_cause = vm_fiche.cle;
				tl_type_fmc.libelle_cause = TMC_libelle_fiche (vm_fiche)

				IF (tl_type_fmc.type = XZAEC_FMC_Delestage) OR
				   (tl_type_fmc.type = XZAEC_FMC_Deviation) {
					NEW_TASK@ ("ITMA_TFP_Fiche_Plan_Secours", "ITMA_TMC_Fiche_Main_Courante",
						      FALSE, tl_type_fmc)
				} ELSE {
					NEW_TASK@ ("ITMA_TMC_Fiche_Main_Courante", "ITMA_TMT",
						      tl_type_fmc, 1, XDC_FMC_ETAT_TRAI)
				}
				RETURN (COM_VALIDE)
			}
		}



	/* appui sur le bouton Clone FMC Travaux */
	CASE "BP_Clone"
		/* valider la FMC sans proposition de plan d'actions */
		MACRO_WINS_BUSY@()
		vl_cr = TMC_Valide_FMC (FALSE)

		/* si la FMC est validee, */
		IF (vl_cr = COM_OK) {
			/* tracer la fin de la consultation de cette fiche */
			ITMA_TMC_Tracer_Consultation (tm_num_evt.numero, tm_num_evt.cle)

			/* restituer les droits d'enrichir aux autres postes du site */
			TMC_Reserver_Fmc (tm_num_evt.numero, tm_num_evt.cle, XDC_NON)

			/* mettre a jour la liste des travaux en prévision */
			DB_SEND_POKE@ (COM_CANAL_MTLT_TRV)

			/* reinitialiser la partie commune de la fiche */
			vl_fiche = NULL
			vl_fiche.type		= XZAEC_FMC_Travaux
			vl_fiche.debut_prevu	= vm_fiche.debut_prevu
			vl_fiche.debut		= vm_fiche.debut
			vl_fiche.fin_prevu	= vm_fiche.fin_prevu
			vl_fiche.origine	= vm_fiche.origine
			vl_fiche.confirme	= vm_fiche.confirme
			vl_fiche.autoroute	= vm_fiche.autoroute
			vl_fiche.pr		= vm_fiche.pr
			vl_fiche.sens		= vm_fiche.sens
			vl_fiche.point_car	= vm_fiche.point_car
			vl_fiche.nom_point_car	= vm_fiche.nom_point_car
			vl_fiche.vr		= vm_fiche.vr
			vl_fiche.vm2		= vm_fiche.vm2
			vl_fiche.vm1		= vm_fiche.vm1
			vl_fiche.vl		= vm_fiche.vl
			vl_fiche.bau		= vm_fiche.bau
			vl_fiche.vr_i		= vm_fiche.vr_i
			vl_fiche.vm2_i		= vm_fiche.vm2_i
			vl_fiche.vm1_i		= vm_fiche.vm1_i
			vl_fiche.vl_i		= vm_fiche.vl_i
			vl_fiche.bau_i		= vm_fiche.bau_i
			vl_fiche.position	= vm_fiche.position
			vl_fiche.bau_etroite	= vm_fiche.bau_etroite
			vl_fiche.bau_i_etroite	= vm_fiche.bau_i_etroite
			vl_fiche.longueur	= vm_fiche.longueur
			vl_fiche.abrev_point_car= vm_fiche.abrev_point_car
			vl_fiche.num_point_car	= vm_fiche.num_point_car
			vm_fiche = vl_fiche

			tm_num_evt = NULL
			vm_intitule = ""
			DB_CTRL_TITLE@ (vm_fenetre, "LI_intitulé_fmc", NULL)

			COM24_Afficher_Horodate (NULL, vm_fenetre,
			                            "BS_jour_fin_reelle",
			                            "BS_mois_fin_reelle",
			                            "BS_annee_fin_reelle",
			                            "BS_heure_fin_reelle",
			                            "BS_minute_fin_reelle",
			                            "BS_seconde_fin_reelle")

			tm_actions = NULL
			DB_TABLE_CLEAR_DATA@ (vm_fenetre, "TA_actions_realisees", 0, -1)

			DB_CTRL_TITLE@ (vm_fenetre, "LI_fmc_cause", NULL)
			tm_liste_causes = NULL
			DB_TABLE_CLEAR_DATA@ (vm_fenetre, "TA_Evenements", 0, -1)

			tm_comment = NULL
			DB_TABLE_CLEAR_DATA@ (vm_fenetre, "TA_comment", 0, -1)

			/* les donnees specifiques aux travaux sont conservees */
			/* reinitialiser les horodates de neutralisation de voies */
			tl_neutral = DB_TABLE_GET_DATA@ (vm_fenetre, "TA_neutral_trv")
			FOR vl_indice = 0 TO ARRAY_SIZE@ (tl_neutral) - 1
				tl_neutral[vl_indice].horodate_debut = NULL
				tl_neutral[vl_indice].horodate_fin = NULL
			NEXT vl_indice
			DB_TABLE_CLEAR_DATA@ (vm_fenetre, "TA_neutral_trv", 0, -1)
			DB_TABLE_SET_DATA@ (vm_fenetre, "TA_neutral_trv", tl_neutral)

			/* remettre la configuration des voies a la normale */
			FOR vl_indice = 0 TO ARRAY_SIZE@ (tm_config) - 1
				IF (vl_indice = 0) OR (vl_indice = 5)
					tm_config[vl_indice][1] = XDC_VOIE_BAU_NORMALE
				ELSE
					tm_config[vl_indice][1] = XDC_VOIE_SENS_NORMAL
			NEXT vl_indice
			ITMA_TMC_config_voies ()

			vm_mode_appel = MODE_CREATION
		}



	/* appui sur le bouton recuperer droits d'enrichir */
	/*CASE "BP_Recup_Droits"
		/* demander si l'operateur veut transferer les droits sur les FMC *
		IF (PEND_FOR_NEW_TASK@( "ITMA_TCF_Demande_Confirmation", 
					"Voulez-vous récupérer les droits d'enrichir des FMC ?") = XDC_OK) {
			MACRO_WINS_BUSY@()
			ITMA_TTR_Transmettre_Droits_Au_Voisin(NULL, SYSTEM_VAR@(vg_numero_poste),TRUE)
		}*/



	/* appui sur le bouton changer de poste*/
	CASE "BP_changer_poste"
		/* je regarde s'il y a des actions operateur*/
		IF (ITMA_TMC_actions_operateur()=COM_OK)
		{
			/* j'acheve la fiche*/
			IF (ITMA_TMC_achever_fiche(vm_fiche,tm_num_evt)=COM_OK) {
				ITMA_TMT_quitter(1)
				RETURN (COM_OK)		' Par securite, car "quitter" doit tout terminer
			}
		}



	/* lancement du plan d'actions*/
	CASE "BP_plan_actions"
		/* Inhiber une nouvelle demande et demarrer un compte-a-rebours */
		DB_CTRL_GRAYED@(vm_fenetre,"BP_plan_actions",TRUE)
		vm_delai_PA = C_DUREE_INHIB_PA

		/* si je suis en formation et sur un bouchon*/
		IF (vm_mode_formation=TRUE) AND (vm_flag_bouchon=TRUE)
		{
			/*plan d'actions sans trafic FM*/
			NEW_TASK@("ITMA_TMC_lancer_plan_actions",vm_fiche_queue,2,
					vm_horodate)
		}
		/* si je suis en formation et pas sur un bouchon*/
		ELSE IF (vm_mode_formation=TRUE)
		{
			/*plan d'actions sans trafic FM*/
			NEW_TASK@("ITMA_TMC_lancer_plan_actions",vm_fiche,2,
					vm_horodate)
		}
		/* si je suis enrichisseur du bouchon*/
		ELSE IF ((vm_flag_bouchon=TRUE) AND (vm_enrichir_queue<>0))
		{
			/*plan d'actions avec trafic FM*/
			NEW_TASK@("ITMA_TMC_lancer_plan_actions",vm_fiche_queue,0,
					vm_horodate)
		}
		/* sinon si je ne suis pas enrichisseur du bouchon */
		ELSE IF ((vm_flag_bouchon=TRUE) AND (vm_enrichir_queue=0))
		{
			/*plan d'actions sans trafic FM*/
			NEW_TASK@("ITMA_TMC_lancer_plan_actions",vm_fiche_queue,1,
					vm_horodate)
		}
		/* sinon si je suis enrichisseur de la fiche*/
		ELSE IF ((vm_flag_bouchon=FALSE) AND (vm_enrichir<>0) )
		{
			/*plan d'actions avec trafic FM*/
			NEW_TASK@("ITMA_TMC_lancer_plan_actions",vm_fiche,0,
					vm_horodate)
		}
		/*sinon si je ne suis pas enrichisseur de la fiche */
		ELSE IF ((vm_flag_bouchon=FALSE) AND (vm_enrichir=0))
		{
			/*plan d'actions sans trafic FM*/
			NEW_TASK@("ITMA_TMC_lancer_plan_actions",vm_fiche,1,
					vm_horodate)
		}

		/* demande la disparition du Plan d'action precedemment lance (eventuellement) */
		DB_SEND_POKE@(COM_CANAL_MTPA, "FIN")



	CASE "BA_majeur"
		 vl_sel = DB_CTRL_GET_VALUE@(vm_fenetre,vl_evt)
		if (vl_sel = -1)
		 vm_fiche.majeur = 1
		else 
		vm_fiche.majeur=0

	/* selection d'une origine  dans la liste*/
	CASE "BO_Origine"
		/* concatener le libelle d'origine predefini et le texte libre */
		vl_sel = DB_CTRL_GET_VALUE@(vm_fenetre,vl_evt)
		vm_fiche.origine = tm_choix_origine[vl_sel].libelle ++ " " ++
		                      TRIM@ (DB_CTRL_GET_VALUE@(vm_fenetre, "BS_origine"))
		/* Tronquer si necessaire l'origine a sa longueur maximale */
		vm_fiche.origine = TRIM@ (SUBSTRING@ (vm_fiche.origine, 1, 25))



	/* selection d'une action dans la liste*/
	CASE "TA_actions_realisees"
		/* recupere les infos sur l'action*/
		vl_action_sel=DB_TABLE_GET_SELECTIONS@(vm_fenetre,vl_evt)
		vl_action_sel=vl_action_sel[0]

		if (vl_action_sel++""<>null) {
		/* prepare les parametres*/
		vl_ficheAction.numero_fiche=vm_fiche.numero
		vl_ficheAction.cle_fiche=vm_fiche.cle
		vl_ficheAction.numero_action=tm_actions[vl_action_sel].numero
		vl_ficheAction.cle_action=tm_actions[vl_action_sel].site
		vl_ficheAction.heure_action=tm_actions[vl_action_sel].heure
		vl_ficheAction.etat_action=tm_actions[vl_action_sel].etat
        vl_ficheAction.domaine_action = tm_actions[vl_action_sel].type

		vl_ficheAction.libelle_fiche=DB_CTRL_GET_TITLE@(vm_fenetre, "LI_intitulé_fmc")

		/* macro a appeler*/
		vl_nom_macro=""
		CASE OF tm_actions[vl_action_sel].type
			CASE XDC_APPEL_RADIO
			CASE XDC_ACT_APPEL
				vl_nom_macro="ITMA_TAT_Appel_Telephonique"

			CASE XDC_ACT_NAV
				vl_nom_macro="ITMA_TNA_consultation_NAV"

			CASE XDC_ACT_FAU
				vl_nom_macro="ITMA_TNA_consultation_NAV"

			CASE XDC_ACT_FAC
				vl_nom_macro="ITMA_TNA_consultation_NAV"

			CASE XDC_ACT_PAL
				vl_nom_macro="ITMA_TPP_consultation_PAL"

			CASE XDC_ACT_PMV
				vl_nom_macro="ITMA_TPM_etat_PMV"

			CASE XDC_ACT_PRV
				vl_nom_macro = "ITMA_TPRV_etat_PRV"

			CASE XDC_ACT_PMVA
				vl_nom_macro="ITMA_TPMVA_etat_PMVA"

			CASE XDC_ACT_SAGA
				vl_nom_macro="ITMA_TSAGA_etat_SAGA"

			CASE XDC_ACT_BAF
				vl_nom_macro="ITMA_TBAF_consultation_BAF"

			CASE XDC_ACT_BAD
				vl_nom_macro="ITMA_TBAD_consultation_BAD"

			CASE XDC_ACT_TUNNEL
				vl_nom_macro="ITMA_TTU_pilotage_tunnel"

			CASE XDC_ACT_GTC_SIG
				vl_nom_macro="ITMA_TTU_pilotage_tunnel"

			CASE XDC_ACT_GTC_SIG_ECH
				vl_nom_macro="ITMA_TEC_pilotage_echangeur"
				
			CASE XDC_ACT_GTC_ECL
				vl_nom_macro="ITMA_TTU_pilotage_tunnel"
				
			CASE XDC_ACT_GTC_VEN
				vl_nom_macro="ITMA_TTU_pilotage_tunnel"
				
			CASE XDC_ACT_GTC_ENR
				vl_nom_macro="ITMA_TTU_pilotage_tunnel"
				
			CASE XDC_ACT_GTC_EXP
				vl_nom_macro="ITMA_TTU_pilotage_tunnel"
				
			CASE XDC_ACT_GTC_INC
				vl_nom_macro="ITMA_TTU_pilotage_tunnel"
                
			CASE XDC_ACT_DEPANNEUR
				vl_nom_macro="ITMA_TID_Interv_Depanneur"

			CASE XDC_ACT_AFF_GARE
				vl_nom_macro="ITMA_TGA_AffichageGare"

			CASE XDC_ACT_PAT_SIS
				vl_nom_macro="ITMA_TIP_Interv_Patrouille_SIS"

			CASE XDC_ACT_INTERVENTION
				vl_nom_macro="ITMA_TIA_Interv_Autre"

			CASE XDC_ACT_PMV_REMORQUE
				vl_nom_macro="ITMA_TMO_pmvMobile"

			CASE XDC_ACT_PMV_FOURGON
				vl_nom_macro="ITMA_TFO_pmvSurFourgon"

			CASE XDC_ACT_TFM
				vl_nom_macro="ITMA_TFM_Fiche_Trafic_FM"

			CASE XDC_ACT_ECHANGEUR
				vl_nom_macro="ITMA_TEC_pilotage_echangeur"

			CASE XDC_ACT_FAX
				vl_nom_macro="ITMA_TFX_Envoi_Fax"

			CASE XDC_ACT_BIP
				vl_nom_macro="ITMA_TAT_Appel_Telephonique"

			CASE XDC_ACT_EXP
				vl_nom_macro="ITMA_TFE_Fiche_Export"

			CASE XDC_ACT_PMVDAT
				vl_nom_macro="ITMA_TPM_PMV_DATEX"

			CASE XDC_ACT_CCH
				vl_nom_macro="ITMA_TVH_Viabilite_Hivernale"

			CASE XDC_ACT_SMS
				vl_nom_macro="ITMA_TFX_Envoi_Fax"				

			CASE XDC_ACT_CFE
				vl_nom_macro="ITMA_TCFE_pilotage_CFE"

			CASE XDC_ACT_IMU
				vl_nom_macro="ITMA_TIMU_pilotage_IMU"

                       CASE XDC_ACT_PAU
				vl_nom_macro="ITMA_TRAU_pilotage_SONO"
	       ENDCASE

		/*execute cette macro*/
		/* Ajout SAGA */
		IF (tm_actions[vl_action_sel].type = XDC_ACT_EXPTFM  OR  tm_actions[vl_action_sel].type = XDC_ACT_DATEX )
			NOTHING
		ELSE IF (tm_actions[vl_action_sel].type=XDC_ACT_DEPANNEUR)
			PEND_FOR_NEW_TASK@(vl_nom_macro,"ITMA_TMC_Fiche_Main_courante",
					vl_ficheAction,vm_enrichir)
		ELSE IF (tm_actions[vl_action_sel].type=XDC_ACT_FAX)
			/* profil d'appel pouvant etre generalise a tous les cas suivants ... */
			NEW_TASK@(vl_nom_macro,"ITMA_TMC_Fiche_Main_courante",
					vl_ficheAction, vm_fiche)
		ELSE IF (tm_actions[vl_action_sel].type=XDC_ACT_SMS)
			NEW_TASK@(vl_nom_macro,"ITMA_TMC_Fiche_Main_courante",
					vl_ficheAction, vm_fiche)
		ELSE IF (tm_actions[vl_action_sel].type=XDC_ACT_TFM)
			NEW_TASK@(vl_nom_macro,"ITMA_TMC_Fiche_Main_courante",
					tm_num_evt, vl_ficheAction)
		ELSE IF (tm_actions[vl_action_sel].type=XDC_ACT_CCH)
		{
			IF (vm_site=XDC_CI)
				NEW_TASK@(vl_nom_macro,"ITMA_TMC_Fiche_Main_courante",
						vl_ficheAction)
		}
		ELSE NEW_TASK@(vl_nom_macro,"ITMA_TMC_Fiche_Main_courante",
					vl_ficheAction)
		}



	/* appui sur le bouton horodate debut reel*/
	/* appui sur le bouton horodate fin reel*/
	/* appui sur le bouton horodate debut prevu*/
	/* appui sur le bouton horodate debut prevu*/
	/* appui sur le bouton horodate debut travaux*/
	/* appui sur le bouton horodate fin travaux*/
	CASE "BP_horodebut_prevue"
	CASE "BP_horodebut_reelle"
	CASE "BP_horofin_prevue"
	CASE "BP_horofin_reelle"
	CASE "BP_horohelp_debuttrv"
	CASE "BP_horohelp_fintrv"
		ITMA_TMC_aide_horodate(vl_evt)



	/* selection d'un commentaire dans la liste*/
	CASE "TA_comment"
		/* recupere l'element selectionne*/
		vl_sel=DB_TABLE_GET_SELECTIONS@(vm_fenetre,vl_evt)
		vl_sel=vl_sel[0]

		/*! dans le cas de fmc close : possibilite d'ajouter des */
		/*! commentaires mais aps de perimer                         */
		IF (vm_etat_fmc=XDC_FMC_ETAT_CLOS)
			vl_mode = MODE_CLOS
		ELSE	vl_mode = vm_mode_appel

		/* lance la macro de visualisation*/
		tm_comment=PEND_FOR_NEW_TASK@("ITMA_TMC_expose_comment",
								tm_comment,
								vl_sel,
								tm_num_evt,
								vl_mode)

		/* met a jour la liste des commentaires affiches*/
		ITMA_TMC_affiche_comment()



	/* ajout d'un commentaire*/
	CASE "BP_ajout_comment"
		/* lance la macro d'ajout*/
		tm_comment=PEND_FOR_NEW_TASK@("ITMA_TMC_ajout_comment",tm_comment,
							tm_num_evt,vm_mode_appel)
		ITMA_TMC_affiche_comment()



	/* appui qur le bouton transmettre FMC*/
	CASE "BP_transmettre_fmc"
		/*! dans le cas du bouchon*/
		IF (vm_flag_bouchon=TRUE)
		{
			vl_cr=PEND_FOR_NEW_TASK@("ITMA_TTR_Transmission_Evt",
								TRUE,
								tm_num_queue,
								tm_num_tete)
		}
		ELSE
		{
			vl_cr=PEND_FOR_NEW_TASK@("ITMA_TTR_Transmission_Evt",
								TRUE,
								tm_num_evt)
		}



	/* appui sur le bouton transmettre le droit d'enrichir*/
	CASE "BP_transmettre"
		/*! dans le cas du bouchon il faut choisir entre la tete et la queue*/
		IF (vm_flag_bouchon=TRUE)
		{
			tl_num_evt=PEND_FOR_NEW_TASK@("ITMA_TMC_transmettre_bouchon",
								tm_num_queue,
								tm_num_tete)
		} ELSE {
			tl_num_evt = tm_num_evt
		}

		/*! verifie les droits d'enrichir pour le bouchon*/
		IF ( (vm_flag_bouchon=TRUE) AND
			( (tl_num_evt.numero=tm_num_tete.numero AND vm_enrichir_tete=0) OR
			  (tl_num_evt.numero=tm_num_queue.numero AND vm_enrichir_queue=0)
			) )
		{
			INFO_MESSAGE@("Vous n'avez pas le droit d'enrichir")
		} ELSE {
			/* lance la macro de transmission*/
			vl_cr=PEND_FOR_NEW_TASK@("ITMA_TTR_Transmission_Evt", FALSE, tl_num_evt)

			/* si on a bien transmis le droit d'enrichir*/
			IF (vl_cr=COM_VALIDE)
			{
				/* je le note*/
				IF (vm_flag_bouchon = TRUE) {
					IF (tl_num_evt.numero = tm_num_tete.numero) {
						vm_enrichir_tete = 0
					} ELSE {
						vm_enrichir_queue = 0
					}
				}
				vm_enrichir=0
				DB_CTRL_GRAYED@(vm_fenetre,"BP_valider",TRUE)
				DB_CTRL_GRAYED@(vm_fenetre,"BP_Annuler_FMC",TRUE)
				DB_CTRL_GRAYED@(vm_fenetre,"BP_transmettre",TRUE)
				DB_CTRL_DISPLAY@(vm_fenetre,"BP_libenrichir",FALSE)
			}
		}



	/* appui sur le bouton Achever*/
	CASE "BP_achever"
		MACRO_WINS_BUSY@()
		vl_cr = TMC_Acheve_FMC ()
		IF (vl_cr = COM_OK) {
			RETURN (COM_OK)
		}



	/* declenchement du timer*/
	CASE "timer_"
		/* recupere horodate courante*/
		vl_horodate=COM09_Date_Courante(TRUE)

		/* rafraichit liste des actions realisees*/
		IF NOT SYSTEM_VAR@ (vg_requete_en_cours)
			ITMA_TMC_actions_realisees(NULL)

		/* Mettre a jour l'autorisation de lancement d'un PA */
		vm_delai_PA = vm_delai_PA - C_FREQUENCE_TIMER
		IF vm_delai_PA = 0 {
			DB_SEND_POKE@(COM_CANAL_FIN_MSG)
			DB_CTRL_GRAYED@(vm_fenetre,"BP_plan_actions",FALSE)
		}

		/* rearme le timer*/
		DB_TIMER@(vm_fenetre,C_FREQUENCE_TIMER)



	/* appui sur le bouton Annuler_FMC */
	CASE "BP_Annuler_FMC"
		IF (PEND_FOR_NEW_TASK@( "ITMA_TCF_Demande_Confirmation",
						"Voulez-vous annuler la FMC ?") = XDC_OK) {
			MACRO_WINS_BUSY@()
			/* au CI, positionner la date de cloture pour purge*/
			if (vm_flag_bouchon=TRUE) {	
				vl_cr = ITMA_TMC_cloture_purge(vm_fiche_queue.numero, vm_fiche_queue.cle)
			}
			else
				vl_cr = ITMA_TMC_cloture_purge(vm_fiche.numero,vm_fiche.cle)
			IF vl_cr = COM_OK  {
				DB_SEND_POKE@(COM_CANAL_MTLT_TRV)
				RETURN (COM_SUPPRIME)
			}
		}


	/* appui sur le bouton valider*/
	CASE "BP_valider"
		MACRO_WINS_BUSY@()
		/* valider avec plan d'action meme si fausse alerte DEM419*/
		vl_cr=TMC_Valide_FMC(TRUE)



	/* appui sur le bouton code matiere*/
	CASE "BP_matiere"
		DB_CTRL_DISPLAY@ (vm_fenetre, "TA_Evenements", FALSE)
		DB_CTRL_DISPLAY@ (vm_fenetre, "TA_Code_matiere", TRUE)



	/* Choix d'un code matiere*/
	CASE "TA_Code_matiere"
		DB_CTRL_DISPLAY@ (vm_fenetre, "TA_Code_matiere", FALSE)
		vl_sel = DB_TABLE_GET_SELECTIONS@ (vm_fenetre, "TA_Code_matiere")
		vl_sel = vl_sel[0]
		DB_CTRL_TITLE@ (vm_fenetre, "BS_matiere",
		                   tm_code_matiere_valide[vl_sel].libelle)



	/* appui sur le bouton effacer cause*/
	CASE "BP_effacer_cause"
		vm_fiche.numero_cause=null
		vm_fiche.cle_cause=null
		DB_CTRL_TITLE@(vm_fenetre,"LI_fmc_cause",null)
		DB_CTRL_DISPLAY@(vm_fenetre,"TA_Evenements",FALSE)



	/* appui sur le bouton autre cause*/
	CASE "BP_autres_causes"
		/* efface la liste des causes "standard"*/
		DB_CTRL_DISPLAY@(vm_fenetre,"TA_Evenements",FALSE)

		/* affiche la liste des evenements*/
		tl_liste_causes=PEND_FOR_NEW_TASK@("ITMA_TLE_Liste_Evenements",
								"ITMA_TMC_Fiche_Main_courante")

		/* si un evt est selectionne*/
		IF (tl_liste_causes<>null)
		{
			/* je verifie que l'evt n'est pas ma fiche*/
			if ( (vm_fiche.numero=tl_liste_causes.info_evt.idfmc.numero) AND 
			     (vm_fiche.cle=tl_liste_causes.info_evt.idfmc.cle) ) {
			     INFO_MESSAGE@("La fiche ne peut pas etre liee avec elle meme")
			}
			else {
				/* recupere num et cle de l'evenement cause*/
				vm_fiche.numero_cause=tl_liste_causes.info_evt.idfmc.numero
				vm_fiche.cle_cause=tl_liste_causes.info_evt.idfmc.cle

				/* on affiche le libelle de l'evenement cause*/
				DB_CTRL_TITLE@(vm_fenetre,"LI_fmc_cause",
				               COM11_Libelle_FMC(tl_liste_causes.info_evt))
			}
		}



	/* appui sur le bouton cause*/
	CASE "BP_cause"
		MACRO_WINS_BUSY@()

		/* on lance la tache de recherche d'evt cause*/
		tl_data=PEND_FOR_NEW_TASK@("ITMA_COM_Liste_Causes",
						"ITMA_TMC_Fiche_Main_Courante")

		DB_CTRL_DISPLAY@(vm_fenetre,"TA_Code_matiere",FALSE)

		tm_liste_causes=tl_data[0]
		/* affiche la liste des evts a traiter*/
		DB_CTRL_DISPLAY@(vm_fenetre,"TA_Evenements",TRUE)
		DB_TABLE_SET_MARKER_WIDTH@(vm_fenetre, "TA_Evenements", 25)
		DB_CTRL_RETURN_ON_CHANGE@(vm_fenetre,"TA_Evenements",TRUE)
		tl_titres[0] = COM_CAUSE_NUMERO,COM_CAUSE_LONG_NUMERO
		tl_titres[1] = COM_CAUSE_CLE,COM_CAUSE_LONG_CLE
		tl_titres[2] = COM_CAUSE_TYPE,COM_CAUSE_LONG_TYPE
		tl_titres[3] = COM_CAUSE_DATE,COM_CAUSE_LONG_DATE
		tl_titres[4] = COM_CAUSE_LOCALISATION,COM_CAUSE_LONG_LOCALISATION
		DB_TABLE_SET_DATA@(vm_fenetre,"TA_Evenements",tl_data[1],tl_titres)
		DB_TABLE_MARKER_PIXMAPS@(vm_fenetre, "TA_Evenements", 0, tl_data[2])



	/* selection d'un element dans la liste des fiches a traiter*/
	CASE "TA_Evenements"
		MACRO_WINS_BUSY@()
		vl_cr = COM_OK
		tl_retour=ITMA_COM_Validite_Cause("ITMA_TMC",vm_fenetre,tm_liste_causes)

		/* on verifie que la fiche choisie n'est pas ma fiche*/
		if (tl_retour[0][0]=vm_fiche.numero) AND (tl_retour[0][1]=vm_fiche.cle) {
			INFO_MESSAGE@("On ne peut pas lier une fiche avec elle meme")
			vl_cr = COM_NOK
		}
		else if (vm_mode_appel <> MODE_CREATION) {
			/* on verifie que la fiche choisie ne soit pas une consequence de ma fiche DEM497*/
			IF (ITMA_TMC_Est_Consequence(vm_fiche.numero,vm_fiche.cle,tl_retour[0][0],tl_retour[0][1])=XDC_VRAI) {
				INFO_MESSAGE@("On ne peut pas lier une fiche avec une consequence d'elle meme")
				vl_cr = COM_NOK
			}
		}
		IF (vl_cr = COM_OK) {
			/* recupere num et cle de l'evenement cause*/
			vm_fiche.numero_cause=tl_retour[0][0]
			vm_fiche.cle_cause=tl_retour[0][1]

			/* on affiche le libelle de l'evenement cause*/
			DB_CTRL_TITLE@(vm_fenetre,"LI_fmc_cause",tl_retour[1])
		}



	/* appui sur le bouton fausse alerte*/
	CASE "BA_FausseAlerte"
		IF DB_CTRL_GET_VALUE@(vm_fenetre,vl_evt) = FALSE	
		{
			DB_CTRL_GRAYED@(vm_fenetre,"BO_veracite",FALSE)
			vm_fiche.fausse_alerte = XDC_FAUX
		}
		ELSE	{
			DB_CTRL_GRAYED@(vm_fenetre,"BO_veracite",TRUE)
			vm_fiche.fausse_alerte = XDC_VRAI
		}
		IF vm_flag_bouchon=TRUE
		{
			vm_fiche_queue.fausse_alerte = vm_fiche.fausse_alerte
			vm_fiche_tete.fausse_alerte = vm_fiche.fausse_alerte
		}



	/* appui sur le bouton veracite*/
	CASE "BO_veracite"
		/* memorise la valeur*/
		vm_fiche.confirme = tm_veracite[DB_CTRL_GET_VALUE@(vm_fenetre,vl_evt)][C_VAL_VERACITE]

		if (vm_fiche.confirme=XZAEC_FMC_CONFIRMEE) {
			if (vm_fiche.type= XZAEC_FMC_Accident or
				vm_fiche.type=XZAEC_FMC_Eboulement or
				vm_fiche.type= XZAEC_FMC_Incendie or
				vm_fiche.type=XZAEC_FMC_Inondation or
				vm_fiche.type=XZAEC_FMC_VehFeu or
				vm_fiche.type=XZAEC_FMC_Contresens)
				DB_CTRL_DISPLAY@(vm_fenetre,"BA_majeur",TRUE)
		}
		else if (vm_fiche.type <> XZAEC_FMC_Contresens) {
		  vm_fiche.majeur = FALSE
		  DB_CTRL_DISPLAY@(vm_fenetre,"BA_majeur",FALSE)
		}

	/* appui sur le bouton Camera */
	CASE "BP_Camera"
			DB_SEND_POKE@ (COM_CANAL_MTCA_RAPIDE,
			{ "ITMA_TMC", vm_fiche.autoroute, vm_fiche.pr, vm_fiche.pr, vm_fiche.sens })

	 /* appui sur le bouton localisation*/
	CASE "BP_localisation"
		vl_loc = PEND_FOR_NEW_TASK@ ("ITMA_TMC_Localisation", vm_fiche)
		IF NOT IS_NULL@ (vl_loc) {
			vl_cr = ITMA_TMC_valide_localisation (vl_loc, 0)

			/* pour un bouchon si la localisation est valide */
			IF (vl_cr = COM_OK) AND (vm_flag_bouchon) {
				/* si la localisation de tete n'est pas */
				/* renseignee, lui donner la meme valeur */
				IF (vm_local_tete_ok = FALSE) AND
				      (vm_fiche_tete.autoroute = XDC_AUT_INCONNUE) {
					vm_fiche_tete.autoroute = vm_fiche.autoroute
					vm_fiche_tete.pr = vm_fiche.pr
					vm_fiche_tete.sens = vm_fiche.sens
					vm_fiche_tete.point_car = vm_fiche.point_car
					vm_fiche_tete.num_point_car = vm_fiche.num_point_car
					vm_fiche_tete.nom_point_car = vm_fiche.nom_point_car
				}
			}
			else if (vl_cr = COM_OK) AND (vm_fiche.type=XZAEC_FMC_Travaux OR vm_fiche.type=XZAEC_FMC_Basculement OR vm_fiche.type=XZAEC_FMC_BasculTravaux) {
			TMC_calcule_vitesse(
				vm_fenetre,
				vm_fiche.autoroute,
                vm_fiche.pr,
				vm_fiche.sens,
				tm_config,
				vm_fiche.type,
				DB_CTRL_GET_VALUE@(vm_fenetre,"BS_pr_bascul"))
				
			}
		}

	/* appui sur le bouton localisation de la tete de bouchon*/
	CASE "BP_local_tetebou"
		vl_loc = PEND_FOR_NEW_TASK@ ("ITMA_TMC_Localisation", vm_fiche_tete)
		IF NOT IS_NULL@ (vl_loc) {
			ITMA_TMC_valide_localisation (vl_loc, 1)
		}



	/* appui bau sens inverse*/
	CASE "BP_bau_i"
		/* je recupere l'ancienne valeur*/
		vl_indice=ARRAY_INDEX@(ARRAY_COLUMN@(tm_config,0),vl_evt)

		/* recuperation de l'icone suivante*/
		vl_ordre_icone_voie = tm_icones_voies[vm_type_fmc][TMC_VOIE_BAU_INV]
		vl_index=ARRAY_INDEX@(vl_ordre_icone_voie,tm_config[vl_indice][1])

		/* recuperation de l'icone suivante*/
		IF vl_index < ARRAY_SIZE@(vl_ordre_icone_voie) - 1
			vl_etat_voie=vl_ordre_icone_voie[vl_index+1]
		ELSE	vl_etat_voie=vl_ordre_icone_voie[0]

		/* je memorise la nouvele valeur*/
		tm_config[vl_indice][1]=vl_etat_voie

		/* si la BAU est etroite alors prendre l'icone de BAU etroite */
		IF vm_fiche.bau_i_etroite = XDC_VRAI
			 vl_etat_voie = vl_etat_voie + XDC_VOIE_BAU_ETROITE

		/* affichage de l'icone*/
		DB_CTRL_TITLE@(vm_fenetre,vl_evt,tm_pix_bau_inv[vl_etat_voie])

		if (vm_fiche.type=XZAEC_FMC_Basculement) {
			TMC_calcule_vitesse( 
					vm_fenetre,
					vm_fiche.autoroute,
					vm_fiche.pr,
					vm_fiche.sens,
					tm_config,
					vm_fiche.type,
					DB_CTRL_GET_VALUE@(vm_fenetre,"BS_pr_bascul"))
		}

	/* appui bau sens normal*/
	CASE "BP_bau"
		/* je recupere l'ancienne valeur*/
		vl_indice=ARRAY_INDEX@(ARRAY_COLUMN@(tm_config,0),vl_evt)

		/* recuperation de l'icone suivante*/
		vl_ordre_icone_voie = tm_icones_voies[vm_type_fmc][TMC_VOIE_BAU]
		vl_index=ARRAY_INDEX@(vl_ordre_icone_voie,tm_config[vl_indice][1])

		/* recuperation de l'icone suivante*/
		IF vl_index < ARRAY_SIZE@(vl_ordre_icone_voie) - 1
			vl_etat_voie=vl_ordre_icone_voie[vl_index+1]
		ELSE	vl_etat_voie=vl_ordre_icone_voie[0]

		/* memorisation de la valeur*/
		tm_config[vl_indice][1]=vl_etat_voie

		/* si la BAU est etroite alors prendre l'icone de BAU etroite */
		IF vm_fiche.bau_etroite = XDC_VRAI
			 vl_etat_voie = vl_etat_voie + XDC_VOIE_BAU_ETROITE

		/* affichage de l'icone*/
		DB_CTRL_TITLE@(vm_fenetre,vl_evt,tm_pix_bau[vl_etat_voie])

		if (vm_fiche.type=XZAEC_FMC_Basculement) {
			TMC_calcule_vitesse( 
					vm_fenetre,
					vm_fiche.autoroute,
					vm_fiche.pr,
					vm_fiche.sens,
					tm_config,
					vm_fiche.type)
				}

	/* appui sur une des icones de configuration des voies sens inverse*/
	CASE "BP_vl_i"
	CASE "BP_vm1_i"
	CASE "BP_vm2_i"
	CASE "BP_vr_i"
		/* je recupere l'ancienne valeur*/
		vl_indice=ARRAY_INDEX@(ARRAY_COLUMN@(tm_config,0),vl_evt)

		/* recherche la position actuelle dans la liste des icones ordonnees */
		vl_ordre_icone_voie = tm_icones_voies[vm_type_fmc][TMC_VOIE_CIRC_INV]
		vl_index=ARRAY_INDEX@(vl_ordre_icone_voie,tm_config[vl_indice][1])

		/* recuperation de l'icone suivante*/
		IF vl_index < ARRAY_SIZE@(vl_ordre_icone_voie) - 1
			vl_etat_voie=vl_ordre_icone_voie[vl_index+1]
		ELSE	vl_etat_voie=vl_ordre_icone_voie[0]

		/* affichage de l'icone*/
		DB_CTRL_TITLE@(vm_fenetre,vl_evt,tm_pix_fav_inv[vl_etat_voie])

		/* memorisation de la valeur*/
		tm_config[vl_indice][1]=vl_etat_voie

		if (vm_fiche.type=XZAEC_FMC_Basculement) {
			TMC_calcule_vitesse( 
					vm_fenetre,
					vm_fiche.autoroute,
					vm_fiche.pr,
					vm_fiche.sens,
					tm_config,
					vm_fiche.type)
			}

	/* appui sur une des icones de configuration des voies sens normal*/
	CASE "BP_vl"
	CASE "BP_vm1"
	CASE "BP_vm2"
	CASE "BP_vr"
		/* je recupere l'ancienne valeur*/
		vl_indice=ARRAY_INDEX@(ARRAY_COLUMN@(tm_config,0),vl_evt)

		/* recherche la position actuelle dans la liste des icones ordonnees */
		vl_ordre_icone_voie = tm_icones_voies[vm_type_fmc][TMC_VOIE_CIRCULEE]
		vl_index=ARRAY_INDEX@(vl_ordre_icone_voie,tm_config[vl_indice][1])

		/* recuperation de l'icone suivante*/
		IF vl_index < ARRAY_SIZE@(vl_ordre_icone_voie) - 1
			vl_etat_voie=vl_ordre_icone_voie[vl_index+1]
		ELSE	vl_etat_voie=vl_ordre_icone_voie[0]

		/* affichage de l'icone*/
		DB_CTRL_TITLE@(vm_fenetre,vl_evt,tm_pix_fav[vl_etat_voie])

		/* memorisation de la valeur*/
		tm_config[vl_indice][1]=vl_etat_voie

		if (tm_config[6][1]=XDC_VOIE_BLOQUEE or
			tm_config[7][1]=XDC_VOIE_BLOQUEE or
			tm_config[8][1]=XDC_VOIE_BLOQUEE or
			tm_config[9][1]=XDC_VOIE_BLOQUEE) {
		if ( (tm_config[6][1]=XDC_VOIE_BLOQUEE or tm_config[6][1]=XDC_VOIE_INEXISTANTE) and
		     (tm_config[7][1]=XDC_VOIE_BLOQUEE or tm_config[7][1]=XDC_VOIE_INEXISTANTE) and
		     (tm_config[8][1]=XDC_VOIE_BLOQUEE or tm_config[8][1]=XDC_VOIE_INEXISTANTE) and 
		     (tm_config[9][1]=XDC_VOIE_BLOQUEE or tm_config[9][1]=XDC_VOIE_INEXISTANTE) and
		    vm_fiche.confirme=XZAEC_FMC_CONFIRMEE)
		    DB_CTRL_DISPLAY@(vm_fenetre, "BA_majeur",TRUE)
		else if (vm_fiche.confirme <> XZAEC_FMC_Contresens) {
			DB_CTRL_DISPLAY@(vm_fenetre, "BA_majeur",FALSE)
			vm_fiche.majeur = FALSE
		}
		}
		if (vm_fiche.confirme=XZAEC_FMC_CONFIRMEE) {
			if (vm_fiche.type= XZAEC_FMC_Accident or
				vm_fiche.type=XZAEC_FMC_Eboulement or
				vm_fiche.type= XZAEC_FMC_Incendie or
				vm_fiche.type=XZAEC_FMC_Inondation or
				vm_fiche.type=XZAEC_FMC_VehFeu or
				vm_fiche.type=XZAEC_FMC_Contresens)
				DB_CTRL_DISPLAY@(vm_fenetre,"BA_majeur",TRUE)
		}
		if (vm_fiche.type=XZAEC_FMC_Basculement) {
			TMC_calcule_vitesse(
					vm_fenetre,
					vm_fiche.autoroute,
					vm_fiche.pr,
					vm_fiche.sens,
					tm_config,
					vm_fiche.type,
					DB_CTRL_GET_VALUE@(vm_fenetre,"BS_pr_bascul"))
               }

	/* demande de la configuration terrain*/
	CASE "BP_config_terrain"
		ITMA_TMC_config_voies_et_terrain ()



	/*choix du bouton quitter*/
	CASE "BP_quitter"
		IF (vm_mode_appel=MODE_CREATION) {
			RETURN (COM_QUITTE)
		} ELSE {
			RETURN (COM_OK)
		}



	/*choix du bouton coupure_autoroute: bloquer toutes les voies sens normal*/
	CASE "BP_coupure_aut"
		FOR vl_indice=5 TO 9
			tm_config[vl_indice][1]=XDC_VOIE_BLOQUEE
		NEXT vl_indice
		ITMA_TMC_config_voies()



	/* choix du bouton Ecoulement */
	CASE "BP_ecoulement"
		ITMA_TMC_ecoulement (vm_fiche.autoroute,vm_fiche.pr,vm_fiche.sens,vm_fiche.point_car)



	/* si c'est un poke*/
	CASE "poke_"
		CASE OF DB_GET_POKE@(vm_fenetre)
			CASE COM_CANAL_TEST
				vl_message = DB_GET_POKE_DATA@(vm_fenetre)
				IF UPPERCASE@ (vl_message[0]) = "MTMC" {
					vl_val = UPPERCASE@ (vl_message[1])
					IF vl_val = "DUMP" {
						dumpfmc()
					}
				}

			/* si poke de fin envoye par le menu*/
			CASE COM_CANAL_MTMC
				SET_SYSTEM_VAR@(vg_verrou,FALSE)
				IF (vm_mode_appel=MODE_CREATION) {
					RETURN (COM_QUITTE)
				} ELSE {
					RETURN (COM_OK)
				}

			/* si c'est le poke du plan d'actions*/
			CASE COM_CANAL_MTMC_PA
				/* je recupere les args et les transforme en un tableau*/
				vl_message = DB_GET_POKE_DATA@(vm_fenetre)
				tl_pokeData=ARRAY_FROM_STRING@(vl_message[0], MTAR_CAR_SEPAR)
				tl_numFiche[0]=tl_pokeData[0]
				tl_numFiche[1]=tl_pokeData[1]

				DB_SEND_POKE@(COM_CANAL_FIN_MSG)
				DB_CTRL_GRAYED@(vm_fenetre,"BP_plan_actions",FALSE)

				IF (tl_numFiche[0] <> tm_num_evt.numero) OR (tl_numFiche[1] <> tm_num_evt.cle) {
					vl_message = "ERREUR : plan d'action du SAD sur une autre FMC"
					vl_val = FORMAT@ (" (%s/%s) en saisie fiche %s/%s",
					                     tl_numFiche[0], tl_numFiche[1],
					                     tm_num_evt.numero, tm_num_evt.cle)
					COM01_Trace (COM_WARNING, vl_message ++ vl_val)
					BEEP@ ()
					DB_SEND_POKE@ (COM_CANAL_MTAV, FORMAT@ ("%s : %s", COM09_Date_Courante(TRUE), vl_message))
				} ELSE {
					/* si je suis en mode formation*/
					IF (vm_mode_formation=TRUE) {
						/* je lance la tache d'affichage du plan d'actions*/
						/* en lui precisant ce mode*/
						NEW_TASK@("ITMA_TPA_Plan_Actions",
								"ITMA_TSC_etape_scenario",
								tl_pokeData[2],vm_fiche,vm_intitule)
					} ELSE {
						/* je lance la tache d'affichage du plan d'actions*/
						/*en mode standard*/
						NEW_TASK@("ITMA_TPA_Plan_Actions",
							"ITMA_TMC_fiche_main_courante",
							tl_pokeData[2],vm_fiche,vm_intitule, 
							tl_pokeData[4])
					}
				}

			/* si c'est le poke du message trafic FM*/
			CASE COM_CANAL_MTMC_TFM
				/* recupere les args et les transforme en tableau*/
				vl_message = DB_GET_POKE_DATA@(vm_fenetre)
				tl_pokeData=ARRAY_FROM_STRING@(vl_message[0], MTAR_CAR_SEPAR)
				tl_numFiche[0]=tl_pokeData[0]
				tl_numFiche[1]=tl_pokeData[1]

				DB_SEND_POKE@(COM_CANAL_FIN_MSG)
				DB_CTRL_GRAYED@(vm_fenetre,"BP_plan_actions",FALSE)

				IF (tl_numFiche[0] <> tm_num_evt.numero) OR (tl_numFiche[1] <> tm_num_evt.cle) {
					vl_message = "Message RVA du SAD pour une autre FMC"
					vl_val = FORMAT@ (" (%s/%s) en saisie fiche %s/%s",
					                     tl_numFiche[0], tl_numFiche[1],
					                     tm_num_evt.numero, tm_num_evt.cle)
					COM01_Trace (COM_WARNING, vl_message ++ vl_val)
					BEEP@ ()
					DB_SEND_POKE@ (COM_CANAL_MTAV, FORMAT@ ("%s : %s", COM09_Date_Courante(TRUE), vl_message))
				} ELSE {
					/*si pas de message TFM*/
					IF (tl_pokeData[2]<>1) {
						INFO_MESSAGE@("Pas de message RVA pour cet événement")
					} ELSE {
						NEW_TASK@("ITMA_TFM_Fiche_Trafic_FM",
							"DPAC_TFM_",tl_numFiche,
							 vm_enrichir, tl_pokeData[6], tl_pokeData[4])
					}
				}

				/* je deverrouille l'IHM et je sors de la boucle d'attente*/
				SET_SYSTEM_VAR@(vg_verrou, FALSE)

			/* si c'est le poke indiquant la fin de mise a jour des vehicules */
			CASE COM_CANAL_VEH_FINI
				/* Mise a jour des champs d'informations si FMC vehicule*/
				vl_message = DB_GET_POKE_DATA@(vm_fenetre)
				IF ((vl_message[0]=vm_fiche.numero) and (vl_message[1]=vm_fiche.cle))
				{
					IF (vm_type_fmc = XZAEC_FMC_Accident) OR (vm_fiche_vehicule = TRUE) {
						ITMA_TMC_Lire_Donnees_Specifiques (vm_type_fmc)
					}
					IF (not (IS_NULL@(vl_message[2])))
						vm_nb_vehicules = vl_message[2]
				}
		ENDCASE

	/*********************************************************************/
	/*********************************************************************/
	/*********************************************************************/
	/*********************************************************************/
	/* evenements relatifs au tampon accident					 */

	CASE "BT_mat_dangereuse"
		if (DB_CTRL_GET_VALUE@(vm_fenetre,"BT_mat_dangereuse")=TRUE)
			  DB_CTRL_DISPLAY@(vm_fenetre,"BP_ecoulement",TRUE)
		  else
	    DB_CTRL_DISPLAY@(vm_fenetre,"BP_ecoulement",FALSE)

	/* appui sur le bouton de description des vehicules*/
	CASE "BP_desc_vehicules"
		/* si la fiche n'a pas été validée alors le demander */
		IF IS_NULL@ (vm_fiche.numero) {
			INFO_MESSAGE@ ("Valider d'abord la FMC pour générer son numéro")
		} ELSE IF (vm_mode_appel <> MODE_CREATION) AND (vm_fiche.type <> XZAEC_FMC_Accident) {
			/* sinon si c'est une fiche véhicule existante alors exiger */
			/* la validation du nouveau type avant d'ajouter des véhicules */
			INFO_MESSAGE@ ("Valider d'abord le changement de type")
		} ELSE {
			/* sinon ouvre la fenetre d'intervention dépanneur */
			tl_num_evt.numero = vm_fiche.numero
			tl_num_evt.cle = vm_fiche.cle
			vm_nb_vehicules = PEND_FOR_NEW_TASK@("ITMA_TID_Interv_Depanneur",
			                                   "ITMA_TMC",tl_num_evt,vm_enrichir)
		}


	/*********************************************************************/
	/*********************************************************************/
	/*********************************************************************/
	/*********************************************************************/
	/* evenements relatifs au tampon basculement				 */

	/* appui bau sens inverse pour le basculement*/
	CASE "BP_bascul_bau_i"
		/* je recupere l'ancienne valeur*/
		vl_indice=ARRAY_INDEX@(ARRAY_COLUMN@(tm_config_bascul,0),vl_evt)

		/* recuperation de l'icone suivante*/
		vl_ordre_icone_voie = tm_icones_voies[XZAEC_FMC_Basculement][TMC_VOIE_BAU_INV]
		vl_index=ARRAY_INDEX@(vl_ordre_icone_voie,tm_config_bascul[vl_indice][1])

		/* recuperation de l'icone suivante*/
		IF vl_index < ARRAY_SIZE@(vl_ordre_icone_voie) - 1
			vl_etat_voie=vl_ordre_icone_voie[vl_index+1]
		ELSE	vl_etat_voie=vl_ordre_icone_voie[0]

		/* je memorise la nouvele valeur*/
		tm_config_bascul[vl_indice][1]=vl_etat_voie

		/* si la BAU inverse est etroite alors prendre l'icone de BAU etroite */
		IF vm_fiche.bau_i_etroite = XDC_VRAI
			 vl_etat_voie = vl_etat_voie + XDC_VOIE_BAU_ETROITE

		/* affichage de l'icone*/
		DB_CTRL_TITLE@(vm_fenetre,vl_evt,tm_pix_bau_inv[vl_etat_voie])

	/* appui bau sens normal pour basculement*/
	CASE "BP_bascul_bau"
		/* je recupere l'ancienne valeur*/
		vl_indice=ARRAY_INDEX@(ARRAY_COLUMN@(tm_config_bascul,0),vl_evt)

		/* recuperation de l'icone suivante*/
		vl_ordre_icone_voie = tm_icones_voies[XZAEC_FMC_Basculement][TMC_VOIE_BAU]
		vl_index=ARRAY_INDEX@(vl_ordre_icone_voie,tm_config_bascul[vl_indice][1])

		/* recuperation de l'icone suivante*/
		IF vl_index < ARRAY_SIZE@(vl_ordre_icone_voie) - 1
			vl_etat_voie=vl_ordre_icone_voie[vl_index+1]
		ELSE	vl_etat_voie=vl_ordre_icone_voie[0]

		/* memorisation de la valeur*/
		tm_config_bascul[vl_indice][1]=vl_etat_voie

		/* si la BAU est etroite alors prendre l'icone de BAU etroite */
		IF vm_fiche.bau_etroite = XDC_VRAI
			 vl_etat_voie = vl_etat_voie + XDC_VOIE_BAU_ETROITE

		/* affichage de l'icone*/
		DB_CTRL_TITLE@(vm_fenetre,vl_evt,tm_pix_bau[vl_etat_voie])

	/* appui sur une icone de config des voies sens inverse pour bascul*/
	CASE "BP_bascul_vl_i"
	CASE "BP_bascul_vm1_i"
	CASE "BP_bascul_vm2_i"
	CASE "BP_bascul_vr_i"
		/* je recupere l'ancienne valeur*/
		vl_indice=ARRAY_INDEX@(ARRAY_COLUMN@(tm_config_bascul,0),vl_evt)

		/* recherche la position actuelle dans la liste des icones ordonnees */
		vl_ordre_icone_voie = tm_icones_voies[XZAEC_FMC_Basculement][TMC_VOIE_CIRC_INV]
		vl_index=ARRAY_INDEX@(vl_ordre_icone_voie,tm_config_bascul[vl_indice][1])

		/* recuperation de l'icone suivante*/
		IF vl_index < ARRAY_SIZE@(vl_ordre_icone_voie) - 1
			vl_etat_voie=vl_ordre_icone_voie[vl_index+1]
		ELSE	vl_etat_voie=vl_ordre_icone_voie[0]

		/* affichage de l'icone*/
		DB_CTRL_TITLE@(vm_fenetre,vl_evt,tm_pix_fav_inv[vl_etat_voie])

		/* memorisation de la valeur*/
		tm_config_bascul[vl_indice][1]=vl_etat_voie

	/* appui sur une des icones de config des voies sens normal pour bascul*/
	CASE "BP_bascul_vl"
	CASE "BP_bascul_vm1"
	CASE "BP_bascul_vm2"
	CASE "BP_bascul_vr"
		/* je recupere l'ancienne valeur*/
		vl_indice=ARRAY_INDEX@(ARRAY_COLUMN@(tm_config_bascul,0),vl_evt)

		/* recherche la position actuelle dans la liste des icones ordonnees */
		vl_ordre_icone_voie = tm_icones_voies[XZAEC_FMC_Basculement][TMC_VOIE_CIRCULEE]
		vl_index=ARRAY_INDEX@(vl_ordre_icone_voie,tm_config_bascul[vl_indice][1])

		/* recuperation de l'icone suivante*/
		IF vl_index < ARRAY_SIZE@(vl_ordre_icone_voie) - 1
			vl_etat_voie=vl_ordre_icone_voie[vl_index+1]
		ELSE	vl_etat_voie=vl_ordre_icone_voie[0]


		/* affichage de l'icone*/
		DB_CTRL_TITLE@(vm_fenetre,vl_evt,tm_pix_fav[vl_etat_voie])

		/* memorisation de la valeur*/
		tm_config_bascul[vl_indice][1]=vl_etat_voie

	/*********************************************************************/
	/*********************************************************************/
	/*********************************************************************/
	/*********************************************************************/
	/* evenements relatifs au tampon sous concessionnaire			 */

	/* choix de la penurie*/
	CASE "BT_penurie"
		vm_tampon_sousconce.penurie=DB_CTRL_GET_VALUE@(vm_fenetre,vl_evt)

		/* si le bouton est enfonce*/
		IF (vm_tampon_sousconce.penurie=-1)
			/* degriser la boite de saisie du carburant*/
			DB_CTRL_GRAYED@(vm_fenetre,"BO_carburant",FALSE)
		ELSE
		{
			/* la griser*/
			DB_CTRL_GRAYED@(vm_fenetre,"BO_carburant",TRUE)

			/* la forcer a null*/
			DB_CTRL_VALUE@(vm_fenetre,"BO_carburant",NULL)
		}

	/*********************************************************************/
        /*********************************************************************/
        /*********************************************************************/
        /*********************************************************************/
	/* evenements relatifs au tampon regulation			*/
	CASE "BO_zone"
		vl_indice=DB_CTRL_GET_VALUE@(vm_fenetre,vl_evt)
		TMC_reg_get_scenarios(vm_fenetre,vl_indice)

		if (vl_indice>-1) {
			tl_zones = SYSTEM_VAR@(vg_zones)
			if(tl_zones[vl_indice].sens = 2)
				vm_fiche.pr = tl_zones[vl_indice].fin
			else
				vm_fiche.pr = tl_zones[vl_indice].debut
			vm_fiche.autoroute = tl_zones[vl_indice].autoroute
			vm_fiche.sens = tl_zones[vl_indice].sens

			/* memorise et affiche le libelle de la localisation de la queue*/
			ITMA_TMC_genere_local()
		}

	/*********************************************************************/
	/*********************************************************************/
	/*********************************************************************/
	/*********************************************************************/
	/* evenements relatifs au tampon meteo						 */

	CASE "BO_nature_met"
		IF (vm_type_fmc = XZAEC_FMC_Meteo) {
			ITMA_TMC_met_CCH_visibles (vm_fenetre, vm_type_fmc, TRUE)
		}


	/* Sur appui sur un bouton de voie, passer a la condition suivante */
	CASE "BP_CCH_VR", "BP_CCH_VM2", "BP_CCH_VM1", "BP_CCH_VL", "BP_CCH_BAU"
	CASE "BP_CCH_VR_I", "BP_CCH_VM2_I", "BP_CCH_VM1_I", "BP_CCH_VL_I", "BP_CCH_BAU_I"
		ITMA_TMC_met_Voie_CCH (vm_fenetre, vl_evt)


	/* Sur selection d'une ligne de conditions de conduite, valuer les champs de saisie */
	CASE "TA_CCH_Prec"
	CASE "TA_CCH"
		ITMA_TMC_met_Selection_CCH (vm_fenetre, vl_evt)


	/* Ajouter les valeurs CCH saisies aux conditions de conduite actuelles */
	CASE "BP_CCH_Ajouter"
		/* PR de fin de l'evenement */
		vl_val = DB_CTRL_GET_VALUE@ (vm_fenetre, "BS_prmet")
		IF NOT IS_NULL@ (vl_val) {
			vl_val = vl_val * 1000
		}

		/* ordre des PR sur l'autoroute */
		vl_val2 = NULL
		vl_index = COM45_IndexEnColonne (tm_autoroutes,
		                                    TDO_NUMERO_AUTOROUTE, vm_fiche.autoroute)
		IF (vl_index >= 0) {
			vl_val2 = tm_autoroutes[vl_index].sens
		}
		ITMA_TMC_met_Ajouter_CCH (vm_fenetre, vm_fiche.pr, vl_val, vl_val2)


	/* Supprimer la ligne selectionnee des conditions de conduite actuelles */
	CASE "BP_CCH_Supprimer"
		ITMA_TMC_met_Supprimer_CCH (vm_fenetre)



	/*********************************************************************/
	/*********************************************************************/
	/*********************************************************************/
	/*********************************************************************/
	/* evenements relatifs au tampon travaux					 */

	/*selection d'une neutralisation de voie dans le tableau des neutralisations*/
	CASE "TA_neutral_trv"
		vl_indice=DB_TABLE_GET_SELECTIONS@(vm_fenetre, vl_evt)
		vl_indice=vl_indice[0]

		/*si une neutralisation est bien selectionnee*/
		if (vl_indice++""<>null) {
			/*on ouvre la bd de description de la neutralisation*/
			vl_cr=TMC_voie_neutral_modifie(vm_fenetre,vl_indice,tm_config_trv,
							tm_config)

			/*si une voie a ete validee*/
			if vl_cr[0]=COM_VALIDE 
			{
				/*remet a jour la config des voies*/
				ITMA_TMC_config_voies()

				if (vm_fiche.type=XZAEC_FMC_Travaux OR vm_fiche.type=XZAEC_FMC_Basculement OR vm_fiche.type=XZAEC_FMC_BasculTravaux) {
					TMC_calcule_vitesse(
						vm_fenetre,
						vm_fiche.autoroute,
						vm_fiche.pr,
						vm_fiche.sens,
						tm_config,
						vm_fiche.type,
						DB_CTRL_GET_VALUE@(vm_fenetre,"BS_pr_bascul"))
				}
			}
		}


	/* appui bau sens inverse pour le travaux*/
	CASE "BP_trv_bau_i"
		/* recuperer l'etat actuel */
		vl_indice = COM45_IndexEnColonne (tm_config_trv,0,vl_evt)

		/* calcul de l'etat suivant de la voie */
		vl_ordre_icone_voie = tm_icones_voies[vm_type_fmc][TMC_VOIE_BAU_INV]
		vl_index= ARRAY_INDEX@(vl_ordre_icone_voie,tm_config_trv[vl_indice][1])
		IF vl_index < ARRAY_SIZE@(vl_ordre_icone_voie) - 1
			vl_etat_voie = vl_ordre_icone_voie[vl_index+1]
		ELSE	vl_etat_voie = vl_ordre_icone_voie[0]

		/* si la voie est bloquee */
		IF (vl_etat_voie = XDC_VOIE_SENS_NORMAL) OR (vl_etat_voie = XDC_VOIE_NEUTRALISEE) OR
		   (vl_etat_voie = XDC_VOIE_BLOQUEE_NEUTRALISEE) {
			/* si le PR de tête n'est pas renseigné afficher l'erreur */
			vl_val = DB_CTRL_GET_VALUE@(vm_fenetre,"BS_prtetetrv") * 1000
			IF vl_val = NULL {
				INFO_MESSAGE@("PR de tête non renseigné") 
				vl_etat_voie=XDC_VOIE_INCONNUE
			} ELSE {
				/* sinon l'ajouter aux voies neutralisees */
				TMC_voie_neutral_ajoute(vm_fenetre,vl_evt,vl_etat_voie,vm_fiche.pr,vl_val)
			}
		} ELSE {
			/* et si elle ne l'est pas la supprimer */
			TMC_voie_neutral_supprime(vm_fenetre,vl_evt)
		}

		IF (vl_etat_voie <> XDC_VOIE_INCONNUE) {
			/* memoriser et afficher le nouvel etat de la voie */
			tm_config_trv[vl_indice][1]=vl_etat_voie

			/* si la BAU inverse est etroite alors adapter l'icone */
			IF vm_fiche.bau_i_etroite = XDC_VRAI
				vl_etat_voie = vl_etat_voie + XDC_VOIE_BAU_ETROITE
			DB_CTRL_TITLE@(vm_fenetre,vl_evt,tm_pix_bau_inv[vl_etat_voie])
		}

	/* appui bau sens normal pour travaux*/
	CASE "BP_trv_bau"
		/* recuperer l'etat actuel */
		vl_indice = COM45_IndexEnColonne (tm_config_trv,0,vl_evt)

		/* calcul de l'etat suivant de la voie */
		vl_ordre_icone_voie = tm_icones_voies[vm_type_fmc][TMC_VOIE_BAU]
		vl_index= ARRAY_INDEX@(vl_ordre_icone_voie,tm_config_trv[vl_indice][1])
		IF vl_index < ARRAY_SIZE@(vl_ordre_icone_voie) - 1
			vl_etat_voie = vl_ordre_icone_voie[vl_index+1]
		ELSE	vl_etat_voie = vl_ordre_icone_voie[0]

		/* si la voie est bloquee */
		IF (vl_etat_voie = XDC_VOIE_SENS_NORMAL) OR (vl_etat_voie = XDC_VOIE_NEUTRALISEE) OR
		   (vl_etat_voie = XDC_VOIE_BLOQUEE_NEUTRALISEE) {
			/* si le PR de tête n'est pas renseigné afficher l'erreur */
			vl_val = DB_CTRL_GET_VALUE@(vm_fenetre,"BS_prtetetrv") * 1000
			IF vl_val = NULL {
				INFO_MESSAGE@("PR de tête non renseigné") 
				vl_etat_voie=XDC_VOIE_INCONNUE
			} ELSE {
				/* sinon l'ajouter aux voies neutralisees */
				TMC_voie_neutral_ajoute(vm_fenetre,vl_evt,vl_etat_voie,vm_fiche.pr,vl_val)
			}
		} ELSE {
			/* et si elle ne l'est pas la supprimer */
			TMC_voie_neutral_supprime(vm_fenetre,vl_evt)
		}

		IF (vl_etat_voie <> XDC_VOIE_INCONNUE) {
			/* memoriser et afficher le nouvel etat de la voie */
			tm_config_trv[vl_indice][1]=vl_etat_voie

			/* si la BAU est etroite alors adapter l'icone */
			IF vm_fiche.bau_etroite = XDC_VRAI
				vl_etat_voie = vl_etat_voie + XDC_VOIE_BAU_ETROITE
			DB_CTRL_TITLE@(vm_fenetre,vl_evt,tm_pix_bau[vl_etat_voie])
		}


	/* appui sur une icone de config des voies sens inverse pour travaux*/ /*DEM589 */
	CASE "BP_trv_vr_i"
	CASE "BP_trv_vm1_i"
	CASE "BP_trv_vm2_i"
	CASE "BP_trv_vl_i"
		/* recuperer l'etat actuel */
		vl_indice = COM45_IndexEnColonne (tm_config_trv,0,vl_evt)

		/* calcul de l'etat suivant de la voie */
		vl_ordre_icone_voie = tm_icones_voies[vm_type_fmc][TMC_VOIE_CIRC_INV]
		vl_index= ARRAY_INDEX@(vl_ordre_icone_voie,tm_config_trv[vl_indice][1])
		IF vl_index < ARRAY_SIZE@(vl_ordre_icone_voie) - 1
			vl_etat_voie = vl_ordre_icone_voie[vl_index+1]
		ELSE	vl_etat_voie = vl_ordre_icone_voie[0]

		/* si la voie est bloquee */
		IF (vl_etat_voie = XDC_VOIE_NEUTRALISEE) OR
		   (vl_etat_voie = XDC_VOIE_BLOQUEE_NEUTRALISEE) OR
		   (vl_etat_voie = XDC_VOIE_SENS_INVERSE) {
			/* si le PR de tête n'est pas renseigné afficher l'erreur */
			vl_val = DB_CTRL_GET_VALUE@(vm_fenetre,"BS_prtetetrv") * 1000
			IF vl_val = NULL {
				INFO_MESSAGE@("PR de tête non renseigné") 
				vl_etat_voie=XDC_VOIE_INCONNUE
			} ELSE {
				/* sinon l'ajouter aux voies neutralisees */
				TMC_voie_neutral_ajoute(vm_fenetre,vl_evt,vl_etat_voie,vm_fiche.pr,vl_val)
			}
		} ELSE {
			/* et si elle ne l'est pas la supprimer */
			TMC_voie_neutral_supprime(vm_fenetre,vl_evt)
		}

		/* pour un Basculement pour travaux, si la circulation en sens inverse débute ou cesse      */
		/* sur la voie rapide de la chaussée opposée, désélectionner l'indicateur de bouchon mobile */
		IF (vm_type_fmc = XZAEC_FMC_BasculTravaux  AND  vl_evt = "BP_trv_vr_i"  AND
		     (vl_etat_voie = XDC_VOIE_SENS_INVERSE  OR  tm_config_trv[vl_indice][1] = XDC_VOIE_SENS_INVERSE))
		{
			tl_neutral = DB_TABLE_GET_DATA@ (vm_fenetre, "TA_neutral_trv")
			FOR i = 0 TO (ARRAY_SIZE@ (tl_neutral) - 1)
				IF (tl_neutral[i].code_voie = XDC_CODE_VOIE_VR_I  AND  tl_neutral[i].horodate_debut <> NULL)
				{
					DB_CTRL_VALUE@ (vm_fenetre, "BT_bouchon", FALSE)
				}
			NEXT i
		}

		IF (vl_etat_voie <> XDC_VOIE_INCONNUE) {
			/* memoriser et afficher le nouvel etat de la voie */
			tm_config_trv[vl_indice][1]=vl_etat_voie
			DB_CTRL_TITLE@(vm_fenetre,vl_evt,tm_pix_fav_inv[vl_etat_voie])
		}


	/* appui sur une des icones de config des voies sens normal pour travaux*/
	CASE "BP_trv_vl"
	CASE "BP_trv_vm1"
	CASE "BP_trv_vm2"
	CASE "BP_trv_vr"
		/* recuperer l'etat actuel */
		vl_indice = COM45_IndexEnColonne (tm_config_trv,0,vl_evt)

		/* calcul de l'etat suivant de la voie */
		vl_ordre_icone_voie = tm_icones_voies[vm_type_fmc][TMC_VOIE_CIRCULEE]
		vl_index= ARRAY_INDEX@(vl_ordre_icone_voie,tm_config_trv[vl_indice][1])
		IF vl_index < ARRAY_SIZE@(vl_ordre_icone_voie) - 1
			vl_etat_voie = vl_ordre_icone_voie[vl_index+1]
		ELSE	vl_etat_voie = vl_ordre_icone_voie[0]

		/* si la voie est bloquee */
		IF (vl_etat_voie = XDC_VOIE_NEUTRALISEE) OR
		   (vl_etat_voie = XDC_VOIE_BLOQUEE_NEUTRALISEE) {
			/* si le PR de tête n'est pas renseigné afficher l'erreur */
			vl_val = DB_CTRL_GET_VALUE@(vm_fenetre,"BS_prtetetrv") * 1000
			IF vl_val = NULL {
				INFO_MESSAGE@("PR de tête non renseigné") 
				vl_etat_voie=XDC_VOIE_INCONNUE
			} ELSE {
				/* sinon l'ajouter aux voies neutralisees */
				TMC_voie_neutral_ajoute(vm_fenetre,vl_evt,vl_etat_voie,vm_fiche.pr,vl_val)
			}
		} ELSE {
			/* et si elle ne l'est pas la supprimer */
			TMC_voie_neutral_supprime(vm_fenetre,vl_evt)
		}

		IF (vl_etat_voie <> XDC_VOIE_INCONNUE) {
			/* memoriser et afficher le nouvel etat de la voie */
			tm_config_trv[vl_indice][1]=vl_etat_voie
			DB_CTRL_TITLE@(vm_fenetre,vl_evt,tm_pix_fav[vl_etat_voie])
		}


		/* Calcul de vitesse */
	CASE "BT_voiesret"
		/* Calcul de vitesse */

		if (vm_fiche.type <> XZAEC_FMC_ZoneStockage)
		{	TMC_calcule_vitesse(
				vm_fenetre,
				vm_fiche.autoroute,
                                vm_fiche.pr,
				vm_fiche.sens,
				tm_config,
				vm_fiche.type,
				DB_CTRL_GET_VALUE@(vm_fenetre,"BS_pr_bascul"))
		}

	CASE "BT_continutrv"
		vm_tampon_trv.continu=-1*DB_CTRL_GET_VALUE@(vm_fenetre,vl_evt)

		/* si le BT est enfonce*/
		IF (vm_tampon_trv.continu<>0)
		{
			/* si les dates de debut et fin travaux n'ont pas de valeur */
			/* alors leur donner les valeurs de debut et fin prevus */
			IF COM23_Horodate (vm_fenetre, "BS_jd_trv", "BS_md_trv", "BS_ad_trv",
			                               "BS_hd_trv", "BS_mid_trv", NULL) = NULL
			{
				IF COM23_Horodate (vm_fenetre, "BS_jf_trv", "BS_mf_trv", "BS_af_trv",
							       "BS_hf_trv", "BS_mif_trv", NULL) = NULL
				{
					vl_horodate = COM23_Horodate (vm_fenetre, "BS_jour_debut_prevu",
					                              "BS_mois_debut_prevu", "BS_annee_debut_prevu",
					                              "BS_heure_debut_prevu", "BS_minute_debut_prevu")
					COM24_Afficher_Horodate (vl_horodate, vm_fenetre,
					                            "BS_jd_trv", "BS_md_trv", "BS_ad_trv",
					                            "BS_hd_trv", "BS_mid_trv", NULL)

					vl_horodate = COM23_Horodate (vm_fenetre, "BS_jour_fin_prevue",
					                              "BS_mois_fin_prevue", "BS_annee_fin_prevue",
					                              "BS_heure_fin_prevue", "BS_minute_fin_prevue")
					COM24_Afficher_Horodate (vl_horodate, vm_fenetre,
					                            "BS_jf_trv", "BS_mf_trv", "BS_af_trv",
					                            "BS_hf_trv", "BS_mif_trv", NULL)
				}
			}

			/* afficher horodates debut et fin continues*/
			ITMA_TMC_visible("Dates travaux",TRUE)

			DB_CURSOR_IN_ENTRY@(vm_fenetre,"BS_jf_trv", TRUE)
		}
		/* sinon*/
		ELSE
		{
			/* ne plus afficher ces controles*/
			ITMA_TMC_visible("Dates travaux",FALSE)

			/* mettre a jour le tampon*/
			vm_tampon_trv.debut_continu=XDC_DATE_NULLE
			vm_tampon_trv.fin_continu=XDC_DATE_NULLE
		}

	/* Selectionner le type rappel client */
	CASE "BO_rappel"
		/* Modification du type de rappel client avant validation */
		vl_index = DB_CTRL_GET_VALUE@ (vm_fenetre, "BO_rappel")
		IF (vl_index = XZAEC_TYP_RAP_NUM_CLIENT)
		{
			/* Afficher tous les champs relatifs au rappel client */
			DB_CTRL_DISPLAY@ (vm_fenetre, "BS_complement_rappel", TRUE)
			DB_CTRL_DISPLAY@ (vm_fenetre, "BP_appeler", TRUE)
			DB_CTRL_TITLE@ (vm_fenetre, "BS_complement_rappel", "Num. Tel. Client")
		}
		ELSE IF (vl_index = XZAEC_TYP_RAP_AUTRE)
		{
			/* Afficher tous les champs relatifs au rappel client sauf bouton appeler */
			DB_CTRL_DISPLAY@ (vm_fenetre, "BS_complement_rappel", TRUE)
			DB_CTRL_DISPLAY@ (vm_fenetre, "BP_appeler", FALSE)
			DB_CTRL_TITLE@ (vm_fenetre, "BS_complement_rappel", "Complément rappel")
		}
		ELSE
		{
			/* Masquer tous les champs relatifs au rappel client */
			DB_CTRL_DISPLAY@ (vm_fenetre, "BS_complement_rappel", FALSE)
			DB_CTRL_DISPLAY@ (vm_fenetre, "BP_appeler", FALSE)
		}
		
	/* Gestion de l'appel client */
	CASE "BP_appeler"
		/* Appel de la macro de numerotation */
		vl_numero_appel = DB_CTRL_GET_VALUE@ (vm_fenetre, "BS_complement_rappel")
		IF (vl_numero_appel <> "")
		/* Le numero est renseigné */
		{
			vl_type_astreinte.numero = XDC_AST_CLIENT
			vl_type_astreinte.nom = XDC_LIB_AST_CLIENT
			
			vl_arguments[1] = "N/A"
			vl_arguments[2] = "N/A"
			vl_arguments[3] = "N/A"
			vl_arguments[4] = -1		/* Numero de competence */
			vl_arguments[5] = -1		/* Num. auto */
			vl_arguments[6] = vm_fiche.pr
			vl_arguments[7][0] = vm_fiche.numero
			vl_arguments[7][1] = vm_fiche.cle
			vl_arguments[8] = DB_CTRL_GET_TITLE@(vm_fenetre, "LI_intitulé_fmc")
			vl_arguments[9] = ""
			vl_arguments[10 ]= "APPEL CLIENT DEPUIS PAU VIRTUEL"
			
			NEW_TASK@("ITMA_TAT_Appel_Telephonique",
					  "ITMA_LCL",
					  "0"++vl_numero_appel,
					  "CLIENT",
					  "CLIENT",
					  XDC_BIP_INCONNU,
					  vl_type_astreinte,
					  vl_arguments)
		}

	ENDCASE

/* Fin de boucle principale*/
WEND
ENDMACRO


macro dumpfmc()
	DUMP_ARRAY@ (vm_fiche)
	DUMP_ARRAY@ (vm_fiche_queue)
	DUMP_ARRAY@ (vm_fiche_tete)
	DUMP_ARRAY@ (tm_vehicules)
endmacro






/*-----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Initialise les données générales du module,
*   qui ne dépendent pas du type de la FMC.
*
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO TMC_Init_Donnees_Globales ()

/*
* ARGUMENTS EN ENTREE : Aucun
*
* ARGUMENTS EN SORTIE : Aucun
*
* CODE RETOUR : Aucun
*
* CONDITION D'UTILISATION
*
*
* FONCTION
*
-----------------------------------------------------------------------------*/

/*
 * Liste des icones de configuration de voie circulée
 * dans l'ordre où elles sont proposées, par catégorie de type FMC
 * ---------------------------------------------------------------
 */
DEFINE  TMC_ICONES_VOIES_TRV  XDC_VOIE_SENS_NORMAL, XDC_VOIE_NEUTRALISEE, XDC_VOIE_BLOQUEE_NEUTRALISEE, XDC_VOIE_SENS_INVERSE
DEFINE  TMC_ICONES_VOIES_BAS  XDC_VOIE_SENS_NORMAL, XDC_VOIE_NEUTRALISEE, XDC_VOIE_BLOQUEE_NEUTRALISEE, XDC_VOIE_BLOQUEE, XDC_VOIE_SENS_INVERSE
DEFINE  TMC_ICONES_VOIES_DEF  XDC_VOIE_SENS_NORMAL, XDC_VOIE_BLOQUEE, XDC_VOIE_NEUTRALISEE, XDC_VOIE_BLOQUEE_NEUTRALISEE, XDC_VOIE_SENS_INVERSE
DEFINE	TMC_ICONES_VOIES_BOU	XDC_VOIE_SENS_NORMAL, XDC_VOIE_BLOQUEE



/*
 * Liste des icones de configuration de voie circulée inverse
 * dans l'ordre où elles sont proposées, par catégorie de type FMC
 * ---------------------------------------------------------------
 */
DEFINE  TMC_ICONES_VOIES_TRV_INV  XDC_VOIE_SENS_NORMAL, XDC_VOIE_NEUTRALISEE, XDC_VOIE_BLOQUEE_NEUTRALISEE, XDC_VOIE_SENS_INVERSE, XDC_VOIE_BLOQUEE
DEFINE  TMC_ICONES_VOIES_BAS_INV  XDC_VOIE_SENS_NORMAL, XDC_VOIE_SENS_INVERSE, XDC_VOIE_NEUTRALISEE, XDC_VOIE_BLOQUEE_NEUTRALISEE, XDC_VOIE_BLOQUEE
DEFINE  TMC_ICONES_VOIES_DEF_INV  XDC_VOIE_SENS_NORMAL, XDC_VOIE_BLOQUEE, XDC_VOIE_NEUTRALISEE, XDC_VOIE_BLOQUEE_NEUTRALISEE, XDC_VOIE_SENS_INVERSE
DEFINE	TMC_ICONES_VOIES_BOU_INV TMC_ICONES_VOIES_BOU


/*
 * Liste des icones de configuration de bau
 * dans l'ordre où elles sont proposées, par catégorie de type FMC
 * ---------------------------------------------------------------
 */
DEFINE  TMC_ICONES_BAU_TRV  XDC_VOIE_BAU_NORMALE, XDC_VOIE_NEUTRALISEE, XDC_VOIE_BLOQUEE_NEUTRALISEE, XDC_VOIE_SENS_INVERSE, XDC_VOIE_SENS_NORMAL
DEFINE  TMC_ICONES_BAU_BAS  XDC_VOIE_BAU_NORMALE, XDC_VOIE_NEUTRALISEE, XDC_VOIE_BLOQUEE_NEUTRALISEE, XDC_VOIE_BLOQUEE, XDC_VOIE_SENS_INVERSE, XDC_VOIE_SENS_NORMAL
DEFINE  TMC_ICONES_BAU_DEF  XDC_VOIE_BAU_NORMALE, XDC_VOIE_BLOQUEE, XDC_VOIE_NEUTRALISEE, XDC_VOIE_BLOQUEE_NEUTRALISEE, XDC_VOIE_SENS_INVERSE, XDC_VOIE_SENS_NORMAL
DEFINE	TMC_ICONES_BAU_BOU  TMC_ICONES_VOIES_BOU


/*
 * Liste des icones de configuration de bau inverse
 * dans l'ordre où elles sont proposées, par catégorie de type FMC
 * ---------------------------------------------------------------
 */
DEFINE  TMC_ICONES_BAU_TRV_INV  TMC_ICONES_BAU_TRV
DEFINE  TMC_ICONES_BAU_BAS_INV  XDC_VOIE_BAU_NORMALE, XDC_VOIE_SENS_INVERSE, XDC_VOIE_NEUTRALISEE, XDC_VOIE_BLOQUEE_NEUTRALISEE, XDC_VOIE_BLOQUEE, XDC_VOIE_SENS_NORMAL
DEFINE  TMC_ICONES_BAU_DEF_INV  TMC_ICONES_BAU_DEF
DEFINE	TMC_ICONES_BAU_BOU_INV TMC_ICONES_VOIES_BOU


VAR	i
VAR	tl_origines_valides


/* Initialiser les tableaux de pixmaps */
tm_pix_fav	= SYSTEM_VAR@ (vg_les_pix_fav)
tm_pix_fav_inv	= SYSTEM_VAR@ (vg_les_pix_fav_inv)
tm_pix_bau	= SYSTEM_VAR@ (vg_les_pix_bau)
tm_pix_bau_inv	= SYSTEM_VAR@ (vg_les_pix_bau_inv)


/* Initialiser la liste des autoroutes */
tm_autoroutes = SYSTEM_VAR@ (vg_toutes_les_autoroutes)

/* Initialiser la liste des sens*/
tm_sens_echangeur = SYSTEM_VAR@ (vg_les_sens_circulation)
/* Changer le libellé du sens Inconnu en 'non précisé' */
i = COM45_IndexEnColonne (tm_sens_echangeur, TDO_NUMERO_SENS, XDC_SENS_INCONNU)
tm_sens_echangeur[i].nom = XDC_LIB_SENS_NON_PREC

/* Initialiser la liste des points caracteristiques */
tm_aires	= SYSTEM_VAR@ (vg_les_aires)
tm_echangeurs	= SYSTEM_VAR@ (vg_les_echangeurs)
tm_gares	= SYSTEM_VAR@ (vg_les_gares)
tm_lits_arret	= SYSTEM_VAR@ (vg_les_lits_arret)

/* B Initialiser la liste des sites de création des fiches vehicules */
tm_sites = SYSTEM_VAR@ (vg_les_districts)


/* Initialiser la table des valeurs de veracite */
tm_veracite[0] = { COM_LIB_FMC_SIGNALEE, XZAEC_FMC_SIGNALEE }
tm_veracite[1] = { COM_LIB_FMC_CONFIRMEE, XZAEC_FMC_CONFIRMEE }


/* Initialiser la liste des origines */
/* La liste complete est conservee en variable publique (mais n'est utilisee que par MTMC) */
tm_origines = SYSTEM_VAR@ (vg_origines_fmc)
IF IS_NULL@ (tm_origines)
{
	COM37_Lit_Libelles_Predefinis (XDC_LIB_ORIGINE, tm_origines, tl_origines_valides)
	FOR i = 0 TO ARRAY_SIZE@ (tm_origines) - 1
		tm_origines[i].libelle = TRIM@ (tm_origines[i].libelle)
		/*! Ne garder que les donnees utiles pour economie de memoire */
		tm_origines[i].explication = NULL
	NEXT i
	SET_SYSTEM_VAR@ (vg_origines_fmc, tm_origines)
}

/* Les origines valides sont seules proposees (hormis l'origine invalide d'une fiche ancienne) */
tm_choix_origine = COM44_ValeursEnColonne (tm_origines, TDO_VALID_LIBELLE, { XDC_VRAI }, TRUE)
 

/* Initialiser les libelles des etats des actions */
tm_etats_actions[0]=0
tm_etats_actions[1]="Lancement"			'XDC_ACT_ETAT_LANC
tm_etats_actions[2]="Fin de lancement"		'XDC_ACT_ETAT_LANC_FIN
tm_etats_actions[3]="Succès"			'XDC_ACT_ETAT_SUCCES
tm_etats_actions[4]="Echec"			'XDC_ACT_ETAT_ECHEC
tm_etats_actions[5]="Fin"			'XDC_ACT_ETAT_FIN
tm_etats_actions[6]="Succès/Fin"		'XDC_ACT_ETAT_SUCCES_FIN
tm_etats_actions[7]="Echec/Fin"			'XDC_ACT_ETAT_ECHEC_FIN


/* Initialiser la liste des codes de matières */
COM37_Lit_Libelles_Predefinis (XDC_LIB_CODE_MAT_DANG, tm_code_matiere, tm_code_matiere_valide)


/* Initialiser la liste des type de fiches main courante */
tm_types_fmc = SYSTEM_VAR@ (vg_les_types_FMC)


/* Initialiser la liste des fonctions de traitement */
/* des informations spécifiques selon le type de FMC */
FOR i = 0 TO ARRAY_SIZE@ (tm_types_fmc) - 1
	CASE OF tm_types_fmc[i].classe
		CASE XZAEC_ClasseAccident	tm_macro_specifique[i] = "ITMA_TMC_acc"
		CASE XZAEC_ClasseDelestage	tm_macro_specifique[i] = "ITMA_TMC_del"
		CASE XZAEC_ClasseVehicule	tm_macro_specifique[i] = "ITMA_TMC_veh"
		CASE XZAEC_ClasseVehLent	tm_macro_specifique[i] = "ITMA_TMC_vhl"
		CASE XZAEC_ClasseMeteo		tm_macro_specifique[i] = "ITMA_TMC_met"
		CASE XZAEC_ClasseEchangeur	tm_macro_specifique[i] = "ITMA_TMC_ech"
		CASE XZAEC_ClasseSousConcess	tm_macro_specifique[i] = "ITMA_TMC_sscnc"
		CASE XZAEC_ClasseManif		tm_macro_specifique[i] = "ITMA_TMC_manif"
		CASE XZAEC_ClasseBouchon	tm_macro_specifique[i] = "ITMA_TMC_bou"
		CASE XZAEC_ClasseTravaux	tm_macro_specifique[i] = "ITMA_TMC_trv"
		CASE XZAEC_ClasseBasculement	tm_macro_specifique[i] = "ITMA_TMC_bascul"
		CASE XZAEC_ClassePosteOper	tm_macro_specifique[i] = "ITMA_TMC_operateur"
		CASE XZAEC_ClasseGenerique	tm_macro_specifique[i] = "ITMA_TMC_gen"
		CASE XZAEC_ClasseNature		tm_macro_specifique[i] = "ITMA_TMC_Nature"
		CASE XZAEC_ClasseBasculTrav	tm_macro_specifique[i] = "ITMA_TMC_bascul_trv"
		CASE XZAEC_ClasseRegulation	tm_macro_specifique[i] = "ITMA_TMC_reg"
		CASE XZAEC_ClasseIncendie	tm_macro_specifique[i] = "ITMA_TMC_incendie"
	ENDCASE
NEXT i


/* Initialiser le tableau des ordres des icones des voies par type de fmc */
FOR i =  0 TO ARRAY_SIZE@ (tm_types_fmc) - 1
	if tm_types_fmc[i].numero = XZAEC_FMC_Basculement
	{
		tm_icones_voies[XZAEC_FMC_Basculement][TMC_VOIE_CIRCULEE] = TMC_ICONES_VOIES_BAS
		tm_icones_voies[XZAEC_FMC_Basculement][TMC_VOIE_CIRC_INV] = TMC_ICONES_VOIES_BAS_INV
		tm_icones_voies[XZAEC_FMC_Basculement][TMC_VOIE_BAU] = TMC_ICONES_BAU_BAS
		tm_icones_voies[XZAEC_FMC_Basculement][TMC_VOIE_BAU_INV] = TMC_ICONES_BAU_BAS_INV
	}
	else if (tm_types_fmc[i].numero = XZAEC_FMC_Travaux) OR
	        (tm_types_fmc[i].numero = XZAEC_FMC_ZoneStockage) OR
	        (tm_types_fmc[i].numero = XZAEC_FMC_BasculTravaux)
	{
		tm_icones_voies[tm_types_fmc[i].numero][TMC_VOIE_CIRCULEE] = TMC_ICONES_VOIES_TRV
		tm_icones_voies[tm_types_fmc[i].numero][TMC_VOIE_CIRC_INV] = TMC_ICONES_VOIES_TRV_INV
		tm_icones_voies[tm_types_fmc[i].numero][TMC_VOIE_BAU] = TMC_ICONES_BAU_TRV
		tm_icones_voies[tm_types_fmc[i].numero][TMC_VOIE_BAU_INV] = TMC_ICONES_BAU_TRV_INV
	}
	else if tm_types_fmc[i].numero = XZAEC_FMC_QueueBouchon
	{
		tm_icones_voies[XZAEC_FMC_QueueBouchon][TMC_VOIE_CIRCULEE] = TMC_ICONES_VOIES_BOU
		tm_icones_voies[XZAEC_FMC_QueueBouchon][TMC_VOIE_CIRC_INV] = TMC_ICONES_VOIES_BOU_INV
		tm_icones_voies[XZAEC_FMC_QueueBouchon][TMC_VOIE_BAU] = TMC_ICONES_BAU_BOU
		tm_icones_voies[XZAEC_FMC_QueueBouchon][TMC_VOIE_BAU_INV] = TMC_ICONES_BAU_BOU_INV
	}
	else
	{
		tm_icones_voies[tm_types_fmc[i].numero][TMC_VOIE_CIRCULEE] = TMC_ICONES_VOIES_DEF
		tm_icones_voies[tm_types_fmc[i].numero][TMC_VOIE_CIRC_INV] = TMC_ICONES_VOIES_DEF_INV
		tm_icones_voies[tm_types_fmc[i].numero][TMC_VOIE_BAU] = TMC_ICONES_BAU_DEF
		tm_icones_voies[tm_types_fmc[i].numero][TMC_VOIE_BAU_INV] = TMC_ICONES_BAU_DEF_INV
	}
NEXT i


/* Initialiser les tableaux de configuration des voies a leur valeur par défaut */
/* (modifiées éventuellement ensuite selon le type de la FMC) */
tm_config[0] = { "BP_bau_i",XDC_VOIE_INEXISTANTE }
tm_config[1] = { "BP_vl_i",XDC_VOIE_INEXISTANTE }
tm_config[2] = { "BP_vm1_i",XDC_VOIE_INEXISTANTE }
tm_config[3] = { "BP_vm2_i",XDC_VOIE_INEXISTANTE }
tm_config[4] = { "BP_vr_i",XDC_VOIE_INEXISTANTE }
tm_config[5] = { "BP_bau",XDC_VOIE_INEXISTANTE }
tm_config[6] = { "BP_vl",XDC_VOIE_INEXISTANTE }
tm_config[7] = { "BP_vm1",XDC_VOIE_INEXISTANTE }
tm_config[8] = { "BP_vm2",XDC_VOIE_INEXISTANTE }
tm_config[9] = { "BP_vr",XDC_VOIE_INEXISTANTE }

tm_config_tete = tm_config

/* Tableau de configuration des voies pour basculement */
tm_config_bascul[0] = { "BP_bascul_bau_i", XDC_VOIE_INEXISTANTE }
tm_config_bascul[1] = { "BP_bascul_vl_i", XDC_VOIE_INEXISTANTE }
tm_config_bascul[2] = { "BP_bascul_vm1_i", XDC_VOIE_INEXISTANTE }
tm_config_bascul[3] = { "BP_bascul_vm2_i", XDC_VOIE_INEXISTANTE }
tm_config_bascul[4] = { "BP_bascul_vr_i", XDC_VOIE_INEXISTANTE }
tm_config_bascul[5] = { "BP_bascul_bau", XDC_VOIE_INEXISTANTE }
tm_config_bascul[6] = { "BP_bascul_vl", XDC_VOIE_INEXISTANTE }
tm_config_bascul[7] = { "BP_bascul_vm1", XDC_VOIE_INEXISTANTE }
tm_config_bascul[8] = { "BP_bascul_vm2", XDC_VOIE_INEXISTANTE }
tm_config_bascul[9] = { "BP_bascul_vr", XDC_VOIE_INEXISTANTE }

/* Tableau de configuration des voies pour travaux */
tm_config_trv[0] = { "BP_trv_bau_i", XDC_VOIE_INEXISTANTE }
tm_config_trv[1] = { "BP_trv_vl_i", XDC_VOIE_INEXISTANTE }
tm_config_trv[2] = { "BP_trv_vm1_i", XDC_VOIE_INEXISTANTE }
tm_config_trv[3] = { "BP_trv_vm2_i", XDC_VOIE_INEXISTANTE }
tm_config_trv[4] = { "BP_trv_vr_i", XDC_VOIE_INEXISTANTE }
tm_config_trv[5] = { "BP_trv_bau", XDC_VOIE_INEXISTANTE }
tm_config_trv[6] = { "BP_trv_vl", XDC_VOIE_INEXISTANTE }
tm_config_trv[7] = { "BP_trv_vm1", XDC_VOIE_INEXISTANTE }
tm_config_trv[8] = { "BP_trv_vm2", XDC_VOIE_INEXISTANTE }
tm_config_trv[9] = { "BP_trv_vr", XDC_VOIE_INEXISTANTE }

ENDMACRO






/*-----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Recolte les donnees saisies (en interface IHM) specifiques au type FMC,
*  ou bien met a jour ces donnees (avec des donnees provenant de la base).
*
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO TMC_Donnees_Specifiques (va_Type_Fmc, va_Donnees, va_Mise_A_Jour)

/*
* ARGUMENTS EN ENTREE :
*   va_Type_Fmc       : le type de la Fmc ;
*   va_Donnees        : le tampon des donnees specifiques au type de Fmc ;
*   va_Mise_A_Jour    : indicateur vrai si mise a jour, faux pour collecte.
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR : Indefini.
*
*
* CONDITION D'UTILISATION
*  ITMA_TMC_Fiche_Main_Courante
*
* FONCTION
*   Copie les donnees fournies dans les tampons specifiques au type Fmc
*    ou bien rassemble et retourne les donnees des tampons specifiques.
*
-----------------------------------------------------------------------------*/

VAR	vl_index

	/* Determiner la classe de la Fmc */
	vl_index = COM45_IndexEnColonne (tm_types_fmc, TDO_NUMERO_FMC, va_Type_Fmc)

	IF (va_Mise_A_Jour = TRUE) {
		/* Copier les donnees fournies dans le(s) tampon(s) specifique(s) au type */
		CASE OF tm_types_fmc[vl_index].classe
			/*! pour un accident les vehicules sont egalement lus en base */
			CASE XZAEC_ClasseAccident
				vm_tampon_accident = va_Donnees[0]
				/*tm_vehicules = va_Donnees[1]*/

			CASE XZAEC_ClasseDelestage
				vm_tampon_delestage = va_Donnees[0]

			CASE XZAEC_ClasseVehicule
				tm_vehicules = { va_Donnees[0] }

			CASE XZAEC_ClasseVehLent
				vm_tampon_vhl = va_Donnees[0]

			CASE XZAEC_ClasseRegulation
				vm_tampon_regul = va_Donnees[0]

			CASE XZAEC_ClasseMeteo
				vm_tampon_meteo = va_Donnees[0]

			CASE XZAEC_ClasseEchangeur
				vm_tampon_echangeur = va_Donnees[0]

			CASE XZAEC_ClasseSousConcess
				vm_tampon_sousconce = va_Donnees[0]

			CASE XZAEC_ClasseManif
				vm_tampon_manif = va_Donnees[0]

			CASE XZAEC_ClasseBouchon
				vm_tampon_bouchon = va_Donnees[0]

			CASE XZAEC_ClassePosteOper
				vm_tampon_operateur = va_Donnees[0]

			CASE XZAEC_ClasseNature
				vm_tampon_nature = va_Donnees[0]

			CASE XZAEC_ClasseTravaux
				vm_tampon_trv = va_Donnees[0]

			CASE XZAEC_ClasseBasculement
				vm_tampon_bascul = va_Donnees[0]

			CASE XZAEC_ClasseBasculTrav
				vm_tampon_trv = va_Donnees[0]
				vm_tampon_bascul = va_Donnees[1]

			CASE XZAEC_ClasseIncendie
				vm_tampon_incendie = va_Donnees[0]
		ENDCASE

		/*! dans le cas d'un basculement ou d'un basculement pour travaux, */
		/*! mettre a jour les configurations de voies pour basculement */
		IF (va_Type_Fmc = XZAEC_FMC_Basculement) OR (va_Type_Fmc = XZAEC_FMC_BasculTravaux) {
			tm_config_bascul[0][1] = vm_tampon_bascul.bau_i
			tm_config_bascul[1][1] = vm_tampon_bascul.vl_i
			tm_config_bascul[2][1] = vm_tampon_bascul.vm1_i
			tm_config_bascul[3][1] = vm_tampon_bascul.vm2_i
			tm_config_bascul[4][1] = vm_tampon_bascul.vr_i
			tm_config_bascul[5][1] = vm_tampon_bascul.bau
			tm_config_bascul[6][1] = vm_tampon_bascul.vl
			tm_config_bascul[7][1] = vm_tampon_bascul.vm1
			tm_config_bascul[8][1] = vm_tampon_bascul.vm2
			tm_config_bascul[9][1] = vm_tampon_bascul.vr
		}

		/*! dans le cas de travaux ou d'un basculement pour travaux, */
		/*! mettre a jour les configurations de voies en travaux */
		IF (va_Type_Fmc = XZAEC_FMC_Travaux) OR
		   (va_Type_Fmc = XZAEC_FMC_ZoneStockage) OR
		   (va_Type_Fmc = XZAEC_FMC_BasculTravaux)
		{
			tm_config_trv[0][1] = vm_tampon_trv.bau_i
			tm_config_trv[1][1] = vm_tampon_trv.vl_i
			tm_config_trv[2][1] = vm_tampon_trv.vm1_i
			tm_config_trv[3][1] = vm_tampon_trv.vm2_i
			tm_config_trv[4][1] = vm_tampon_trv.vr_i
			tm_config_trv[5][1] = vm_tampon_trv.bau
			tm_config_trv[6][1] = vm_tampon_trv.vl
			tm_config_trv[7][1] = vm_tampon_trv.vm1
			tm_config_trv[8][1] = vm_tampon_trv.vm2
			tm_config_trv[9][1] = vm_tampon_trv.vr
		}
	} ELSE {
		/* Collecter les donnees en interface IHM dans le tampon indique */

		/*! dans le cas d'un basculement ou d'un basculement pour travaux, */
		/*! recolter d'abord les configurations de voies pour basculement */
		IF (va_Type_Fmc = XZAEC_FMC_Basculement) OR (va_Type_Fmc = XZAEC_FMC_BasculTravaux) {
			vm_tampon_bascul.bau_i	= tm_config_bascul[0][1]
			vm_tampon_bascul.vl_i	= tm_config_bascul[1][1]
			vm_tampon_bascul.vm1_i	= tm_config_bascul[2][1]
			vm_tampon_bascul.vm2_i	= tm_config_bascul[3][1]
			vm_tampon_bascul.vr_i	= tm_config_bascul[4][1]
			vm_tampon_bascul.bau	= tm_config_bascul[5][1]
			vm_tampon_bascul.vl	= tm_config_bascul[6][1]
			vm_tampon_bascul.vm1	= tm_config_bascul[7][1]
			vm_tampon_bascul.vm2	= tm_config_bascul[8][1]
			vm_tampon_bascul.vr	= tm_config_bascul[9][1]
		}

		/*! dans le cas de travaux ou d'un basculement pour travaux, */
		/*! recolter d'abord les configurations de voies en travaux */
		IF (va_Type_Fmc = XZAEC_FMC_Travaux) OR
		   (va_Type_Fmc = XZAEC_FMC_ZoneStockage) OR
		   (va_Type_Fmc = XZAEC_FMC_BasculTravaux)
		{
			vm_tampon_trv.bau_i	= tm_config_trv[0][1]
			vm_tampon_trv.vl_i	= tm_config_trv[1][1]
			vm_tampon_trv.vm1_i	= tm_config_trv[2][1]
			vm_tampon_trv.vm2_i	= tm_config_trv[3][1]
			vm_tampon_trv.vr_i	= tm_config_trv[4][1]
			vm_tampon_trv.bau	= tm_config_trv[5][1]
			vm_tampon_trv.vl	= tm_config_trv[6][1]
			vm_tampon_trv.vm1	= tm_config_trv[7][1]
			vm_tampon_trv.vm2	= tm_config_trv[8][1]
			vm_tampon_trv.vr	= tm_config_trv[9][1]
		}
		CASE OF tm_types_fmc[vl_index].classe
			/*! pour un accident les vehicules sont egalement lus en base */
			CASE XZAEC_ClasseAccident
				va_Donnees = { vm_tampon_accident }

			CASE XZAEC_ClasseDelestage
				va_Donnees = { vm_tampon_delestage }

			CASE XZAEC_ClasseVehicule
				va_Donnees = { tm_vehicules[0] }

			CASE XZAEC_ClasseRegulation
				va_Donnees = { vm_tampon_regul }

			CASE XZAEC_ClasseVehLent
				va_Donnees = { vm_tampon_vhl }

			CASE XZAEC_ClasseMeteo
				va_Donnees = { vm_tampon_meteo }

			CASE XZAEC_ClasseEchangeur
				va_Donnees = { vm_tampon_echangeur }

			CASE XZAEC_ClasseSousConcess
				va_Donnees = { vm_tampon_sousconce }

			CASE XZAEC_ClasseManif
				va_Donnees = { vm_tampon_manif }

			CASE XZAEC_ClasseBouchon
				va_Donnees = { vm_tampon_bouchon }

			CASE XZAEC_ClassePosteOper
				va_Donnees = { vm_tampon_operateur }

			CASE XZAEC_ClasseNature
				va_Donnees = { vm_tampon_nature }

			CASE XZAEC_ClasseTravaux
				va_Donnees = { vm_tampon_trv }

			CASE XZAEC_ClasseBasculement
				va_Donnees = { vm_tampon_bascul }

			CASE XZAEC_ClasseBasculTrav
				va_Donnees = { vm_tampon_trv, vm_tampon_bascul }

			CASE XZAEC_ClasseIncendie
				va_Donnees = { vm_tampon_incendie }
		ENDCASE
	}

ENDMACRO






/*-----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Demande la reservation ou la restitution a tous
*  des droits d'enrichissement d'une FMC pour le poste opérateur appelant.
*
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO TMC_Reserver_Fmc (va_NumEvt, va_CleEvt, va_Reservation)

/*
* ARGUMENTS EN ENTREE :
*   va_NumEvt         : le numero de l'evenement ;
*   va_CleEvt         : la cle de l'evenement ;
*   va_Reservation    : indicateur vrai si reservation, faux pour restitution.
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR : COM_OK si les droits sont obtenus ou rendus, COM_NOK sinon.
*
*
* CONDITION D'UTILISATION
*  ITMA_TMC_Fiche_Main_Courante
*
* FONCTION
*   Appelle la procedure de reservation / restitution du droit d'enrichir
*    pour le poste operateur appelant, eventuellement surcharge.
*
-----------------------------------------------------------------------------*/

	VAR	FORMAT	SQL_Procedure_Params@	vl_parametres
	VAR	FORMAT	SQL_Procedure_Result@	vl_resultats
	VAR	vl_cr

	/* preparation des parametres de la requete */
	vl_parametres[0].type = SYB#INT4_
	vl_parametres[0].data = va_NumEvt
	vl_parametres[0].output = FALSE

	vl_parametres[1].type = SYB#INT1_
	vl_parametres[1].data = va_CleEvt
	vl_parametres[1].output = FALSE

	vl_parametres[2].type = SYB#INT2_
	IF (SYSTEM_VAR@ (vg_surcharge) = TRUE)
		vl_parametres[2].data = SYSTEM_VAR@ (vg_numero_poste_surcharge)
	ELSE
		vl_parametres[2].data = SYSTEM_VAR@ (vg_numero_poste)
	vl_parametres[2].output = FALSE

	vl_parametres[3].type = SYB#BIT_
	vl_parametres[3].data = va_Reservation
	vl_parametres[3].output = FALSE

	vl_parametres[4].type = SYB#BIT_
	vl_parametres[4].data = NULL
	vl_parametres[4].output = TRUE

	vl_parametres[5].type = SYB#CHAR_                               ' Site local
	vl_parametres[5].data = SYSTEM_VAR@(vg_nom_site)
	vl_parametres[5].output = FALSE

	vl_cr = COM05_SQL_Procedure (XZAE210_Reserver_FMC,
	                                vl_parametres, vl_resultats, C_MODULE)

	IF (vl_cr = XDC_OK)  AND  (vl_resultats.status = XDC_OK) {
		RETURN (COM_OK)
	} ELSE {
		/* La Fmc est reservee par un autre poste, sauf erreur SGBD */
		RETURN (COM_NOK)
	}
ENDMACRO






/*-----------------------------------------------------------------------------
* SERVICE RENDU :
* Acheve une FMC
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO TMC_Acheve_FMC()

/*
* ARGUMENTS EN ENTREE :
*   Aucun
*
* ARGUMENTS EN SORTIE :
*   Aucun
*
* CODE RETOUR :
*   COM_OK	la fiche est achevee, la saisie est terminee ;
*   COM_NOK	une condition d'erreur est rencontree, la fiche n'est pas achevee ;
*   COM_VALIDE	la fiche est achevee mais la saisie doit continuer.
*
* CONDITION D'UTILISATION
*   ITMA_TMC_Fiche_Main_Courante
*
* FONCTION
*   Verifie les conditions d'achevement de la fiche,
*   puis l'acheve avec les specificites relatives au type fmc.
*
-----------------------------------------------------------------------------*/
VAR vl_nb, vl_cr, tl_retour
VAR vl_nb_bg,vl_nb_morts
VAR vl_heure, vl_minute, vl_annee, vl_mois, vl_jour
VAR vl_jourMoisAnneeCourant, vl_jourMoisAnnee
VAR vl_indice
VAR FORMAT TMC_neutral tl_neutral

	vl_cr = COM_OK

	/* si la localisation de la queue est invalide alors */
	/* en informer l'operateur et continuer la saisie */
	IF (vm_local_ok <> TRUE)
	{
		INFO_MESSAGE@("Une localisation correcte doit d'abord être saisie")
		RETURN (COM_NOK)
	}


	/* si c'est un bouchon*/
	IF (vm_flag_bouchon=TRUE)
	{
		/* si on est enrichisseur ni de la tete ni de la queue ou alors enrichisseur des deux */
		IF ((vm_enrichir_tete=0) AND (vm_enrichir_queue=0)) OR
		((vm_enrichir_tete<>0) AND (vm_enrichir_queue<>0)) OR ( SYSTEM_VAR@ ( vg_datex ) = XDC_VRAI )
		{
			/* si la localisation de la tete est incorrecte */
			IF (vm_local_tete_ok=FALSE)
				/* en informer l'operateur et continuer la saisie*/
				INFO_MESSAGE@("Une localisation correcte de la tête doit d'abord être saisie")
			ELSE
			/* sinon si la date de fin reelle n'est pas renseignee */
			IF (vm_fiche.fin = NULL)
				/* en informer l'operateur et continuer la saisie*/
				INFO_MESSAGE@ ("Horodate de fin réelle non renseignée")
			ELSE
			/* Sinon tout est OK pour achever */
			{
				/* mettre a jour FMC initiale */
				IF TMC_Lier_FMC_Initiale() = COM_OK {
					/* declenche l'achevement de la fiche*/
					vl_cr=PEND_FOR_NEW_TASK@("ITMA_TMC_achever_bouchon",
							vm_fiche_queue,vm_fiche_tete)
					IF (vl_cr<>COM_OK)
						vl_cr=COM_NOK
				}
			}
		}
		ELSE
		/* sinon on ne peut pas achever et on l'annonce*/
		{
			INFO_MESSAGE@("Pas le droit d'achever la fiche")
			vl_cr = COM_NOK
		}
	}
	ELSE
	{
	
	    /* DEM1329 : Contrôle des conditions dans le cas d'une FMC accident */
	    IF (vm_fiche.type = XZAEC_FMC_Accident)
	    {
	      /* Météo, Visibilité, état chaussée  */
	      IF (DB_CTRL_GET_VALUE@(vm_fenetre,"BO_Cond_Meteo") = 0 OR
	          DB_CTRL_GET_VALUE@(vm_fenetre,"BO_Cond_Visibilite") = 0 OR
	          DB_CTRL_GET_VALUE@(vm_fenetre,"BO_Cond_Etat_Chaus") = 0/* OR
	          DB_CTRL_GET_VALUE@(vm_fenetre,"BO_Cond_Chantier") = 87*/)
	      {
	        INFO_MESSAGE@("Merci de renseigner toutes les conditions de l'accident (météo, visibilité, état de la chaussée, et présence chantier)")
		    vl_cr = COM_NOK
	      }
	    }
	
		/* verifier dans le cas d'une fmc accident que */
		/* le nombre de vehicules impliques est correct */
		/* avant d'achever dans le cas enrichisseur  */
		IF ((vm_fiche.type = XZAEC_FMC_Accident) AND 
			(vm_enrichir <> 0) AND
		    SYSTEM_VAR@ (vg_datex) <> XDC_VRAI)
		{
			vl_nb = DB_CTRL_GET_VALUE@(vm_fenetre,"BS_nb_motos")
			vl_nb = DB_CTRL_GET_VALUE@(vm_fenetre,"BS_nb_vl") + vl_nb
			vl_nb = DB_CTRL_GET_VALUE@(vm_fenetre,"BS_nb_pl") + vl_nb
			vl_nb = DB_CTRL_GET_VALUE@(vm_fenetre,"BS_nb_remorques") + vl_nb
			vl_nb = DB_CTRL_GET_VALUE@(vm_fenetre,"BS_nb_cars") + vl_nb
			vm_nb_vehicules = ITMA_TMC_compte_vehicules( vm_fiche.numero, vm_fiche.cle, XDC_DATE_NULLE)
			IF ((vm_nb_vehicules<> null) and (vm_nb_vehicules <> vl_nb))
			{
				INFO_MESSAGE@("Il n'y a pas le bon nombre de descriptions de véhicules.")
				vl_cr=COM_NOK
			}
		}

		/* verifier pour une fmc meteo que les conditions de conduite */
		/* ont toutes ete declarees  de retour a la normale */
		IF ((vm_fiche.type = XZAEC_FMC_Meteo) AND (vm_enrichir <> 0))
		{
			IF (ITMA_TMC_met_Retour_Normale (vm_fenetre) <> XDC_VRAI)
			{
				INFO_MESSAGE@ ("Les conditions de circulation doivent revenir a la normale")
				vl_cr = COM_NOK
			}
		}

		IF (vl_cr = COM_OK) 
		{
			/* si la date de fin reelle n'est pas renseignee */
			/* en informer l'operateur et continuer la saisie*/
			IF (vm_fiche.fin = NULL)
			{
				INFO_MESSAGE@ ("Horodate de fin réelle non renseignée")
				vl_cr = COM_NOK
			}
		}

		IF (vl_cr = COM_OK) 
		{
			/* verifier dans le cas d'une fmc accident */
			/* avec au moins 1 blesse grave ou un mort */
			/* que l'operateur a pense a prendre une photo de systeme */
			/* avant d'achever dans le cas enrichisseur  */
			vl_nb_bg = DB_CTRL_GET_VALUE@(vm_fenetre,"BS_nb_bg")
			vl_nb_morts = DB_CTRL_GET_VALUE@(vm_fenetre,"BS_nb_morts")

			IF ((vm_fiche.type = XZAEC_FMC_Accident) AND (vm_enrichir <> 0) AND ((vl_nb_bg > 0) OR (vl_nb_morts > 0)))
			{
				PEND_FOR_NEW_TASK@("ITMA_TCF_Demande_Confirmation",
							       "ATTENTION! AVEZ-VOUS PENSE A FAIRE UNE PHOTO DU SYSTEME ? ")                 
			}
		}

		/* declenche l'achevement de la fiche*/
		IF (vl_cr = COM_OK)
		{
			/* mettre a jour FMC initiale */
			IF TMC_Lier_FMC_Initiale() = COM_OK
			  vl_cr = PEND_FOR_NEW_TASK@("ITMA_TMC_achever_fiche", vm_fiche,tm_num_evt)
			else 
			  vl_cr = COM_NOK
		}

		/* si ca s'est bien passe*/
		IF (vl_cr = COM_OK)
		{
			/* si les travaux a achever sont discontinus alors */
			/* demander les dates des prochains trav. a creer  */
			/* uniquement sur le site de creation des travaux  */
			IF ((vm_fiche.type = XZAEC_FMC_Travaux) or
			    (vm_fiche.type = XZAEC_FMC_BasculTravaux)) and 
				(vm_enrichir<>0) AND 
				(vm_site=tm_num_evt.cle) AND 
				(vm_tampon_trv.continu = XDC_VRAI) AND 
				(IS_NULL@(vm_tampon_trv.fin_continu) <> TRUE) 
			{
			  /* rechercher le jour de planification des travaux*/
			  vl_jourMoisAnnee = COM23_Horodate(vm_fenetre, 
								                "BS_jf_trv",
								                "BS_mf_trv",
								                "BS_af_trv",
								                NULL, 
								                NULL)
			  /* rechercher le jour courant */
			  COM14_Valeurs_Horodate (COM09_Date_Courante(),
								      vl_jour, vl_mois, vl_annee,
								      vl_heure, vl_minute)
			  vl_jourMoisAnneeCourant = COM06_Date_Formatee( 
								vl_jour, vl_mois, vl_annee,
								" ", " ", NULL)

			  /* si les travaux discontinus ne se terminent pas */
			  /* ce jour courant alors demander les dates des   */
			  /* prochains travaux                              */
			  IF	(COM17_Difference_Dates (vl_jourMoisAnnee, vl_jourMoisAnneeCourant) > 0)
			  {
				tl_retour =  PEND_FOR_NEW_TASK@("ITMA_TMC_dates_trv_discont",
					                            COM18_Date_SGBD_Formatee(vm_tampon_trv.debut_continu),
					                            COM18_Date_SGBD_Formatee(vm_tampon_trv.fin_continu))
				
				/* reinitialiser les variables internes */
				IF NOT IS_NULL@(tl_retour) 
				{
					/*reinitialiser les horodates de neutralisation de voie*/
					tl_neutral=DB_TABLE_GET_DATA@(vm_fenetre,"TA_neutral_trv")
					for vl_indice=0 to (ARRAY_SIZE@(tl_neutral)-1)
					  tl_neutral[vl_indice].horodate_debut=null
					  tl_neutral[vl_indice].horodate_fin=null
					next vl_indice
					DB_TABLE_CLEAR_DATA@(vm_fenetre,"TA_neutral_trv",0,-1)
					DB_TABLE_SET_DATA@(vm_fenetre,"TA_neutral_trv", tl_neutral)
					ITMA_TMC_afficher_nouv_trv(vm_fenetre, 
										       vm_intitule, 
										       tl_retour[0],
										       tl_retour[1],
										       vm_etat_fmc)

					vm_mode_appel = MODE_CREATION
					tm_actions = NULL
					tm_comment = NULL

					/* la cause est les travaux actuels */
					/*vm_fiche.numero_cause = vm_fiche.numero
					vm_fiche.cle_cause = vm_fiche.cle*/

					vm_fiche.numero_cause = NULL
					vm_fiche.cle_cause = NULL

					/* pas de numero : il doit etre cree */
					vm_fiche.numero = NULL
					vm_fiche.cle = NULL
					tm_num_evt = NULL

					/* indiquer achevement ok ET continuation saisie */
					vl_cr=COM_VALIDE
				}
			   }
			}
		}
	}

 	RETURN (vl_cr)
ENDMACRO






/*-----------------------------------------------------------------------------
* SERVICE RENDU :
*  Effectue tous les controles de validite sur les valeurs saisies
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO TMC_Controle_Validite_FMC (va_avec_PA,
				    va_date_validation,
				    va_debut, va_debut_prevu, va_fin, va_fin_prevu,
				    va_localisation_valide)

/*
* ARGUMENTS EN ENTREE :
*  va_avec_PA         : indicateur de demande de calcul du plan d'action ;
*  va_date_validation : horodate de validation ;
*  va_debut           : horodate de debut Fmc saisie ;
*  va_debut_prevu     : horodate de debut prevue saisie ;
*  va_fin             : horodate de fin Fmc saisie ;
*  va_fin_prevu       : horodate de fin prevue saisie.
*
*
* ARGUMENTS EN SORTIE :
*  va_localisation_valide : Vrai ssi. la localisation est verifiee.
*
* CODE RETOUR :
*  XDC_OK si toutes les valeurs sont correctes, XDC_NOK en cas d'invalidite.
*
* CONDITION D'UTILISATION
*
*
*
* FONCTION
*   Verifier la validite de la localisation ;
*   verifier la validite des dates saisies ;
*   verifier la validite des donnees specifiques selon le type d'evenement.
*
-----------------------------------------------------------------------------*/
VAR vl_indice
VAR vl_trouve
VAR vl_sensT, vl_sensQ
	/*
	 * Verifier la validite de la localisation
	 * ---------------------------------------
	 */

	va_localisation_valide = FALSE

	IF ((vm_local_ok=FALSE AND (vm_fiche.autoroute=XDC_AUT_INCONNUE)
		AND IS_NULL@(vm_fiche.point_car)) OR
	     ( (vm_flag_bouchon=TRUE)AND (vm_local_tete_ok=FALSE) AND
		IS_NULL@(vm_fiche_tete.point_car) AND (vm_fiche_tete.autoroute=XDC_AUT_INCONNUE)))
	{
		INFO_MESSAGE@("Une localisation correcte doit d'abord être saisie")
		RETURN (XDC_NOK)
	}

	IF (vm_flag_bouchon=TRUE) AND (vm_multi=NULL)
	{
		vl_trouve=0
		vl_sensQ = vm_fiche.sens
		IF (vm_fiche.sens=XDC_SENS_SORTIE_NORD)  OR (vm_fiche.sens=XDC_SENS_ENTREE_NORD)
			vl_sensQ= XDC_SENS_NORD
		IF (vm_fiche.sens=XDC_SENS_SORTIE_SUD) OR (vm_fiche.sens=XDC_SENS_ENTREE_SUD)
			vl_sensQ= XDC_SENS_SUD
		vl_sensT = vm_fiche_tete.sens
		IF (vm_fiche_tete.sens=XDC_SENS_SORTIE_NORD)  OR (vm_fiche_tete.sens=XDC_SENS_ENTREE_NORD)
			vl_sensT = XDC_SENS_NORD
		IF (vm_fiche_tete.sens=XDC_SENS_SORTIE_SUD )  OR (vm_fiche_tete.sens=XDC_SENS_ENTREE_SUD)
			vl_sensT = XDC_SENS_SUD
		/*verifie a nouveau le multi autoroute si la local queue a change*/
		for vl_indice = 0 TO (ARRAY_SIZE@(tm_multi)-1)
                                if ((tm_multi[vl_indice].autoroute_queue= vm_fiche.autoroute) AND
                                        (tm_multi[vl_indice].sens_queue = vl_sensQ) AND
                                        (tm_multi[vl_indice].autoroute_tete = vm_fiche_tete.autoroute) AND
                                        (tm_multi[vl_indice].sens_tete = vl_sensT)) {
                                        vl_trouve=1
                                        vm_multi=tm_multi[vl_indice]
                                }
                        NEXT vl_indice

		if (vm_multi<>NULL) {
			if (TMC_check_PR_multi() = 1)
			  va_localisation_valide = TRUE
			else {
			   INFO_MESSAGE@("Les PR tete et queue ne sont pas compatibles")
			    RETURN (XDC_NOK)
			}
			goto POS_SUITE
		}

		IF (vm_fiche.autoroute<>vm_fiche_tete.autoroute) 
		{
			INFO_MESSAGE@("La localisation doit être sur une seule autoroute")
			RETURN (XDC_NOK)
		}
		ELSE IF (vm_fiche.sens = XDC_SENS_ENTREE_NORD OR
				vm_fiche.sens = XDC_SENS_ENTREE_SUD) AND
				(vm_fiche.sens <> vm_fiche_tete.sens OR
				vm_fiche.point_car <> vm_fiche_tete.point_car OR
				vm_fiche.nom_point_car <> vm_fiche_tete.nom_point_car) 
		{
			INFO_MESSAGE@("La queue et la tête de bouchon doivent être sur la même bretelle")
			RETURN (XDC_NOK)
		}
		ELSE IF (vm_fiche.sens = XDC_SENS_SORTIE_NORD OR
				vm_fiche.sens = XDC_SENS_SORTIE_SUD) AND
				(vm_fiche.sens <> vm_fiche_tete.sens OR
				vm_fiche.point_car <> vm_fiche_tete.point_car OR
				vm_fiche.nom_point_car <> vm_fiche_tete.nom_point_car)
		{
			INFO_MESSAGE@("La queue et la tête de bouchon doivent être sur la même bretelle")
			RETURN (XDC_NOK)
		}
		ELSE IF (vm_fiche.sens = XDC_SENS_NORD AND
				(vm_fiche_tete.sens <> XDC_SENS_SORTIE_NORD AND
				vm_fiche_tete.sens <> vm_fiche.sens))	OR
				(vm_fiche.sens = XDC_SENS_SUD AND
				(vm_fiche_tete.sens <> XDC_SENS_SORTIE_SUD AND
				vm_fiche_tete.sens <> vm_fiche.sens))
		{
			INFO_MESSAGE@("La queue étant sur section courante, la tête de bouchon doit être soit sur section courante, soit sur une bretelle de sortie")
			RETURN (XDC_NOK)
		}

		/* Verifier la coherence des Pr de tete et queue */
		IF (vm_multi=NULL) {
		IF (PEND_FOR_NEW_TASK@("ITMA_TMC_coherence_pr",
					vm_fiche.autoroute,
					vm_fiche_tete.pr,
					vm_fiche.pr,
					vm_fiche.sens) <> COM_OK)
			RETURN (XDC_NOK)
		}
	}
	ELSE IF (vm_flag_bouchon=TRUE) AND (vm_multi<>NULL)
		 {
			if (TMC_check_PR_multi() = 1)
			  va_localisation_valide = TRUE
			else {
			   INFO_MESSAGE@("Les PR tete et queue ne sont pas compatibles")
			    RETURN (XDC_NOK)
			}
			goto POS_SUITE
		}

POS_SUITE:
	/*
	 * Indiquer a l'appelant que la localisation est correcte
	 * ------------------------------------------------------
	 */

	va_localisation_valide = TRUE


	/*
	 * Verifier la validite des horodates saisies
	 * ------------------------------------------
	 */

	/* Si un plan d'action est demande, il faut au moins une des 2 dates de debut*/
	IF (va_avec_PA=TRUE)
	{
		IF (va_debut = null) AND (va_debut_prevu = null)
		{
			INFO_MESSAGE@("Les horodates de début ne peuvent être nulles toutes les deux")
			RETURN (XDC_NOK)
		}
	}

	/* debut doit etre inferieur a fin*/
	IF (va_fin<>null) AND (va_debut<>null)
	IF (COM17_Difference_Dates(va_fin,va_debut)<0)
	{
		INFO_MESSAGE@("L'horodate de fin doit être supérieure à l'horodate de début")
		RETURN (XDC_NOK)
	}

	/* debut prevu doit etre inferieur a fin prevue*/
	IF (va_fin_prevu<>null) AND (va_debut_prevu<>null)
	{
		IF (COM17_Difference_Dates(va_fin_prevu, va_debut_prevu)<0)
		{
			INFO_MESSAGE@("L'horodate de fin prévue doit être supérieure à l'horodate de début prévue")
			RETURN (XDC_NOK)
		}
	}

	/* La date de debut prevu doit etre supérieure a la date courante de 10h */
	/*  pour fmc travaux, zone de stockage, basculement pour travaux et convois */
	IF ( (vm_etat_fmc = XDC_FMC_ETAT_PREV) AND
		(vm_type_fmc = XZAEC_FMC_Travaux OR
		 vm_type_fmc = XZAEC_FMC_ZoneStockage OR
		 vm_type_fmc = XZAEC_FMC_BasculTravaux OR
		 vm_type_fmc = XZAEC_FMC_ConvoiExc OR
		 vm_type_fmc = XZAEC_FMC_ConvoiMil) )
	{
		IF (COM17_Difference_Dates(va_debut_prevu, va_date_validation) < 10 * 60) 
		{
			INFO_MESSAGE@("La date de début prévu doit laisser un délai d'au moins 10 heures")
			RETURN (XDC_NOK)
		}
	}


	/*
	 * Verifier la validite des donnees specifiques selon le type d'evenement
	 * ----------------------------------------------------------------------
	 */

	IF (vm_flag_bouchon=TRUE)
	{
		/* Pour un bouchon, verifier que la densite est saisie */
		IF (DB_CTRL_GET_VALUE@(vm_fenetre, "BO_typetrafic") < XZAEC_BOU_Dense)
		{
			INFO_MESSAGE@("La densité du bouchon n'est pas renseignée")
			RETURN (XDC_NOK)
		}
	}

	/* Pour un evenement sur echangeur, verifier la validite des acces saisis */
	IF (vm_type_fmc = XZAEC_FMC_FermetureEch) OR (vm_type_fmc = XZAEC_FMC_EchDeconseille)
	{
		IF	(DB_CTRL_GET_VALUE@(vm_fenetre,"BT_entree1")= FALSE) AND
			(DB_CTRL_GET_VALUE@(vm_fenetre,"BT_entree2")= FALSE) AND
			(DB_CTRL_GET_VALUE@(vm_fenetre,"BT_sortie1")= FALSE) AND
			(DB_CTRL_GET_VALUE@(vm_fenetre,"BT_sortie2")= FALSE) 
		{
			INFO_MESSAGE@("Renseigner au moins un accès")
			RETURN (XDC_NOK)
		}
	}

	/* Pour un Basculement pour travaux terminé, forcer l'absence de bouchon mobile */
	IF (vm_type_fmc = XZAEC_FMC_BasculTravaux)  AND  (va_fin <> NULL) {
		DB_CTRL_VALUE@ (vm_fenetre, "BT_bouchon", FALSE)
	}

	RETURN (XDC_OK)
ENDMACRO






/*-----------------------------------------------------------------------------
* SERVICE RENDU :
* Valide une FMC
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO TMC_Valide_FMC(va_avec_PA)

/*
* ARGUMENTS EN ENTREE :
* va_avec_PA : true=>valide+calcul plan d'actions.   false=>valide sans PA
*
*
* ARGUMENTS EN SORTIE :
* Aucun
*
* CODE RETOUR :
*  XDC_OK si toutes la fiche est validee, un code d'erreur sinon.
*
* CONDITION D'UTILISATION
*
*
* FONCTION
*   Effectue les controles de validite des valeurs saisies ;
*   ecrit ensuite en base les donnees specifiques de la fiche ;
*   ecrit en base de donnees la partie generique de la fiche ;
*   met enfin a jour les donnees affichees selon que tout est correct ou non.
*
-----------------------------------------------------------------------------*/
VAR vl_date_validation
VAR vl_date_debut, vl_date_debut_prevu, vl_date_fin, vl_date_fin_prevu
VAR FORMAT TMC_comment	vl_comment	/* commentaire a la creation de la fmc */
VAR vl_longueur				/* Longueur associee si basculement, meteo, travaux */
VAR vl_enrichir_tete, vl_enrichir_queue

VAR vl_localisation_valide,vl_cr2
VAR vl_macro_specifique			/*racine des noms de macros specifiques au type Fmc*/
VAR vl_nom_macro			/*nom de macro a executer*/
VAR tl_tampon_specifique		/* tampon temporaire des donnees specifiques au type */
VAR FORMAT TMC_fmc	vl_fiche_MC
VAR tl_retour, vl_cr, vl_indice
VAR tl_retour_multi

	/* Determiner la macro de traitement des donnees specifiques au type de Fmc */
	vl_indice = COM45_IndexEnColonne (tm_types_fmc, TDO_NUMERO_FMC, vm_type_fmc)
	vl_macro_specifique = tm_macro_specifique[vl_indice]

	ITMA_TMC_enrichir()

	/* Recuperer les horodates saisies et les formater */
	vl_date_debut=COM23_Horodate(vm_fenetre,
					"BS_jour_debut_reel",
					"BS_mois_debut_reel",
					"BS_annee_debut_reel",
					"BS_heure_debut_reel",
					"BS_minute_debut_reel",
					"BS_seconde_debut_reel")

	vl_date_debut_prevu=COM23_Horodate(vm_fenetre,
						"BS_jour_debut_prevu",
						"BS_mois_debut_prevu",
						"BS_annee_debut_prevu",
						"BS_heure_debut_prevu",
						"BS_minute_debut_prevu")

	vl_date_fin=COM23_Horodate(vm_fenetre,
					"BS_jour_fin_reelle",
					"BS_mois_fin_reelle",
					"BS_annee_fin_reelle",
					"BS_heure_fin_reelle",
					"BS_minute_fin_reelle",
					"BS_seconde_fin_reelle")

	vl_date_fin_prevu=COM23_Horodate(vm_fenetre,
						"BS_jour_fin_prevue",
						"BS_mois_fin_prevue",
						"BS_annee_fin_prevue",
						"BS_heure_fin_prevue",
						"BS_minute_fin_prevue")


	/* Lire l'horodate courante et la formater */
	vl_date_validation=COM09_Date_Courante(TRUE)


	/* Effectuer les controles de validite */
	vl_cr = TMC_Controle_Validite_FMC (va_avec_PA,
	                                      vl_date_validation,
	                                      vl_date_debut,
	                                      vl_date_debut_prevu,
	                                      vl_date_fin,
	                                      vl_date_fin_prevu,
	                                      vl_localisation_valide)

	/* si la localisation est correcte, repositionner les indicateurs */
	IF (vl_localisation_valide = TRUE)
	{
		vm_local_ok=TRUE
		IF vm_flag_bouchon=TRUE
		{
			vm_local_tete_ok=TRUE
		}
	}


	/* si les donnees generales sont valides */
	IF (vl_cr = XDC_OK)
	{
		/* collecter les donnees specifiques au type de Fmc */
		TMC_Donnees_Specifiques (vm_type_fmc, tl_tampon_specifique, FALSE)
		/* completer avec les valeurs saisies et effectuer les controles de validite */
		vl_nom_macro = vl_macro_specifique ++ "_saisie"
		vl_cr = !vl_nom_macro (vm_fenetre, tl_tampon_specifique[0], tl_tampon_specifique[1])
		IF (vl_cr = XDC_OK)
		{
			vl_nom_macro = vl_macro_specifique ++ "_controle"
			vl_cr = !vl_nom_macro (vm_fiche, tl_tampon_specifique[0], vm_fenetre, tl_tampon_specifique[1])
		}
	}


	/* si la fiche est valide */
	IF (vl_cr = XDC_OK)
	{
		/* memoriser les dates saisies */
		vm_fiche.debut = vl_date_debut
		vm_fiche.debut_prevu = vl_date_debut_prevu
		vm_fiche.fin = vl_date_fin
		vm_fiche.fin_prevu = vl_date_fin_prevu

		/* recuperer les commentaires de la fmc init en mode degrade */
		IF (vm_fiche.degrade = XDC_OUI)
		{
			vm_fiche.com_fmc_init = DB_CTRL_GET_VALUE@(vm_fenetre, "BS_Com_FMC_Init")	
			IF (vm_flag_bouchon=TRUE)
			{
				vm_fiche_tete.com_fmc_init = vm_fiche.com_fmc_init	
				vm_fiche_queue.com_fmc_init = vm_fiche.com_fmc_init	
			}
		}

		/* Si c'est une fausse alerte alors positionner une date */
		/* de fin si non valuee */
		IF vm_fiche.fin = NULL AND(vm_fiche.fausse_alerte = XDC_VRAI)
		{
			vm_fiche.fin=vl_date_validation
			COM24_Afficher_Horodate(vl_date_validation, vm_fenetre,
			                           "BS_jour_fin_reelle",
			                           "BS_mois_fin_reelle",
			                           "BS_annee_fin_reelle",
			                           "BS_heure_fin_reelle",
			                           "BS_minute_fin_reelle",
			                           "BS_seconde_fin_reelle")
		}

		/* recupere origine si elle est affichee*/
		IF (DB_CTRL_GET_DISPLAY@(vm_fenetre,"BS_origine")=TRUE)
		{
			/* concatener le libelle d'origine predefini et le texte libre */
			vl_indice = DB_CTRL_GET_VALUE@ (vm_fenetre, "BO_Origine")
			IF (vl_indice >= 0) {
				vm_fiche.origine = tm_choix_origine[vl_indice].libelle
			} ELSE {
				vm_fiche.origine = ""
			}
			vm_fiche.origine = vm_fiche.origine ++ " " ++
			                      TRIM@ (DB_CTRL_GET_VALUE@(vm_fenetre, "BS_origine"))
			/* Tronquer si necessaire l'origine a sa longueur maximale */
			vm_fiche.origine = TRIM@ (SUBSTRING@ (vm_fiche.origine, 1, 25))
		}

		/* recupere longueur s'il est affiche*/
		IF (DB_CTRL_GET_DISPLAY@(vm_fenetre,"BS_Longueur")=TRUE)
			vm_fiche.longueur=DB_CTRL_GET_VALUE@(vm_fenetre, "BS_Longueur")

		/* recupere degats domaine s'il est affiche*/
		IF (DB_CTRL_GET_DISPLAY@(vm_fenetre,"BT_degats")=TRUE)
			vm_fiche.degatsdom=TRUE*DB_CTRL_GET_VALUE@(vm_fenetre, "BT_degats")

		/* recupere l'indicateur d'ecoulement s'il est affiche*/
		IF (DB_CTRL_GET_DISPLAY@(vm_fenetre,"BA_Ecoulement")=TRUE)
			vm_fiche.ecoulement=TRUE*DB_CTRL_GET_VALUE@(vm_fenetre, "BA_Ecoulement")

		/* gestion du sens pour une fmc de type fermeture echangeur */
		IF (vm_fiche.type = XZAEC_FMC_FermetureEch) OR (vm_fiche.type = XZAEC_FMC_EchDeconseille)
		{
			if 	(DB_CTRL_GET_VALUE@(vm_fenetre,"BT_entree1")=FALSE) AND
				(DB_CTRL_GET_VALUE@(vm_fenetre,"BT_sortie1")=FALSE) AND
				(DB_CTRL_GET_VALUE@(vm_fenetre,"BT_entree2")=FALSE)
				vm_fiche.sens=XDC_SENS_SORTIE_NORD
			else if (DB_CTRL_GET_VALUE@(vm_fenetre,"BT_entree1")=FALSE) AND
				(DB_CTRL_GET_VALUE@(vm_fenetre,"BT_sortie1")=FALSE) AND     
				(DB_CTRL_GET_VALUE@(vm_fenetre,"BT_sortie2")=FALSE)
				vm_fiche.sens=XDC_SENS_ENTREE_NORD
			else if (DB_CTRL_GET_VALUE@(vm_fenetre,"BT_entree1")=FALSE) AND
				(DB_CTRL_GET_VALUE@(vm_fenetre,"BT_sortie1")=FALSE)
				vm_fiche.sens=XDC_SENS_NORD
			else if (DB_CTRL_GET_VALUE@(vm_fenetre,"BT_entree2")=FALSE) AND
				(DB_CTRL_GET_VALUE@(vm_fenetre,"BT_sortie2")=FALSE) AND
				(DB_CTRL_GET_VALUE@(vm_fenetre,"BT_entree1")=FALSE)
				vm_fiche.sens=XDC_SENS_SORTIE_SUD
			else if (DB_CTRL_GET_VALUE@(vm_fenetre,"BT_entree2")=FALSE) AND     
				(DB_CTRL_GET_VALUE@(vm_fenetre,"BT_sortie2")=FALSE) AND
				(DB_CTRL_GET_VALUE@(vm_fenetre,"BT_sortie1")=FALSE)
				vm_fiche.sens=XDC_SENS_ENTREE_SUD
			else if (DB_CTRL_GET_VALUE@(vm_fenetre,"BT_entree2")=FALSE) AND    
				(DB_CTRL_GET_VALUE@(vm_fenetre,"BT_sortie2")=FALSE)
				vm_fiche.sens=XDC_SENS_SUD
			else
				vm_fiche.sens=XDC_SENS_INCONNU
		}


		/*! si c'est un bouchon*/
		IF (vm_mode_appel = MODE_CREATION)
		{
			/*! si c'est un bouchon*/
			IF (vm_flag_bouchon = TRUE)
			{
				/*! je cree les fiches tetes et queue de bouchon*/
				tl_retour=PEND_FOR_NEW_TASK@("ITMA_TMC_creer_bouchon",
										vm_fiche.debut,
										vm_fiche.debut_prevu,
										vm_fiche.degrade)

				if (vm_multi<>NULL) {
					 /*! je cree les fiches tetes et queue de bouchon */
					 /* pour la seconde autoroute*/
				tl_retour_multi = PEND_FOR_NEW_TASK@("ITMA_TMC_creer_bouchon",
							vm_fiche.debut,
							vm_fiche.debut_prevu,
							vm_fiche.degrade)
					tm_num_tete2 = tl_retour_multi[1]
					tm_num_queue2 = tl_retour_multi[2]

				}
				/*! recupere les arguments*/
				IF (tl_retour[0]<>COM_OK)
				{
					INFO_MESSAGE@("Impossible de créer la fiche bouchon")
					vl_cr = XDC_NOK
					goto POS_ERR
				}
				ELSE
				{
					/*! recupere les fiches creees*/
					tm_num_tete=tl_retour[1]
					tm_num_queue=tl_retour[2]

					vm_fiche_tete.numero=tm_num_tete.numero
					vm_fiche_tete.cle=tm_num_tete.cle
					vm_fiche_queue.numero=tm_num_queue.numero
					vm_fiche_queue.cle=tm_num_queue.cle
					vm_fiche_queue.type=XZAEC_FMC_QueueBouchon
					vm_fiche_tete.type=XZAEC_FMC_TeteBouchon

					/*! on force la var vm_fiche a la queue de bouchon*/
					vm_fiche.numero=vm_fiche_queue.numero
					vm_fiche.cle=vm_fiche_queue.cle
					vm_fiche.type=XZAEC_FMC_QueueBouchon
					tm_num_evt=tm_num_queue

					/*! la tete est la cause de la queue*/
					vm_fiche_queue.numero_cause=vm_fiche_tete.numero
					vm_fiche_queue.cle_cause=vm_fiche_tete.cle

					if (vm_multi<>NULL) {
						vm_fiche_tete.numero=tm_num_tete.numero
						vm_fiche_tete.cle=tm_num_tete.cle

						vm_fiche_queue_inter = vm_fiche_tete /* pour recup config voies*/
						vm_fiche_queue_inter.numero = tm_num_queue2.numero
						vm_fiche_queue_inter.cle= tm_num_queue2.cle
						vm_fiche_queue_inter.type=XZAEC_FMC_QueueBouchon
						vm_fiche_queue_inter.autoroute = vm_multi.autoroute_queue_inter
						vm_fiche_queue_inter.PR=vm_multi.pr_queue_inter
						vm_fiche_queue_inter.sens = vm_multi.sens_queue_inter
						vm_fiche_queue_inter.origine = vm_fiche.origine
						vm_fiche_queue_inter.debut = vm_fiche.debut
						vm_fiche_queue_inter.debut_prevu = vm_fiche.debut_prevu
						vm_fiche_queue_inter.fin = vm_fiche.fin
						vm_fiche_queue_inter.fin_prevu = vm_fiche.fin_prevu
						vm_fiche_queue_inter.origine = vm_fiche.origine
						vm_fiche_queue_inter.confirme = vm_fiche.confirme
						vm_fiche_queue_inter.nom_point_car = 0
						vm_fiche_queue_inter.point_car = 0
						vm_fiche_tete_inter = vm_fiche  /* pour recup config voies*/
						vm_fiche_tete_inter.numero=tm_num_tete2.numero
						vm_fiche_tete_inter.cle = tm_num_tete2.cle
						vm_fiche_tete_inter.type=XZAEC_FMC_TeteBouchon
						vm_fiche_tete_inter.autoroute = vm_multi.autoroute_tete_inter
						vm_fiche_tete_inter.sens=vm_multi.sens_tete_inter
						vm_fiche_tete_inter.pr=vm_multi.pr_tete_inter
						vm_fiche_tete_inter.confirme = vm_fiche.confirme

						/*tete est la cause de la queue inter*/
						vm_fiche_queue_inter.numero_cause=
								tm_num_tete.numero
						vm_fiche_queue_inter.cle_cause=
								tm_num_tete.cle
					
						/* tete inter est la cause de la queue*/
						vm_fiche_queue.numero_cause=
						                        vm_fiche_tete_inter.numero
						vm_fiche_queue.cle_cause = vm_fiche_tete_inter.cle

						vm_fiche.numero_cause=vm_fiche_queue.numero_cause
						vm_fiche.cle_cause = vm_fiche_queue.cle_cause

						/*queue inter est la cause de tete inter*/
						vm_fiche_tete_inter.numero_cause=
								vm_fiche_queue_inter.numero
						vm_fiche_tete_inter.cle_cause=
								vm_fiche_queue_inter.cle
					}
				}
			}
			ELSE
			{
				/*! sinon je cree la fiche main courante*/
				tl_retour=PEND_FOR_NEW_TASK@ ("ITMA_TMC_creer_fiche",
				                                 vm_type_fmc,
				                                 vm_etat_fmc,
				                                 vm_fiche.debut,
				                                 vm_fiche.debut_prevu,
				                                 SYSTEM_VAR@(vg_site),			' Toujours null a la creation
				                                 vm_fiche.degrade)

				IF tl_retour[0]=COM_OK
				{
					tm_num_evt=tl_retour[1]
					vm_fiche.numero=tm_num_evt.numero
					vm_fiche.cle=tm_num_evt.cle
					vm_fiche.type=vm_type_fmc
					tm_vehicules[0].num_fiche_appel = tl_retour[1][2]
				}
				ELSE
				{
					INFO_MESSAGE@("Impossible de créer la fiche main courante")
					vl_cr = XDC_NOK
					goto POS_ERR
				}
			}
		}
		else {
			if (vm_multi<>NULL) {
				/*ma FMC passe sur 2 autoroutes, je dois creer un autre bouchon*/
				tl_retour_multi = PEND_FOR_NEW_TASK@("ITMA_TMC_creer_bouchon",
							vm_fiche.debut,
							vm_fiche.debut_prevu,
							vm_fiche.degrade)
					tm_num_tete2 = tl_retour_multi[1]
					tm_num_queue2 = tl_retour_multi[2]
					tm_num_tete.numero = vm_fiche_tete.numero
					tm_num_tete.cle = vm_fiche_tete.cle
				vm_fiche_tete.numero=tm_num_tete.numero
						vm_fiche_tete.cle=tm_num_tete.cle

						/**********/

						vm_fiche_queue_inter = vm_fiche /* pour recup config voies*/
						vm_fiche_queue_inter.numero = tm_num_queue2.numero
						vm_fiche_queue_inter.cle= tm_num_queue2.cle
						vm_fiche_queue_inter.numero_cause=
								tm_num_tete2.numero
						vm_fiche_queue_inter.cle_cause=
								tm_num_tete2.cle
						/***********/

						/* OBSOLETE
						vm_fiche_queue_inter = vm_fiche_tete 
						vm_fiche_queue_inter.numero = tm_num_queue2.numero
						vm_fiche_queue_inter.cle= tm_num_queue2.cle
						vm_fiche_queue_inter.type=XZAEC_FMC_QueueBouchon
						vm_fiche_queue_inter.autoroute = vm_multi.autoroute_queue_inter
						vm_fiche_queue_inter.PR=vm_multi.pr_queue_inter
						vm_fiche_queue_inter.sens = vm_multi.sens_queue_inter
						vm_fiche_queue_inter.origine = vm_fiche.origine
						 FIN OBSOLETE*/
						
						/*OBSOLETE
						vm_fiche_queue_inter.debut = vm_fiche.debut
						vm_fiche_queue_inter.debut_prevu = vm_fiche.debut_prevu
						vm_fiche_queue_inter.fin = vm_fiche.fin
						vm_fiche_queue_inter.fin_prevu = vm_fiche.fin_prevu
						vm_fiche_queue_inter.origine = vm_fiche.origine
						vm_fiche_queue_inter.confirme = vm_fiche.confirme
						vm_fiche_queue_inter.nom_point_car = 0
						vm_fiche_queue_inter.point_car = 0
						FIN OBSOLETE */

						vm_fiche_tete_inter = vm_fiche  /* pour recup config voies*/
						vm_fiche_tete_inter.numero=tm_num_tete2.numero
						vm_fiche_tete_inter.cle = tm_num_tete2.cle
						vm_fiche_tete_inter.type=XZAEC_FMC_TeteBouchon
						vm_fiche_tete_inter.autoroute = vm_multi.autoroute_tete_inter
						vm_fiche_tete_inter.sens=vm_multi.sens_tete_inter
						vm_fiche_tete_inter.pr=vm_multi.pr_tete_inter
						vm_fiche_tete_inter.confirme = vm_fiche.confirme

						vm_fiche.autoroute = vm_multi.autoroute_queue_inter
						vm_fiche.PR=vm_multi.pr_queue_inter
						vm_fiche.sens = vm_multi.sens_queue_inter

						/*OBSOLETE
						vm_fiche_queue_inter.numero_cause=
								tm_num_tete.numero
						vm_fiche_queue_inter.cle_cause=
								tm_num_tete.cle
						FIN OBSOLETE */

						/* tete inter est la cause de la queue*/
						/*OBSOLETE
						vm_fiche_queue.numero_cause=
						                        vm_fiche_tete_inter.numero
						vm_fiche_queue.cle_cause = vm_fiche_tete_inter.cle

						vm_fiche.numero_cause=vm_fiche_queue.numero_cause
						vm_fiche.cle_cause = vm_fiche_queue.cle_cause
						FIN OBSOLETE*/

						/*queue inter est la cause de tete inter*/
						/* OBSOLETE
						vm_fiche_tete_inter.numero_cause=
								vm_fiche_queue_inter.numero
						vm_fiche_tete_inter.cle_cause=
								vm_fiche_queue_inter.cle
						FIN OBSOLETE*/

						vm_fiche_queue.numero_cause = vm_fiche_tete.numero
						vm_fiche_queue.cle_cause = vm_fiche_tete.cle
						vm_fiche.numero_cause=vm_fiche_queue.numero_cause
						vm_fiche.cle_cause = vm_fiche_queue.cle_cause
						/*tete inter a pour cause la Queue*/
						vm_fiche_tete_inter.numero_cause=
								vm_fiche.numero
						vm_fiche_tete_inter.cle_cause=
								vm_fiche.cle
			}

		}

		/* si mode creation*/
		IF (vm_mode_appel=MODE_CREATION)
		{
			/* affiche le libelle de la fiche*/
			vm_intitule = TMC_libelle_fiche (vm_fiche)
			DB_CTRL_TITLE@(vm_fenetre, "LI_intitulé_fmc", vm_intitule)
		}

		/* si mode creation*/
		IF (vm_mode_appel=MODE_CREATION)
		{
			/* je peux maintenant sauver les commentaires*/
			FOR vl_indice=0 TO (ARRAY_SIZE@(tm_comment)-1)
				/* Ne pas donner de numero de commentaires en creation */
				vl_comment = tm_comment[vl_indice]
				vl_comment.numero = NULL
				ITMA_TMC_valide_comment(vl_comment,vl_date_validation,tm_num_evt)
			NEXT vl_indice
			
			/* affiche la liste des commentaires*/
			ITMA_TMC_formater_date_comment()
			ITMA_TMC_affiche_comment()
		}

	if (vm_appelant="MTLL") {
		vl_cr2[0]=COM_OK
		vl_cr2[1]=tm_num_evt.numero
		vl_cr2[2]=tm_num_evt.cle
		DB_SEND_POKE@(COM_CANAL_COMMU,vl_cr2)
	}

		IF (vm_mode_appel=MODE_CREATION)
			/*! je valorise son horodate de validation*/
			vm_fiche.validation=vl_date_validation

		/*si je cree la fiche depuis un evt strada*/
		if (vm_mode_appel=MODE_CREATION) AND (vm_appelant = "MTES") {
			TMC_archive_synthese_strada(vm_fiche.numero,
						    vm_fiche.cle,
						    vm_reference_strada)
		}


		/* la fiche a ete creee, on passe en mode Modification */
		vm_mode_appel=MODE_MODIF


		/* en cas de retypage, preparer l'ecriture des donnees specifiques */
		/* correspondant au nouveau type par modification des tables adequates */
		IF (vm_type_fmc <> vm_fiche.type) {
			vl_cr = TMC_Nouveau_Type_FMC (vm_fiche.numero, vm_fiche.cle, vm_etat_fmc, vm_type_fmc)
			IF (vl_cr <> XDC_OK)
				goto POS_ERR
		}


		/*! si etat prevision ou clos*/
		IF (vm_etat_fmc=XDC_FMC_ETAT_PREV) OR (vm_etat_fmc=XDC_FMC_ETAT_CLOS) {
			/*! je recupere son horodate de validation*/
			/*! (NON NULLE : en creation FMC en prevision elle vaut l'heure courante) */
			vl_date_validation = COM18_Date_SGBD_Formatee (vm_fiche.validation)
		}

		/* écrire en base les données spécifiques au type FMC */
		IF (vm_flag_bouchon=TRUE)
		{
			/*! la cause de la tete est celle de la fiche generique*/
			if (vm_multi=NULL) {
			vm_fiche_tete.numero_cause=vm_fiche.numero_cause
			vm_fiche_tete.cle_cause=vm_fiche.cle_cause
			}

			vl_enrichir_tete = 0
/* Modif SAGA */
/*************			IF (SYSTEM_VAR@ (vg_datex_propriete) <> XDC_FAUX) {        
				vl_enrichir_tete = vm_enrichir_tete
			}
			vl_enrichir_queue = 0
			IF (SYSTEM_VAR@ (vg_datex_propriete) <> XDC_FAUX) {        
				vl_enrichir_queue = vm_enrichir_queue
			}
*************/
			vl_enrichir_tete = vm_enrichir_tete
			vl_enrichir_queue = vm_enrichir_queue

			/*! lance la macro specifique au bouchon*/
			/*! i.e. sauve la tete*/
			/*si multi sauvegarder la tete intermediaire*/
			if (vm_multi<>NULL) {
			vm_fiche_tete_inter.bau=vm_fiche_queue.bau
			vm_fiche_tete_inter.vr=vm_fiche_queue.vr
			vm_fiche_tete_inter.vm1=vm_fiche_queue.vm1
			vm_fiche_tete_inter.vm2=vm_fiche_queue.vm2
			vm_fiche_tete_inter.vl=vm_fiche_queue.vl
			vm_fiche_tete_inter.bau_i=vm_fiche_queue.bau_i
			vm_fiche_tete_inter.vr_i=vm_fiche_queue.vr_i
			vm_fiche_tete_inter.vm1_i=vm_fiche_queue.vm1_i
			vm_fiche_tete_inter.vm2_i=vm_fiche_queue.vm2_i
			vm_fiche_tete_inter.vl_i=vm_fiche_queue.vl_i
				PEND_FOR_NEW_TASK@("ITMA_TMC_valide_comp_bouchon",
						vm_fiche,
						vm_fiche_tete_inter,
						tl_tampon_specifique[0],
						vm_etat_fmc,
						vl_date_validation,
						vm_fenetre,
						XDC_VRAI,
						XDC_VRAI,
						tm_config_tete, /*config tete inter ??*/ /*TODO*/
						ABS@(vm_fiche.pr-vm_fiche_tete_inter.pr))

			vl_cr=PEND_FOR_NEW_TASK@("ITMA_TMC_valide_comp_bouchon",
							vm_fiche_queue_inter,
							vm_fiche_tete,
							tl_tampon_specifique[0],
							vm_etat_fmc,
							vl_date_validation,
							vm_fenetre,
							vl_enrichir_tete,
							vl_enrichir_queue,
							tm_config_tete,
							ABS@(vm_fiche_queue_inter.pr-vm_fiche_tete.pr))
			}
			else {
				vl_cr=PEND_FOR_NEW_TASK@("ITMA_TMC_valide_comp_bouchon",
							vm_fiche,
							vm_fiche_tete,
							tl_tampon_specifique[0],
							vm_etat_fmc,
							vl_date_validation,
							vm_fenetre,
							vl_enrichir_tete,
							vl_enrichir_queue,
							tm_config_tete,
							vm_tampon_bouchon.longueur)

			}
		} ELSE {
			/* sauver le tampon de donnees specifique a l'evenement */
			vl_nom_macro = vl_macro_specifique ++ "_sauve"
			vl_cr = !vl_nom_macro (tm_num_evt, tl_tampon_specifique[0],
						vm_etat_fmc, vl_date_validation, vm_fenetre,
						vm_fiche.autoroute, vm_fiche.pr, vm_fiche.sens,
						tl_tampon_specifique[1])

		}
		IF (vl_cr <> COM_OK) {
			vl_cr = XDC_NOK
			goto POS_ERR
		}

		/* si les donnees specifiques sont valides alors en conserver une copie */
		/* et reafficher les donnees calculees */
		/*! utile seulement pour maj. des donnees NON HISTORISEES (pour fax) */
		/*! car si la validation va jusqu'a son terme les donnees sont relues */
		/*IF (vl_cr = COM_OK) {
			tm_donnees_specifiques = tl_tampon_specifique
			TMC_Donnees_Specifiques (vm_type_fmc, tl_tampon_specifique, TRUE)

			vl_nom_macro = vl_macro_specifique ++ "_affiche"
			!vl_nom_macro (vm_fenetre, tl_tampon_specifique[0], tl_tampon_specifique[1], vm_type_fmc)
		}*/


		/*! si c'est un bouchon on sauve la queue du bouchon */
		IF ((vm_flag_bouchon=TRUE) AND (vm_enrichir_queue<>0))
		{
			if (vm_multi<>NULL) {
			/*sauvegarde Queue intermediaire*/
			vl_cr=PEND_FOR_NEW_TASK@("ITMA_TMC_valide_bouchon",
					vl_date_validation,
					vm_fiche_queue_inter,
					vm_etat_fmc,
					ABS@(vm_fiche_queue_inter.PR -vm_fiche_tete.pr),
					tm_config)

			IF (vl_cr<>COM_OK) {

				vl_cr = XDC_NOK
				goto POS_ERR
			}
			}
			/*! la config des voies est celle de la queue */
			vm_fiche.bau=vm_fiche_queue.bau
			vm_fiche.vr=vm_fiche_queue.vr
			vm_fiche.vm1=vm_fiche_queue.vm1
			vm_fiche.vm2=vm_fiche_queue.vm2
			vm_fiche.vl=vm_fiche_queue.vl
			vm_fiche.bau_i=vm_fiche_queue.bau_i
			vm_fiche.vr_i=vm_fiche_queue.vr_i
			vm_fiche.vm1_i=vm_fiche_queue.vm1_i
			vm_fiche.vm2_i=vm_fiche_queue.vm2_i
			vm_fiche.vl_i=vm_fiche_queue.vl_i

			/* calcule la longueur du bouchon d'apres les PR de tete et queue */
			vl_longueur=ABS@(vm_fiche.pr-vm_fiche_tete.pr)
			vm_fiche.longueur=vm_tampon_bouchon.longueur

			/*! la cause de la queue a la valeur de la tete*/
			if (vm_multi=NULL) {
			vl_fiche_MC = vm_fiche
			vl_fiche_MC.numero_cause=vm_fiche_tete.numero
			vl_fiche_MC.cle_cause=vm_fiche_tete.cle
			}
			else
				vl_fiche_MC = vm_fiche

			/*! sauve la partie commune du bouchon i.e. la queue*/
			vl_cr=PEND_FOR_NEW_TASK@("ITMA_TMC_valide_bouchon",
							vl_date_validation,
							vl_fiche_MC,
							vm_etat_fmc,
							vm_tampon_bouchon.longueur,
							tm_config)

			IF (vl_cr<>COM_OK) {
				vl_cr = XDC_NOK
				goto POS_ERR
			}
		}


		/* sinon on sauve la partie commune de la fiche*/
		IF (vm_flag_bouchon=FALSE)
		{
			CASE OF vm_type_fmc
			CASE XZAEC_FMC_Basculement
				vl_longueur = ABS@(vm_fiche.pr -
				DB_CTRL_GET_VALUE@(vm_fenetre,"BS_pr_bascul")*1000)
			CASE XZAEC_FMC_Meteo
			CASE XZAEC_FMC_ChausseeGliss, XZAEC_FMC_TraitChaussees
				vl_longueur = ABS@(vm_fiche.pr -
					DB_CTRL_GET_VALUE@(vm_fenetre,"BS_prmet")*1000)
			CASE XZAEC_FMC_Travaux, XZAEC_FMC_ZoneStockage, XZAEC_FMC_BasculTravaux
				vl_longueur = ABS@(vm_fiche.pr -
				DB_CTRL_GET_VALUE@(vm_fenetre,"BS_prtetetrv")*1000)
			DEFAULT
				vl_longueur = 0
			ENDCASE
			vl_cr=PEND_FOR_NEW_TASK@("ITMA_TMC_valide",
						vl_date_validation,
						vm_fiche,
						vm_etat_fmc,
						tm_config,
						tm_comment,
						vl_longueur,
						vm_type_fmc)

			IF (vl_cr<>COM_OK) {
				vl_cr = XDC_NOK
				goto POS_ERR
			}

			/* reinitialisation du type en cas de retypage a la validation */
			vm_fiche.type_precedent = vm_fiche.type
			IF (vm_type_fmc <> vm_fiche.type) {
				vm_fiche.type = vm_type_fmc

				/* modifier l'intitule de la fmc */
				vm_intitule = TMC_libelle_fiche (vm_fiche)
				DB_CTRL_TITLE@ (vm_fenetre, "LI_intitulé_fmc", vm_intitule)
			}

			/* reaffichage du type precedent */
			TMC_AffichageTypePrecedentFMC (vm_fenetre,
			                               vm_type_fmc, vm_fiche.type_precedent,
			                               tm_ListeTypesFMC, 
			                               vm_mode_formation)

			/* Reinitialisation de la liste de choix du types de fmc */
			/* au cas ou elle serait passee de l'etat signalee a confirmee */
			tm_ListeTypesFMC = TMC_AffichageListeTypesFMC (vm_fenetre,
			                                                  vm_type_fmc,
			                                                  vm_fiche.confirme,
			                                                  tm_types_fmc,
			                                                  vm_etat_fmc,
			                                                  vm_mode_appel,
			                                                  vm_enrichir)
		}


		/*si je suis une fiche echangeur*/
		if (vm_fiche.type=XZAEC_FMC_FermetureEch) OR
		   (vm_fiche.type=XZAEC_FMC_EchDeconseille)
		{
			/*je dois mettre a jour le libelle de la localisation suite aux entrees/sorties fermees*/
			ITMA_TMC_genere_local(0)
		}

		if (vm_flag_bouchon=TRUE) AND (vm_multi<>NULL) {
			ITMA_TMC_genere_local(0)
			vm_fiche_tete = vm_fiche_tete_inter
			ITMA_TMC_genere_local(1)
		}
		/*si la voie VR_I est inversee pour des travaux, creer un basculement*/
		/* obsolete: couvert par la Fmc Basculement pour Travaux */
		if (vm_fiche.type=XZAEC_FMC_Travaux) {
		  if (tm_config[4][1] = XDC_VOIE_SENS_INVERSE) 
		    TMC_Genere_Bascul(vm_fenetre)
		}

		/* demande la disparition du Plan d'action eventuellement associe */
		IF va_avec_PA=TRUE
			DB_SEND_POKE@(COM_CANAL_MTPA, "FIN")

		if (vm_multi<>NULL) {
			SET_SYSTEM_VAR@ (vg_fmc_ouverte, FALSE)
			EXIT@()
		}

		/*! calcul du plan d'actions si demandé et si on n'est pas en surcharge*/
		IF (vm_calcul_pa = TRUE) AND (va_avec_PA = TRUE)
		{
			/* Inhiber une nouvelle demande; demarrer un compte-a-rebours*/
			DB_CTRL_GRAYED@(vm_fenetre,"BP_plan_actions",TRUE)
			vm_delai_PA = C_DUREE_INHIB_PA

			/* si je suis enrichisseur du bouchon et a traiter*/
			IF ((vm_flag_bouchon=TRUE) AND (vm_enrichir_queue<>0) AND
					(vm_etat_fmc=XDC_FMC_ETAT_TRAI))
			{
				/*plan d'actions avec trafic FM*/
				NEW_TASK@("ITMA_TMC_lancer_plan_actions",vm_fiche_queue,0)
			}
			/* si pas enrichisseur et a traiter*/
			ELSE IF ((vm_flag_bouchon=TRUE) AND (vm_etat_fmc=XDC_FMC_ETAT_TRAI))
			{
				/*plan d'actions sans trafic FM*/
				NEW_TASK@("ITMA_TMC_lancer_plan_actions",vm_fiche_queue,1)
			}
			/* sinon si je suis enrichisseur de la fiche et a traiter*/
			ELSE IF ((vm_flag_bouchon=FALSE) AND (vm_enrichir<>0) AND
					(vm_etat_fmc=XDC_FMC_ETAT_TRAI))
			{
				/*plan d'actions avec trafic FM*/
				NEW_TASK@("ITMA_TMC_lancer_plan_actions",vm_fiche,0)
			}
			/* sinon si pas enrichisseur et a traiter*/
			ELSE IF ((vm_flag_bouchon=FALSE) AND (vm_etat_fmc=XDC_FMC_ETAT_TRAI))
			{
				/*plan d'actions sans trafic FM*/
				NEW_TASK@("ITMA_TMC_lancer_plan_actions",vm_fiche,1)
			}


			/* on degrise les controles*/
			IF (vm_etat_fmc=XDC_FMC_ETAT_TRAI) {
				DB_CTRL_GRAYED@(vm_fenetre,"BP_achever",FALSE)
				DB_CTRL_GRAYED@(vm_fenetre,"BP_transmettre",FALSE)
				DB_CTRL_GRAYED@(vm_fenetre,"BP_plan_actions",FALSE)
				DB_CTRL_GRAYED@(vm_fenetre,"BP_surcharge",FALSE)
				DB_CTRL_GRAYED@(vm_fenetre,"BA_FausseAlerte",FALSE)
			}

			IF (vm_etat_fmc=XDC_FMC_ETAT_PREV) OR (vm_etat_fmc=XDC_FMC_ETAT_TRAI)
				DB_CTRL_GRAYED@(vm_fenetre,"BP_Faxer",FALSE)
		}


		/* Affichage ou non de l'annulation de FMC*/
		IF ((vm_mode_appel<>MODE_CREATION) and 
			((vm_fiche.type = XZAEC_FMC_AireFermee) or
			 (vm_fiche.type = XZAEC_FMC_Basculement) or
			 (vm_fiche.type = XZAEC_FMC_Delestage) or
			 (vm_fiche.type = XZAEC_FMC_Deviation) or
			 (vm_fiche.type = XZAEC_FMC_FermetureEch) or
			 (vm_fiche.type = XZAEC_FMC_EchDeconseille) or
			 (vm_fiche.type = XZAEC_FMC_Salage) or
			 (vm_fiche.type = XZAEC_FMC_TraitChaussees) or
			 (vm_fiche.type = XZAEC_FMC_Travaux) or
			 (vm_fiche.type = XZAEC_FMC_ZoneStockage) or
			 (vm_fiche.type = XZAEC_FMC_BasculTravaux) or
			 (vm_fiche.type = XZAEC_FMC_ConvoiMil) or
			 (vm_fiche.type = XZAEC_FMC_ConvoiExc)))
		{	
			IF ((COM04_Operateur_A_Le_Droit_De( XDC_FAM_EXPLOITATION_DISTRICT))
				OR (COM04_Operateur_A_Le_Droit_De(XDC_FAM_EXPLOITATION_PC2)) 
				OR (COM04_Operateur_A_Le_Droit_De(XDC_FAM_EXPLOITATION_CI)))

			{	
				IF (DB_CTRL_GET_DISPLAY@(vm_fenetre,"BP_annuler_FMC_prevue") = FALSE)
					 DB_CTRL_DISPLAY@(vm_fenetre, "BP_Annuler_FMC", TRUE)
			}
			ELSE
			{
				DB_CTRL_DISPLAY@(vm_fenetre, "BP_Annuler_FMC", FALSE)
			}
		}
		ELSE
		{
			DB_CTRL_DISPLAY@(vm_fenetre, "BP_Annuler_FMC", FALSE)
		}


		/* je ne suis plus en train d'enrichir*/
		DB_CTRL_DISPLAY@(vm_fenetre,"BP_libenrichir",FALSE)


		/* je valorise la configuration des voies pour reaffichage*/
		vm_fiche.bau_i=tm_config[0][1]
		vm_fiche.vl_i=tm_config[1][1]
		vm_fiche.vm1_i=tm_config[2][1]
		vm_fiche.vm2_i=tm_config[3][1]
		vm_fiche.vr_i=tm_config[4][1]
		vm_fiche.bau=tm_config[5][1]
		vm_fiche.vl=tm_config[6][1]
		vm_fiche.vm1=tm_config[7][1]
		vm_fiche.vm2=tm_config[8][1]
		vm_fiche.vr=tm_config[9][1]


		/* associe une camera a la queue de bouchon si c'est demande */
		IF (vm_flag_bouchon=TRUE)
		{
			IF (DB_CTRL_GET_VALUE@ (vm_fenetre, "BA_associer_camera") = TRUE)
			{
				DB_SEND_POKE@ (COM_CANAL_MTCA_RAPIDE,
				               { "ITMA_TMC", vm_fiche.autoroute, vm_fiche.pr, vm_fiche.pr, vm_fiche.sens })
			}
		}


		/* Afficher les donnees specifiques mises a jour, et les eventuelles donnees calculees */
		ITMA_TMC_Lire_Donnees_Specifiques (vm_type_fmc)


		/* Ajout SAGA : TMC_DATEX() est appele pour gerer un eventuel changement */
		/* dans le droit de propriete                                            */
		TMC_DATEX()
	}


/*! saut atteint en cas d'erreur dans une proc de sauvegarde en base*/
POS_ERR:
	IF vl_cr=XZAEC_FMC_PAS_ENR			
	{
		if (SYSTEM_VAR@(vg_type_machine)<>XDC_TYPEM_PCS)
			INFO_MESSAGE@("Vous n'avez plus le droit d'enrichir cette FMC")
		ELSE	INFO_MESSAGE@("La FMC est passée à l'état à traiter par le CI")
		DB_CTRL_GRAYED@(vm_fenetre,"BP_valider",TRUE)
		DB_CTRL_DISPLAY@(vm_fenetre,"BP_Annuler_FMC",FALSE)
		DB_CTRL_DISPLAY@(vm_fenetre,"BP_libenrichir",FALSE)
		DB_CTRL_GRAYED@(vm_fenetre,"BP_transmettre",TRUE)
		/*Rendre actif le bouton 'Transmettre FMC' DEM420 */
		/*DB_CTRL_GRAYED@(vm_fenetre,"BP_transmettre_fmc",TRUE)*/
	}
	ELSE IF vl_cr=XZAEC_FMC_PAS_RETYPAGE OR vl_cr=XZAEC_FMC_INC_RETYPAGE
	{
		INFO_MESSAGE@ ("Changement de type de l'événement non autorisé ou erroné")

		/* remettre a jour l'affichage */
		ITMA_TMC_Visu_Champs_Specifiques (vm_type_fmc, FALSE)
		ITMA_TMC_Visu_Champs_Specifiques (vm_fiche.type, TRUE)

		/* repositionner le type de fmc */
		vl_indice = COM45_IndexEnColonne (tm_ListeTypesFMC, TDO_NUMERO_FMC, vm_fiche.type)
		DB_CTRL_VALUE@ (vm_fenetre, "BO_TypeFMC", vl_indice)
		vm_type_fmc = vm_fiche.type
	}

	RETURN (vl_cr)
ENDMACRO






/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Effectue en base de donnees les verifications et modifications prealables
*  au changement de type d'une FMC en preparant les donnees correspondant
*  au nouveau type dans les tables contenant les donnees specifiques.
*
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO TMC_Nouveau_Type_FMC (va_NumEvt, va_CleEvt, va_Mode, va_NouveauType)

/*
* ARGUMENTS EN ENTREE :
*   va_NumEvt         : le numero de l'evenement ;
*   va_CleEvt         : la cle de l'evenement ;
*   va_Mode           : le mode de la fiche (prevision/traiter/clos) ;
*   va_NouveauType    : le nouveau type de l'evenement.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         :
*   XDC_OK
*   XDC_NOK                 : operation impossible ou erronee
*   XZAEC_FMC_PAS_ENR       : pas le droit d'enrichir
*   XZAEC_FMC_PAS_RETYPAGE,
*   XZAEC_FMC_INC_RETYPAGE  : conditions de retypage non remplies
*
* CONDITION D'UTILISATION
*   TMC_Valide_FMC
*
* FONCTION
*   Appelle la procedure de prise en compte du nouveau type.
*
-----------------------------------------------------------------------------*/

	VAR	FORMAT	SQL_Procedure_Params@	vl_parametres
	VAR	FORMAT	SQL_Procedure_Result@	vl_resultats
	VAR	vl_cr

	/* preparation des parametres de la requete */
	vl_parametres[0].type = SYB#INT4_
	vl_parametres[0].data = va_NumEvt
	vl_parametres[0].output = FALSE

	vl_parametres[1].type = SYB#INT4_
	vl_parametres[1].data = va_CleEvt
	vl_parametres[1].output = FALSE

	vl_parametres[2].type = SYB#INT4_
	vl_parametres[2].data = va_Mode
	vl_parametres[2].output = FALSE

	vl_parametres[3].type = SYB#INT4_
	vl_parametres[3].data = va_NouveauType
	vl_parametres[3].output = FALSE

	vl_parametres[4].type = SYB#CHAR_                               ' Site local
	vl_parametres[4].data = SYSTEM_VAR@(vg_nom_site)
	vl_parametres[4].output = FALSE

	vl_cr = COM05_SQL_Procedure (XZAE209_Modifier_Type_Fiche_MC,
	                                vl_parametres, vl_resultats, C_MODULE)

	RETURN (vl_cr)
ENDMACRO






/*-----------------------------------------------------------------------------
* SERVICE RENDU :
* Lire les informations associees a la fiche
* Affiche ces informations dans la boite de dialogue
*
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION TMC_Lire_Fiche()

/*
* ARGUMENTS EN ENTREE : Aucun
*
* ARGUMENTS EN SORTIE : Aucun
*
* CODE RETOUR :
*   COM_OK	la fiche a ete lue correctement ;
*   COM_NOK	une erreur s'est produite.
*
*
-----------------------------------------------------------------------------*/
	VAR vl_indice
	VAR FORMAT SQL_Procedure_Params@	vl_parametres
	VAR FORMAT SQL_Procedure_Result@	vl_resultats
	VAR  i
	VAR FORMAT TDO_Horo_Eclatee	vl_horodate
	VAR FORMAT COM_Intitule_FMC	vl_cause
	VAR vl_intitule
	VAR vl_nom
	VAR vl_index

	i=0

	/* preparation des parametres de la requete*/
	vl_parametres[i].type = SYB#DATETIME_
	vl_parametres[i].data= vm_horodate
	vl_parametres[i].output = FALSE
	i=i+1

	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].data = tm_num_evt.numero
	vl_parametres[i].output = FALSE
	i=i+1

	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].data = tm_num_evt.cle
	vl_parametres[i].output = FALSE
	i=i+1

	'vl_parametres[i].data=null	'num
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'cle
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'site
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'type
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'deb prev
	vl_parametres[i].type = SYB#DATETIME_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'deb
	vl_parametres[i].type = SYB#DATETIME_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'fin prev
	vl_parametres[i].type = SYB#DATETIME_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'fin
	vl_parametres[i].type = SYB#DATETIME_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'validation
	vl_parametres[i].type = SYB#DATETIME_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'num cause
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'cle cause
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'type cause
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'num alerte
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'horo alerte
	vl_parametres[i].type = SYB#DATETIME_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'type alerte
	vl_parametres[i].type = SYB#CHAR_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'origine
	vl_parametres[i].type = SYB#CHAR_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'confirme
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'autoroute
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'pr
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'sens
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'pt car
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'nom pt car
	vl_parametres[i].type = SYB#CHAR_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'vr
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'vm2
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'vm1
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'vl
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'bau
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'vri
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'vm2i
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'vm1i
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'vli
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'baui
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'autoroute cause
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'pr cause
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'sens cause
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'horo cause
	vl_parametres[i].type = SYB#DATETIME_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'position sur aire ou echangeur
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1


	'vl_parametres[i].data=" "	'degats domaine
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'type fmc precedent
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'fausse alerte
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'BAU etroite 
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'BAU inverse etroite
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'longueur escargot
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'abrev point car
	vl_parametres[i].type = SYB#CHAR_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'numero point car
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	' fmc degrade (0/1)
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'num fmc init 
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'cle fmc init
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'commentaire fmc init
	vl_parametres[i].type = SYB#CHAR_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'type fmc init
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'autoroute fmc init
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'PR fmc init
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'sens fmc init
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'horodate fmc init
	vl_parametres[i].type = SYB#DATETIME_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'site alerte
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'datex
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'trafic
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'gravite
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'bloquant
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'duree
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1


	'vl_parametres[i].data=" "	'majeur
	vl_parametres[i].type = SYB#INT2_
	vl_parametres[i].output = TRUE
	i=i+1

	'vl_parametres[i].data=" "	'ecoulement
	vl_parametres[i].type = SYB#INT1_
	vl_parametres[i].output = TRUE
	i=i+1


	/* execution de la requete*/
	/* Hilmarcher */
	/* Execution requete sur HIS si horodate FMC < 1 mois sinon sur EXP */

	IF COM50_DateHistorique(vm_horodate)
	{
		IF COM41_SQL_Procedure_HIS (XZAE40_Lire_Fiche_MC,
				vl_parametres, vl_resultats, C_MODULE) <> COM_OK
		{
		INFO_MESSAGE@("Erreur dans la lecture de la fiche en base HIS")
		RETURN (COM_NOK)
		}
	}
	ELSE
	{
		IF COM05_SQL_Procedure (XZAE40_Lire_Fiche_MC,
			   	vl_parametres, vl_resultats, C_MODULE) <> COM_OK
		{
		INFO_MESSAGE@("Erreur dans la lecture de la fiche en base EXP")
		RETURN (COM_NOK)
		}
	}
	/* recupere les parametres de sortie*/
	vm_fiche=vl_resultats.return_parameters
	tm_comment=vl_resultats.select_results[0]

	/* memorise le numero d'evt*/
	tm_num_evt.numero=vm_fiche.numero
	tm_num_evt.cle=vm_fiche.cle

	/* On memorise si c'est une fmc datex */
	SET_SYSTEM_VAR@ (vg_datex,vm_fiche.datex)

	/*! determine le num du point caracteristique en fonction du nom*/
	/*! bug applix: if faut extraire les 25 premiers caracteres*/
	vl_nom=TRIM@(SUBSTRING@(vm_fiche.nom_point_car,1,25))
	vm_local.NomPtCar=vl_nom
	vm_local.PtCar=vm_fiche.point_car

	/* Recherche du numero du point caracteristique */
	Initialiser_Point_Caract_Fiche(vm_fenetre, vm_fiche)

	/* affiche les valeurs dans les controles associes*/

	/* fmc init*/
	IF (vm_fiche.degrade = XDC_OUI)  
	{
		DB_CTRL_VALUE@(vm_fenetre,"BS_Com_FMC_Init",vm_fiche.com_fmc_init)
		IF (vm_fiche.num_fmc_init > 0)
		{
			vl_cause.IdFMC.numero=vm_fiche.num_fmc_init
			vl_cause.IdFMC.cle=vm_fiche.cle_fmc_init
			vl_cause.NumType=vm_fiche.type_fmc_init
			vl_cause.date=COM18_Date_SGBD_Formatee(vm_fiche.debut_fmc_init)
			vl_cause.localisation.NumAuto=vm_fiche.autoroute_fmc_init
			vl_cause.localisation.pr=vm_fiche.pr_fmc_init
			vl_cause.localisation.sens_circulation=vm_fiche.sens_fmc_init
			vl_intitule = COM11_Libelle_FMC ( vl_cause)
			DB_CTRL_TITLE@(vm_fenetre, "LI_FMC_Initiale",vl_intitule)
		}
	}

	/* horodate debut prevu*/
	vl_horodate=COM18_Date_SGBD_Formatee(vm_fiche.debut_prevu)
	COM24_Afficher_Horodate(vl_horodate,vm_fenetre,
				"BS_jour_debut_prevu",
				"BS_mois_debut_prevu",
				"BS_annee_debut_prevu",
				"BS_heure_debut_prevu",
				"BS_minute_debut_prevu")

	/* horodate debut*/
	vl_horodate=COM18_Date_SGBD_Formatee(vm_fiche.debut)
	COM24_Afficher_Horodate(vl_horodate,vm_fenetre,
				"BS_jour_debut_reel",
				"BS_mois_debut_reel",
				"BS_annee_debut_reel",
				"BS_heure_debut_reel",
				"BS_minute_debut_reel",
				"BS_seconde_debut_reel")

	/* horodate fin prevu*/
	vl_horodate=COM18_Date_SGBD_Formatee(vm_fiche.fin_prevu)
	COM24_Afficher_Horodate(vl_horodate,vm_fenetre,
				"BS_jour_fin_prevue",
				"BS_mois_fin_prevue",
				"BS_annee_fin_prevue",
				"BS_heure_fin_prevue",
				"BS_minute_fin_prevue")

	/* horodate fin*/
	vl_horodate=COM18_Date_SGBD_Formatee(vm_fiche.fin)
	COM24_Afficher_Horodate(vl_horodate,vm_fenetre,
				"BS_jour_fin_reelle",
				"BS_mois_fin_reelle",
				"BS_annee_fin_reelle",
				"BS_heure_fin_reelle",
				"BS_minute_fin_reelle",
				"BS_seconde_fin_reelle")

	/* veracite*/
	i = COM45_IndexEnColonne (tm_veracite, C_VAL_VERACITE, vm_fiche.confirme)
	DB_CTRL_VALUE@ (vm_fenetre, "BO_veracite", i)

	/* fausse alerte : si c'est une fausse alerte, la veracite est grisee */
	IF vm_fiche.fausse_alerte = XDC_VRAI
	{
		DB_CTRL_GRAYED@(vm_fenetre,"BO_veracite",TRUE)
		DB_CTRL_VALUE@(vm_fenetre,"BA_FausseAlerte",TRUE)
	}
	ELSE
		DB_CTRL_VALUE@(vm_fenetre,"BA_FausseAlerte",FALSE)

	/* degats domaine */
	IF vm_fiche.degatsdom = XDC_VRAI
		DB_CTRL_VALUE@(vm_fenetre,"BT_degats",TRUE)
	ELSE	vm_fiche.degatsdom = XDC_FAUX

	IF vm_fiche.majeur = TRUE
		DB_CTRL_VALUE@(vm_fenetre,"BA_majeur",TRUE)
	ELSE
		DB_CTRL_VALUE@(vm_fenetre,"BA_majeur",FALSE)

	IF vm_fiche.ecoulement = XDC_VRAI
		DB_CTRL_VALUE@(vm_fenetre,"BA_Ecoulement",TRUE)
	ELSE
		DB_CTRL_VALUE@(vm_fenetre,"BA_Ecoulement",FALSE)

	/* longueur escargot */
	IF (vm_fiche.type = XZAEC_FMC_Escargot AND
		vm_fiche.longueur <> NULL)
		DB_CTRL_VALUE@(vm_fenetre,"BS_Longueur", vm_fiche.longueur)

	/* alerte*/
	IF (vm_fiche.numero_alerte<>null)
	{
		/* ne plus afficher l'origine*/
		DB_CTRL_DISPLAY@(vm_fenetre,"BS_origine",FALSE)
		DB_CTRL_DISPLAY@(vm_fenetre,"BO_Origine",FALSE)

		/* afficher l'alerte*/
		DB_CTRL_DISPLAY@(vm_fenetre,"ta_alerte",TRUE)
		DB_CTRL_DISPLAY@(vm_fenetre,"LIB_alerte",TRUE)
		DB_CTRL_DISPLAY@(vm_fenetre,"LI_alerte",TRUE)

		/* libelle de l'alerte*/
		vm_fiche.horo_alerte=COM18_Date_SGBD_Formatee(vm_fiche.horo_alerte)
		if vm_fiche.datex = XDC_VRAI
		{
			DB_CTRL_TITLE@(vm_fenetre,"LIB_alerte",vm_fiche.numero_alerte++
								" "++vm_fiche.origine++" "++
                                        vm_fiche.horo_alerte)
		}
		ELSE
		{
                DB_CTRL_TITLE@(vm_fenetre,"LIB_alerte",vm_fiche.numero_alerte++" "++
                                        vm_fiche.type_alerte++" "++
                                        vm_fiche.horo_alerte)
		}
	}
	ELSE
	{
		/* afficher l'origine*/
		DB_CTRL_DISPLAY@(vm_fenetre,"BS_origine",TRUE)
		DB_CTRL_DISPLAY@(vm_fenetre,"BO_Origine",TRUE)

		/* ne plus afficher l'alerte*/
		DB_CTRL_DISPLAY@(vm_fenetre,"ta_alerte",FALSE)
		DB_CTRL_DISPLAY@(vm_fenetre,"LIB_alerte",FALSE)
		DB_CTRL_DISPLAY@(vm_fenetre,"LI_alerte",FALSE)

		/* origine*/
		/*! on extrait les 25 premiers caracteres*/
		vm_fiche.origine=TRIM@(SUBSTRING@(vm_fiche.origine,1,25))
	}


	/*! si je ne suis pas une fiche operateur*/
	IF (vm_fiche.type <> XZAEC_FMC_PosteOperateur)
		/* memorise et affiche le libelle de la localisation*/
		ITMA_TMC_genere_local()

	/* affiche la configuration des voies*/
	ITMA_TMC_config_voies()

	/* affiche la liste des actions realisees*/
	ITMA_TMC_actions_realisees(vm_horodate)

	/* affiche la liste des commentaires*/
	ITMA_TMC_formater_date_comment()
	ITMA_TMC_affiche_comment()

	/* affichage du type precdent de fmc */
	TMC_AffichageTypePrecedentFMC (vm_fenetre, vm_fiche.type, vm_fiche.type_precedent, 
					tm_ListeTypesFMC, vm_mode_formation)

	/* construit le libelle de l'evenement cause et l'affiche*/
	IF (vm_fiche.numero_cause<>null)
	{
		vl_cause.IdFMC.numero=vm_fiche.numero_cause
		vl_cause.IdFMC.cle=vm_fiche.cle_cause
		vl_cause.NumType=vm_fiche.type_cause
		vl_cause.localisation.NumAuto=vm_fiche.autoroute_cause
		vl_cause.localisation.pr=vm_fiche.pr_cause
		vl_cause.localisation.sens_circulation=vm_fiche.sens_cause
		vl_intitule = COM11_Libelle_FMC ( vl_cause)
		DB_CTRL_TITLE@(vm_fenetre, "LI_fmc_cause",vl_intitule)
	}

	/* Traitement FMC DATEX */
	/* Ajout SAGA : TMC_DATEX() est appele dans tous les cas pour gerer le droit de propriete */
	/*if (vm_fiche.datex = XDC_VRAI)*/
		TMC_DATEX()

RETURN (COM_OK)
ENDFUNCTION






/*-----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Affiche ou masque les champs specifiques au type de la FMC
*   selon l'indicateur donne en parametre
*
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TMC_Visu_Champs_Specifiques (va_num_type, va_visible)

/*
* ARGUMENTS EN ENTREE :
*  va_num_type        : type de la fiche main courante
*  va_visible         : indicateur demandant affichage ou masquage
*
* ARGUMENTS EN SORTIE :
* aucun
*
* CODE RETOUR :
* aucun
*
-----------------------------------------------------------------------------*/

VAR vl_nom_macro
VAR vl_index

	/* Déterminer la macro de traitement des informations d'une fmc de ce type */
	vl_index = COM45_IndexEnColonne (tm_types_fmc, TDO_NUMERO_FMC, va_num_type)
	vl_nom_macro = tm_macro_specifique[vl_index]

	/* Pour une fiche échangeur existante, les voies ont déjà été affichées */ 
	IF NOT (vm_mode_appel <> MODE_CREATION  AND
	          (va_num_type = XZAEC_FMC_FermetureEch OR va_num_type = XZAEC_FMC_EchDeconseille))
	{
		/* Invoquer la macro adequate */
		vm_fenetre = !vl_nom_macro (vm_fenetre, va_num_type, va_visible)
	}
ENDMACRO






/*-----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Lit en base les données spécifiques au type de FMC traitée
*   et les visualise dans les zones adéquates
*
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TMC_Lire_Donnees_Specifiques (va_num_type)

/*
* ARGUMENTS EN ENTREE :
*  va_num_type        : type de la fiche main courante
*
* ARGUMENTS EN SORTIE :
* aucun
*
* CODE RETOUR :
* aucun
*
-----------------------------------------------------------------------------*/

VAR vl_nom_macro
VAR tl_retour
VAR vl_index

	/* déterminer la fonction de traitement des informations d'une fmc de ce type */
	vl_index = COM45_IndexEnColonne (tm_types_fmc, TDO_NUMERO_FMC, va_num_type)
	vl_nom_macro = tm_macro_specifique[vl_index] ++ "_charge"

	/* exécuter cette macro */
	tl_retour = !vl_nom_macro (vm_fenetre, tm_num_evt, vm_horodate, va_num_type)

	vm_fenetre = tl_retour[0]

	/* Mette a jour les tampons des donnees specifique au type FMC */
	tm_donnees_specifiques = { tl_retour[1], tl_retour[2] }
	TMC_Donnees_Specifiques (va_num_type, tm_donnees_specifiques, TRUE)

	/* Afficher la configuration des voies selon le type de FMC */
	IF (va_num_type = XZAEC_FMC_Basculement) OR
	   (va_num_type = XZAEC_FMC_Travaux) OR
	   (va_num_type = XZAEC_FMC_ZoneStockage) OR
	   (va_num_type = XZAEC_FMC_BasculTravaux)
	{
		ITMA_TMC_config_voies()
	}

	RETURN
ENDMACRO






/*-----------------------------------------------------------------------------
* SERVICE RENDU :
* construit le libelle de la localisation
*
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION ITMA_TMC_genere_local(va_mode_tete)

/*
* ARGUMENTS EN ENTREE :
* va_mode_tete: 1 => afficher la local de la tete de bouchon
*
* ARGUMENTS EN SORTIE :
* aucun
*
* CODE RETOUR :
* aucun
*
*
*
-----------------------------------------------------------------------------*/
VAR tl_localisation
VAR vl_indice
VAR FORMAT localisation	vl_local

	/*! si je suis un bouchon*/
	IF (va_mode_tete=1)
	{
	/*! je construit la localisation de la tete de bouchon*/
		vl_local=vm_local_tete
		vl_local.NumAutoroute=vm_fiche_tete.autoroute
		vl_local.Pr=vm_fiche_tete.pr
		vl_local.Sens=vm_fiche_tete.sens
	}
	ELSE
	{
		vl_local=vm_local
		/* memoriser les valeurs de la localisation*/
		vl_local.NumAutoroute=vm_fiche.autoroute
		vl_local.Pr=vm_fiche.pr
		vl_local.Sens=vm_fiche.sens
		vl_local.PtCar=vm_fiche.point_car
	}

	/*! je transforme le pr en km*/
	vl_local.pr=vl_local.pr/1000

	/*! initialiser le libelle du sens a sa valeur par defaut */
	vl_indice = COM45_IndexEnColonne (tm_sens_echangeur, TDO_NUMERO_SENS,
	                                     vl_local.Sens)
	IF (vl_indice < 0) {
		vl_local.LibSens = null
	} ELSE IF (vl_local.Sens = XDC_SENS_INCONNU)  and
		   (vm_type_fmc = XZAEC_FMC_Meteo  or
		    vm_type_fmc = XZAEC_FMC_Inondation  or
		    vm_type_fmc = XZAEC_FMC_TraitChaussees) {
		vl_local.LibSens = XDC_LIB_2_SENS
	} ELSE {
		vl_local.LibSens = "sens " ++ tm_sens_echangeur[vl_indice].nom
	}


	CASE OF (vl_local.PtCar)
		/* aire*/
		CASE XDC_POINT_CARACT_AIRE
			tl_localisation[1] = "sur l'aire " ++ vl_local.NomPtCar

		/* echangeur*/
		CASE XDC_POINT_CARACT_ECHANGEUR
			vl_local.LibSens=ARRAY_FROM_STRING@(vl_local.LibSens,",")

			IF (vl_local.LibSens[1]<>null)
				tl_localisation[1]="sur la "++vl_local.LibSens[1]
								++" de l'échangeur "
								++vl_local.NomPtCar
			ELSE
				tl_localisation[1]="sur l'échangeur "++vl_local.NomPtCar
			vl_local.LibSens=vl_local.LibSens[0]

		/* peage*/
		CASE XDC_POINT_CARACT_PEAGE
			tl_localisation[1] = "sur le péage " ++ vl_local.NomPtCar

		/* lit d'arret*/
		CASE XDC_POINT_CARACT_LIT_ARRET
			tl_localisation[1] = "sur le lit d'arrêt " ++ vl_local.NomPtCar

		/* section courante*/
		DEFAULT
			tl_localisation[1] = "sur la section courante"
	ENDCASE

	/* je recupere le nom de l'autoroute*/
	vl_indice=ARRAY_INDEX@(ARRAY_COLUMN@(tm_autoroutes,TDO_NUMERO_AUTOROUTE),
	                          vl_local.NumAutoroute)
	vl_local.NomAutoroute=tm_autoroutes[vl_indice].nom

	/* Construire l'intitulé de la localisation et l'afficher*/
	tl_localisation[0]="Autoroute "++vl_local.NomAutoroute++
						", " ++ vl_local.LibSens++
						", au PR " ++ vl_local.pr

	/*! si je suis un bouchon*/
	IF (va_mode_tete=1)
	{
		DB_EDITBOX_SET_DATA@(vm_fenetre,"BE_local_tetebou",tl_localisation)
		/*! je memorise ma localisation*/
		vm_local_tete=vl_local
	}
	ELSE
	{
		DB_EDITBOX_SET_DATA@(vm_fenetre,"BE_localisation",tl_localisation)
		vm_local=vl_local
	}
	RETURN
ENDFUNCTION






/*----------------------------------------------------------------------------------
* SERVICE RENDU :
*
*   Visualise dans la fenêtre indiquée en argument 
*    la configuration des voies de section courante spécifiée
*    (aussi bien la configuration actuelle des voies, générique qu'une
*     configuration des voies spécifique au type FMC - basculement, travaux -)
*
------------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TMC_visu_config_voies (va_fenetre, ta_config_voies, va_bau_etroite, va_bau_i_etroite)

/*
* ARGUMENTS EN ENTREE :
*   va_fenetre		: fenetre de visualisation
*   ta_config_voies	: table des configurations de voies
*   va_bau_etroite	: indicateur de nature de la BAU
*   va_bau_i_etroite	: indicateur de nature de la BAU inverse
*
* ARGUMENTS EN SORTIE :
* aucun
*
* CODE RETOUR :
* aucun
*
----------------------------------------------------------------------------------*/

VAR	vl_centre_voies, vl_xposition
VAR	vl_pix
VAR	vl_i

	/* Calculer la position centrale des voies pour repositionnement */
	vl_centre_voies = (DB_CTRL_GET_XPOS@ (va_fenetre, ta_config_voies[4][0]) +
	                     DB_CTRL_GET_XPOS@ (va_fenetre, ta_config_voies[9][0])) / 2

	/* Visualiser les configurations des voies inverses */
	vl_xposition = vl_centre_voies - 25

	FOR vl_i = 4 TO 0 STEP -1
		IF (ta_config_voies[vl_i][1] = XDC_VOIE_INEXISTANTE) OR
		   (ta_config_voies[vl_i][1] = XDC_VOIE_INCONNUE)
		{
			DB_CTRL_DISPLAY@ (va_fenetre, ta_config_voies[vl_i][0], FALSE)
		} ELSE {
			/*! les icones doivent etre alignes a droite */
			/*!  par rapport au terre-plein central      */
			IF (vl_i = 0) {
				/* la BAU est décalée par rapport aux autres voies */
				vl_xposition = vl_xposition - fav_delta * 0.4

				vl_pix = tm_pix_bau_inv[ta_config_voies[vl_i][1] +
				                        XDC_VOIE_BAU_ETROITE * va_bau_i_etroite]
			} ELSE {
				vl_pix = tm_pix_fav_inv[ta_config_voies[vl_i][1]]
			}

			/* Positionner l'icone de configuration de voie */
			DB_CTRL_XPOS@ (va_fenetre, ta_config_voies[vl_i][0], vl_xposition)
			vl_xposition = vl_xposition - fav_delta

			/* Afficher le pixmap associe a son etat */
			DB_CTRL_TITLE@ (va_fenetre, ta_config_voies[vl_i][0], vl_pix)
			DB_CTRL_DISPLAY@ (va_fenetre, ta_config_voies[vl_i][0], TRUE)
		}
	NEXT vl_i


	/* Visualiser les configurations des voies normales */
	vl_xposition = vl_centre_voies + 25

	FOR vl_i = 9 TO 5 STEP -1
		IF (ta_config_voies[vl_i][1] = XDC_VOIE_INEXISTANTE) OR
		   (ta_config_voies[vl_i][1] = XDC_VOIE_INCONNUE)
		{
			DB_CTRL_DISPLAY@ (va_fenetre, ta_config_voies[vl_i][0], FALSE)
		} ELSE {
			/*! les icones doivent etre alignes a gauche */
			/*!  par rapport au terre-plein central      */
			IF (vl_i = 5) {
				/* la BAU est décalée par rapport aux autres voies */
				vl_xposition = vl_xposition + fav_delta * 0.4

				vl_pix = tm_pix_bau[ta_config_voies[vl_i][1] +
				                    XDC_VOIE_BAU_ETROITE * va_bau_etroite]
			} ELSE {
				vl_pix = tm_pix_fav[ta_config_voies[vl_i][1]]
			}

			/* Positionner l'icone de configuration de voie */
			DB_CTRL_XPOS@ (va_fenetre, ta_config_voies[vl_i][0], vl_xposition)
			vl_xposition = vl_xposition + fav_delta

			/* Afficher le pixmap associe a son etat */
			DB_CTRL_TITLE@ (va_fenetre, ta_config_voies[vl_i][0], vl_pix)
			DB_CTRL_DISPLAY@ (va_fenetre, ta_config_voies[vl_i][0], TRUE)
		}
	NEXT vl_i
ENDMACRO






/*----------------------------------------------------------------------------------
* SERVICE RENDU :
*
*   Définit (prépare pour affichage)
*    ou met à jour (en cas de changement de localisation par exemple)
*    la configuration actuelle des voies sur la section courante (générique)
*
------------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TMC_config_voies_section_courante ()

/*
* ARGUMENTS EN ENTREE :
*
* ARGUMENTS EN SORTIE :
* aucun
*
* CODE RETOUR :
* aucun
*
----------------------------------------------------------------------------------*/

VAR	tl_old_config
VAR	vl_indice

	/* Mémoriser l'ancienne configuration des voies */
	tl_old_config = tm_config

	/* Mettre a jour le tableau de configuration des voies */
	tm_config[0][1] = vm_fiche.bau_i
	tm_config[1][1] = vm_fiche.vl_i
	tm_config[2][1] = vm_fiche.vm1_i
	tm_config[3][1] = vm_fiche.vm2_i
	tm_config[4][1] = vm_fiche.vr_i
	tm_config[5][1] = vm_fiche.bau
	tm_config[6][1] = vm_fiche.vl
	tm_config[7][1] = vm_fiche.vm1
	tm_config[8][1] = vm_fiche.vm2
	tm_config[9][1] = vm_fiche.vr

	/* En création de bouchon, */
	if (vm_flag_bouchon = TRUE) AND (vm_mode_appel = MODE_CREATION) {
		/* les voies circulées en sens normal sont bloquées par défaut */
		FOR vl_indice = 6 TO 9
			if (tm_config[vl_indice][1] = XDC_VOIE_SENS_NORMAL)
				tm_config[vl_indice][1] = XDC_VOIE_BLOQUEE
		NEXT vl_indice
	}


	/* Pour chacune des voies, */
	FOR vl_indice = 0 TO 9
		/* si la voie existe alors */
		IF (tm_config[vl_indice][1] <> XDC_VOIE_INEXISTANTE) AND
		   (tm_config[vl_indice][1] <> XDC_VOIE_INCONNUE)
		{
			/* si elle existait dans l'ancienne configuration alors */
			IF ((tl_old_config[vl_indice][1] <> XDC_VOIE_INEXISTANTE) AND
			    (tl_old_config[vl_indice][1] <> XDC_VOIE_INCONNUE) AND
			    (tl_old_config[vl_indice][1] <> null))
			{
				/* conserver son état défini précédemment */
				tm_config[vl_indice][1] = tl_old_config[vl_indice][1]
			}
		}
	NEXT vl_indice
ENDMACRO






/*----------------------------------------------------------------------------------
* SERVICE RENDU :
*
*   Définit (prépare pour affichage)
*    ou met à jour (en cas de changement de localisation par exemple)
*    la configuration des voies de section courante
*    spécifique au type fmc (basculement, travaux)
*
------------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TMC_config_voies_specifique (ta_cfg_voies_type)

/*
* ARGUMENTS EN ENTREE :
* ta_cfg_voies_type	: table des configurations des voies specifiques
*
* ARGUMENTS EN SORTIE :
* aucun
*
* CODE RETOUR :
* aucun
*
----------------------------------------------------------------------------------*/

VAR	vl_indice

	/* Pour chacune des voies, */
	FOR vl_indice = 0 TO 9
		/* si la voie existe alors */
		IF (tm_config[vl_indice][1] <> XDC_VOIE_INEXISTANTE) AND
		   (tm_config[vl_indice][1] <> XDC_VOIE_INCONNUE)
		{
			/* si la voie n'est pas définie dans la config. spécifique alors */
			IF ((ta_cfg_voies_type[vl_indice][1] = XDC_VOIE_INEXISTANTE) OR
			    (ta_cfg_voies_type[vl_indice][1] = XDC_VOIE_INCONNUE))
			{
				/* elle prend le même état que dans la config. actuelle */
				ta_cfg_voies_type[vl_indice][1] = tm_config[vl_indice][1]
			}
		} ELSE {
			/* si la voie n'existe pas, elle n'existe pas non plus */
			/* dans la configuration spécifique */
			ta_cfg_voies_type[vl_indice][1] = tm_config[vl_indice][1]
		}
	NEXT vl_indice
ENDMACRO






/*----------------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Définit puis affiche la configuration des voies sur section courante
*   ou les bretelles d'accès dans le cas d'un événement situé sur échangeur
*
------------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TMC_config_voies ()

/*
* ARGUMENTS EN ENTREE :
*
* ARGUMENTS EN SORTIE :
* aucun
*
* CODE RETOUR :
* aucun
*
----------------------------------------------------------------------------------*/

VAR	vl_indice

	/*! Ne rien afficher pour une FMC Datex */
	IF (SYSTEM_VAR@ ( vg_datex ) = XDC_VRAI)
		RETURN

	/*! si bouchon */
	/*IF (vm_flag_bouchon=TRUE)
		RETURN*/

	/*! Ne rien afficher pour une fiche aire */
	IF (vm_fiche_aire = TRUE) OR (vm_fiche_frontiere = TRUE)
		RETURN

	if (vm_fiche_regulation=true)
		return

	/*! Pour un événement situé sur échangeur */
	IF (vm_fiche_echangeur = TRUE) {
		/* Afficher les acces qui existent pour cet echangeur */
		vl_indice = COM45_IndexEnColonne (tm_echangeurs, TDO_NUMERO_ECHANGEUR,
		                                     vm_fiche.nom_point_car)

		DB_CTRL_DISPLAY@ (vm_fenetre, "BT_entree1", -1*tm_echangeurs[vl_indice].voies_entree_sens1)
		DB_CTRL_DISPLAY@ (vm_fenetre, "BT_sortie1", -1*tm_echangeurs[vl_indice].voies_sortie_sens1)
		DB_CTRL_DISPLAY@ (vm_fenetre, "BT_entree2", -1*tm_echangeurs[vl_indice].voies_entree_sens2)
		DB_CTRL_DISPLAY@ (vm_fenetre, "BT_sortie2", -1*tm_echangeurs[vl_indice].voies_sortie_sens2)
		DB_CTRL_DISPLAY@ (vm_fenetre, "LI_acces_ech", TRUE)

		/* réinitialiser les acces inexistants pour cet echangeur */
		/* (nécessaire si on change d'echangeur)                  */
		IF DB_CTRL_GET_DISPLAY@ (vm_fenetre,"BT_entree1") <> TRUE
			DB_CTRL_VALUE@ (vm_fenetre, "BT_entree1", FALSE)
		IF DB_CTRL_GET_DISPLAY@ (vm_fenetre,"BT_entree2") <> TRUE
			DB_CTRL_VALUE@ (vm_fenetre, "BT_entree2", FALSE)
		IF DB_CTRL_GET_DISPLAY@ (vm_fenetre,"BT_sortie1") <> TRUE
			DB_CTRL_VALUE@ (vm_fenetre, "BT_sortie1", FALSE)
		IF DB_CTRL_GET_DISPLAY@ (vm_fenetre,"BT_sortie2") <> TRUE
			DB_CTRL_VALUE@ (vm_fenetre, "BT_sortie2", FALSE)

		/* on n'affiche pas la configuration des voies */
		RETURN
	}


	/* Mettre à jour puis visualiser la configuration actuelle des voies */
	ITMA_TMC_config_voies_section_courante ()
	ITMA_TMC_visu_config_voies (vm_fenetre, tm_config,
	                               vm_fiche.bau_etroite, vm_fiche.bau_i_etroite)


	/* Mettre à jour puis visualiser la config. des voies spécifique au type fmc */
	CASE OF vm_type_fmc
	CASE XZAEC_FMC_Basculement
		ITMA_TMC_config_voies_specifique (tm_config_bascul)
		/* Visualiser les configurations de voies spécifiques au basculement */
		ITMA_TMC_visu_config_voies (vm_fenetre, tm_config_bascul,
		                               vm_fiche.bau_etroite, vm_fiche.bau_i_etroite)

	CASE XZAEC_FMC_Travaux, XZAEC_FMC_ZoneStockage
		ITMA_TMC_config_voies_specifique (tm_config_trv)
		/* Visualiser les configurations de voies spécifiques aux travaux */
		ITMA_TMC_visu_config_voies (vm_fenetre, tm_config_trv,
		                               vm_fiche.bau_etroite, vm_fiche.bau_i_etroite)

	CASE XZAEC_FMC_BasculTravaux
		ITMA_TMC_config_voies_specifique (tm_config_bascul)
		ITMA_TMC_config_voies_specifique (tm_config_trv)
		/* Visualiser les configurations de voies en travaux et de basculement */
		ITMA_TMC_visu_config_voies (vm_fenetre, tm_config_bascul,
		                               vm_fiche.bau_etroite, vm_fiche.bau_i_etroite)
		ITMA_TMC_visu_config_voies (vm_fenetre, tm_config_trv,
		                               vm_fiche.bau_etroite, vm_fiche.bau_i_etroite)
	ENDCASE
ENDMACRO






/*----------------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Définit puis affiche la configuration des voies en synthétisant
*   la configuration des voies indiquée avec les données
*   des éventuels autres événements situés à la même localisation
*
------------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TMC_config_voies_et_terrain ()

/*
* ARGUMENTS EN ENTREE :
*
* ARGUMENTS EN SORTIE :
* aucun
*
* CODE RETOUR :
* aucun
*
----------------------------------------------------------------------------------*/

	/* Mettre à jour puis visualiser la configuration actuelle des voies */
	ITMA_TMC_Config_Terrain (vm_fiche, tm_config, C_MODULE)
	ITMA_TMC_visu_config_voies (vm_fenetre, tm_config,
	                               vm_fiche.bau_etroite, vm_fiche.bau_i_etroite)


	/* Mettre à jour puis visualiser la config. des voies spécifique au type fmc */
	CASE OF vm_type_fmc
	CASE XZAEC_FMC_Basculement
		ITMA_TMC_config_voies_specifique (tm_config_bascul)
		/* Visualiser les configurations de voies spécifiques au basculement */
		ITMA_TMC_visu_config_voies (vm_fenetre, tm_config_bascul,
		                               vm_fiche.bau_etroite, vm_fiche.bau_i_etroite)

	CASE XZAEC_FMC_Travaux, XZAEC_FMC_ZoneStockage
		ITMA_TMC_config_voies_specifique (tm_config_trv)
		/* Visualiser les configurations de voies spécifiques aux travaux */
		ITMA_TMC_visu_config_voies (vm_fenetre, tm_config_trv,
		                               vm_fiche.bau_etroite, vm_fiche.bau_i_etroite)

	CASE XZAEC_FMC_BasculTravaux
		ITMA_TMC_config_voies_specifique (tm_config_bascul)
		ITMA_TMC_config_voies_specifique (tm_config_trv)
		/* Visualiser les configurations de voies en travaux et de basculement */
		ITMA_TMC_visu_config_voies (vm_fenetre, tm_config_bascul,
		                               vm_fiche.bau_etroite, vm_fiche.bau_i_etroite)
		ITMA_TMC_visu_config_voies (vm_fenetre, tm_config_trv,
		                               vm_fiche.bau_etroite, vm_fiche.bau_i_etroite)
	ENDCASE
ENDMACRO







/*-----------------------------------------------------------------------------
* SERVICE RENDU :
* verifie la validite de la localisation
*
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION ITMA_TMC_verif_localisation(FORMAT COM_localisation va_loc,va_mode_tete,va_flag_config_terrain)

/*
* ARGUMENTS EN ENTREE :
* va_loc: localisation choisie
* va_mode_tete: 1 => on verifie la localisation de la tete
* va_flag_config_terrain: config terrain a rechercher (oui/non)
*
* ARGUMENTS EN SORTIE :
* aucun
*
* CODE RETOUR :
* aucun
*
*
*
-----------------------------------------------------------------------------*/
VAR FORMAT sql_procedure_params@ param_in,vl_parametres
var 	i
var FORMAT sql_procedure_result@ vl_resultats
var vl_msg
var FORMAT TMC_fmc vl_fiche
var vl_indice
var vl_trouve
var vl_multi_ok
var vl_sensQ

	/*! si calcul de la localisation tete de bouchon*/
	IF (va_mode_tete=1)
	{
		vm_local_tete_ok=FALSE
		/*! recupere les infos de la fiche tete de bouchon*/
		vl_fiche=vm_fiche_tete
	}
	ELSE
	{
		vm_local_ok=FALSE
		/*! recupere les infos de la fiche generique*/
		vl_fiche=vm_fiche
	}

	/*! controler qu'une localisation a été choisie   */
	/*! (probleme survenant avec un choix de type de  */
	/*! point caracteristique sur un district n'ayant */
	/*! pas de localisation de ce type                */
	IF NOT IS_NULL@(va_loc.type_point_caract) AND IS_NULL@(va_loc.point_caract)
	{
		INFO_MESSAGE@("La localisation est incorrecte")
		RETURN (COM_NOK)		
	}

	i=0
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].data=va_loc.numauto
	vl_parametres[i].output = FALSE
	i=i+1
	
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].data = va_loc.pr
	vl_parametres[i].output = FALSE
	i=i+1

	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].data = va_loc.sens_circulation
	/*! pour une aire, ne pas utiliser le sens meme s'il est connu */
	/*! pour ne pas obtenir la configuration des voies de la section courante */
	IF va_loc.type_point_caract = XDC_POINT_CARACT_AIRE {
		vl_parametres[i].data = XDC_SENS_INCONNU
	}
	vl_parametres[i].output = FALSE
	i=i+1

	vl_parametres[i].data=va_loc.point_caract
	vl_parametres[i].type =  SYB#INT4_
	vl_parametres[i].output = FALSE
	i=i+1

	vl_parametres[i].data=va_loc.type_point_caract
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = FALSE
	i=i+1

	vl_parametres[i].data=va_loc.position
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = FALSE
	i=i+1

	vl_parametres[i].data=0  'type
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = FALSE
	i=i+1

	vl_parametres[i].data=null 	'autoroute
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	vl_parametres[i].data=null 	'pr
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	vl_parametres[i].data=null 	'sens
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	vl_parametres[i].data=null 	'pt car
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	vl_parametres[i].data=null 	'type pt car
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	vl_parametres[i].data=null 	'position
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	vl_parametres[i].data=null 	'vr
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	vl_parametres[i].data=null 	'vm2
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	vl_parametres[i].data=null 	'vm1
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	vl_parametres[i].data=null 	'vl
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	vl_parametres[i].data=null 	'bau
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	vl_parametres[i].data=null 	'vri
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	vl_parametres[i].data=null 	'vm2i
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	vl_parametres[i].data=null 	'vm1i
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	vl_parametres[i].data=null 	'vli
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	vl_parametres[i].data=null 	'baui
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	vl_parametres[i].data=null 	'bau_etroite
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	vl_parametres[i].data = null 	'baui_etroite
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	vl_parametres[i].data=null 	'district
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	vl_parametres[i].data=null 	'district recouvrement
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	vl_parametres[i].data=null 	'resultat
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE

	IF (COM05_SQL_Procedure (XZAE66_Configuration_Voies,
				  vl_parametres, vl_resultats, C_MODULE) <> COM_OK)
	{
		vl_msg="Erreur dans la vérification de la configuration des voies"
		INFO_MESSAGE@(vl_msg)
		RETURN (COM_NOK)
	}
	ELSE IF vl_resultats.status=XZAEC_LOC_PT_CAR_INC
	{
		INFO_MESSAGE@("Point caractéristique inexistant")
		RETURN (COM_NOK)
	}

	/*suivant la valeur du resultat*/
	CASE OF vl_resultats.return_parameters[20]
		CASE XDC_LOC_SENS_MOD
			INFO_MESSAGE@("Sens incorrect")
			RETURN (COM_NOK)

		CASE XDC_LOC_PR_MOD
			INFO_MESSAGE@("PR incorrect")
			RETURN (COM_NOK)

		CASE XDC_LOC_AUT_MOD
			INFO_MESSAGE@("Autoroute incorrecte")
			RETURN (COM_NOK)

		CASE XDC_LOC_INC
			INFO_MESSAGE@("Localisation incorrecte")
			RETURN (COM_NOK)
	ENDCASE

	/*! si calcul de la localisation tete de bouchon*/
	vl_trouve=0
	vl_multi_ok=1

	IF (vm_flag_bouchon=TRUE)
	{
			/*rechercher dans tm_multi si la config multi autoroute est possible*/
			vm_multi=NULL
		vl_sensQ = vm_fiche.sens
		IF (vm_fiche.sens=XDC_SENS_SORTIE_NORD)  OR (vm_fiche.sens=XDC_SENS_ENTREE_NORD)
			vl_sensQ= XDC_SENS_NORD
		IF (vm_fiche.sens=XDC_SENS_SORTIE_SUD) OR (vm_fiche.sens=XDC_SENS_ENTREE_SUD)
			vl_sensQ= XDC_SENS_SUD
			for vl_indice = 0 TO (ARRAY_SIZE@(tm_multi)-1)
				if ((tm_multi[vl_indice].autoroute_queue= vm_fiche.autoroute) AND
   					(tm_multi[vl_indice].sens_queue = vl_sensQ) AND
					(tm_multi[vl_indice].autoroute_tete = vl_resultats.return_parameters[0]) AND
					(tm_multi[vl_indice].sens_tete = vl_resultats.return_parameters[2])) {
					vl_trouve=1
					vm_multi=tm_multi[vl_indice]
				}
			NEXT vl_indice

	}



	/* si je ne suis pas au CI*/
	IF (vm_site<>XDC_CI) 
	{
		/* la localisation doit rester sur mon site*/
		/* Ajout SAGA :                                         */
		/* sauf dans le cas des districts Aubagne ou Cannet     */
		/* ou la localisation peut etre sur le site de la DDE83 */
		IF ((vl_resultats.return_parameters[18]<>vm_site) AND NOT
		    ((vl_resultats.return_parameters[18] = XDC_DDE83) AND
		     ((vm_site = XDC_DA) OR (vm_site = XDC_VE))))
		{
			INFO_MESSAGE@("L'événement ne peut être localisé que sur votre site")
			RETURN (COM_NOK)
		}
		IF ((vl_resultats.return_parameters[18]<>vm_site) AND 
		    ((vl_resultats.return_parameters[18] = XDC_DDE83) AND
		     ((vm_site = XDC_DA) OR (vm_site = XDC_VE))))
		{
			COM01_Trace(COM_INFO,"demande de confirmation du PR hors réseau")
			if PEND_FOR_NEW_TASK@("ITMA_TCF_Demande_Confirmation",
			                      "Attention, vous avez saisi une localisation hors réseau. Validez-vous ? ") = COM_NOK 
			{
				RETURN (COM_NOK)
			}
		}
	}

	/* la localisation a ete bien saisie*/
	IF (va_mode_tete=1)
		vm_local_tete_ok=TRUE
	ELSE
		vm_local_ok=TRUE

	/* on memorise les valeurs retournees*/
	vl_fiche.autoroute=vl_resultats.return_parameters[0]
	vl_fiche.pr=vl_resultats.return_parameters[1]
	vl_fiche.sens=vl_resultats.return_parameters[2]
	vl_fiche.nom_point_car=vl_resultats.return_parameters[3]
	vl_fiche.point_car=vl_resultats.return_parameters[4]
	vl_fiche.position=vl_resultats.return_parameters[5]
	vl_fiche.vr=vl_resultats.return_parameters[6]
	vl_fiche.vm2=vl_resultats.return_parameters[7]
	vl_fiche.vm1=vl_resultats.return_parameters[8]
	vl_fiche.vl=vl_resultats.return_parameters[9]
	vl_fiche.bau=vl_resultats.return_parameters[10]
	vl_fiche.vr_i=vl_resultats.return_parameters[11]
	vl_fiche.vm2_i=vl_resultats.return_parameters[12]
	vl_fiche.vm1_i=vl_resultats.return_parameters[13]
	vl_fiche.vl_i=vl_resultats.return_parameters[14]	
	vl_fiche.bau_i=vl_resultats.return_parameters[15]
	vl_fiche.bau_etroite=vl_resultats.return_parameters[16]
	vl_fiche.bau_i_etroite=vl_resultats.return_parameters[17]
	vl_fiche.district_loc=vl_resultats.return_parameters[18]

	/*! si c'est un bouchon*/
	IF (vm_flag_bouchon=TRUE)
	{
		/*! les voies sont bloquees par defaut*/
		if vl_fiche.vr=XDC_VOIE_SENS_NORMAL
			vl_fiche.vr=XDC_VOIE_BLOQUEE
		if vl_fiche.vm2=XDC_VOIE_SENS_NORMAL
			vl_fiche.vm2=XDC_VOIE_BLOQUEE
		if vl_fiche.vm1=XDC_VOIE_SENS_NORMAL
			vl_fiche.vm1=XDC_VOIE_BLOQUEE
		if vl_fiche.vl=XDC_VOIE_SENS_NORMAL
			vl_fiche.vl=XDC_VOIE_BLOQUEE
	}

	/*! si calcul de la localisation tete de bouchon*/
	IF (va_mode_tete=1)
	{
		/* met a jour la fiche*/
		vm_fiche_tete=vl_fiche
	}
	ELSE
		vm_fiche=vl_fiche

	/*! si c'est un bouchon*/
	IF (vm_flag_bouchon=TRUE)
	{
			/*rechercher dans tm_multi si la config multi autoroute est possible*/
			vm_multi=NULL
			
			for vl_indice = 0 TO (ARRAY_SIZE@(tm_multi)-1)
				if ((tm_multi[vl_indice].autoroute_queue= vm_fiche.autoroute) AND
   					(tm_multi[vl_indice].sens_queue = vm_fiche.sens) AND
					(tm_multi[vl_indice].autoroute_tete = vm_fiche_tete.autoroute) AND
					(tm_multi[vl_indice].sens_tete = vm_fiche_tete.sens)) {
					vl_trouve=1
					vm_multi=tm_multi[vl_indice]
				}
			NEXT vl_indice
		/*je verifie que les PR du bouchon permettent une localisation multi autoroute*/
		if (vl_trouve=1) {
			vl_multi_ok=TMc_check_PR_multi()
		}

		if (vl_multi_ok=0) {
			INFO_MESSAGE@("les PR de la tête et de la queue de bouchon sont incompatibles")
			IF (va_mode_tete=1)
				vm_local_tete_ok=FALSE
			ELSE
				vm_local_ok=FALSE
			goto POS_CONFIG
		}
		/*! si les sens de la tete et de la queue sont ni nuls ni inconnus
		* je dois verifier qu'ils sont de meme parite*/
		IF ((vm_fiche_tete.sens <> null) AND (vm_fiche.sens <> null) AND
		    (vl_trouve=0) AND
		    (vm_fiche_tete.sens <> XDC_SENS_INCONNU) AND
		    (vm_fiche.sens <> XDC_SENS_INCONNU) AND
		    (vm_fiche_tete.sens MOD 2) <> (vm_fiche.sens MOD 2))
		{
			INFO_MESSAGE@("Les sens de la tête et de la queue de bouchon sont incompatibles")
			IF (va_mode_tete=1)
				vm_local_tete_ok=FALSE
			ELSE
				vm_local_ok=FALSE

			goto POS_CONFIG
		}

		/*! si un des 2 pr de la tete ou de la queue est inconnu ou nul*/
		IF (vm_fiche_tete.pr=XDC_PR_INCONNU) OR (vm_fiche.pr=XDC_PR_INCONNU)
		      OR  (vm_fiche_tete.pr=null) OR (vm_fiche.pr=null)
			/*! pas de calcul de longueur possible*/
			goto POS_CONFIG

		/* calcule la longueur du bouchon et l'affiche*/
		i=0
		vl_parametres=null
		vl_resultats=null
		vl_parametres[i].type = SYB#INT4_
		vl_parametres[i].data=vm_fiche_tete.autoroute
		vl_parametres[i].output = FALSE
		i=i+1

		vl_parametres[i].type = SYB#INT4_
		vl_parametres[i].data = vm_fiche_tete.pr
		vl_parametres[i].output = FALSE
		i=i+1

		vl_parametres[i].type = SYB#INT4_
		vl_parametres[i].data = vm_fiche.autoroute
		vl_parametres[i].output = FALSE
		i=i+1

		vl_parametres[i].data=vm_fiche.pr
		vl_parametres[i].type =  SYB#INT4_
		vl_parametres[i].output = FALSE
		i=i+1

		vl_parametres[i].type =  SYB#INT4_
		vl_parametres[i].output = TRUE

		IF COM05_SQL_Procedure (XZAO22_Distance,
		                        vl_parametres, vl_resultats,C_MODULE)=COM_OK
		{
			vm_tampon_bouchon.longueur=vl_resultats.return_parameters[0]
			/*tm_donnees_specifiques[0]=vm_tampon_bouchon*/
			DB_CTRL_TITLE@(vm_fenetre,"LI_longueurbou", vm_tampon_bouchon.longueur)
		}
	}

POS_CONFIG:
	/* Mettre a jour l'affichage de la configuration des voies */
	/* si on ne valide pas la localisation de tete de bouchon */
	IF (va_mode_tete <> 1) {
		IF (va_flag_config_terrain = XDC_FAUX OR vm_fiche_echangeur = TRUE OR
		       vm_fiche_aire = TRUE OR vm_fiche_frontiere = TRUE)
		{
			ITMA_TMC_config_voies()
		} ELSE {
			ITMA_TMC_config_voies_et_terrain ()
		}
	}

	RETURN (COM_OK)
ENDFUNCTION






/*-----------------------------------------------------------------------------
* SERVICE RENDU :
* affiche la liste des actions réalisées
*
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION ITMA_TMC_actions_realisees(va_horodate)

/*
* ARGUMENTS EN ENTREE :
*
*
* ARGUMENTS EN SORTIE :
* aucun
*
* CODE RETOUR :
* aucun
*
*
*
-----------------------------------------------------------------------------*/
VAR FORMAT sql_procedure_params@ param_in,vl_parametres
var 	i
var FORMAT sql_procedure_result@ vl_resultats
var vl_indice
var FORMAT TMC_actions tl_actions_affichees
VAR vl_num
VAR vl_compteurActions,vl_horodate

	/* si la fiche n'a pas encore ete creee*/
	IF (tm_num_evt.numero=null)
		/* on ne fait rien*/
		RETURN

	/* si l'horodate est nulle*/
	IF (va_horodate=null) {
		vl_horodate=XDC_DATE_NULLE
	} ELSE {
		vl_horodate=va_horodate
	}

	i=0
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].data=tm_num_evt.numero
	vl_parametres[i].output = FALSE
	i=i+1

	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].data = tm_num_evt.cle
	vl_parametres[i].output = FALSE
	i=i+1

	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE

	/* execution de la requete sql*/
	IF COM05_SQL_Procedure (XZAC27_Controler_Modif,
		   vl_parametres, vl_resultats, C_MODULE) <> COM_OK
	{
		INFO_MESSAGE@("Erreur dans la lecture des actions en base")
		 RETURN
	}

	/* s'il n'y a aucune nouvelle action pour cette evenement*/
	IF (NOT IS_NULL@(vm_compteurActions)) AND 
		(vm_compteurActions=vl_resultats.return_parameters[0])
		/* je sors directement de cette fonction*/
		RETURN
	ELSE
		vm_compteurActions=vl_resultats.return_parameters[0]


	/* preparation des parametres de la requete*/
	i=0
	vl_parametres[i].type = SYB#DATETIME_
	vl_parametres[i].data=vl_horodate
	vl_parametres[i].output = FALSE
	i=i+1

	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].data = tm_num_evt.numero
	vl_parametres[i].output = FALSE
	i=i+1

	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].data = tm_num_evt.cle
	vl_parametres[i].output = FALSE

	/* execution de la requete sql*/
	IF COM05_SQL_Procedure (XZAC21_Actions_Evt,
			   vl_parametres, vl_resultats, C_MODULE) <> COM_OK
	{
		INFO_MESSAGE@("Erreur dans la lecture des actions en base")
		 RETURN
	}


	/* memorisation des actions realisees*/
	tm_actions=vl_resultats.select_results[0]
	tl_actions_affichees=tm_actions

	IF ARRAY_SIZE@(tm_actions)<1
	{
		 RETURN
	}

	/* formattage des actions et affichage*/
	FOR vl_indice=0 TO (ARRAY_SIZE@(tm_actions)-1)
		/* recherche du libelle du district*/
		tl_actions_affichees[vl_indice].site=tm_actions[vl_indice].site
		tl_actions_affichees[vl_indice].site_origine=tm_actions[vl_indice].site_origine

		/* libelle de l'etat de l'action*/
		tl_actions_affichees[vl_indice].etat=
						tm_etats_actions[tm_actions[vl_indice].etat]

		/* formattage de l'horodate*/
		tl_actions_affichees[vl_indice].heure=
					COM18_Date_SGBD_Formatee(tm_actions[vl_indice].heure)

		/* libelle de l'action*/
		CASE OF tm_actions[vl_indice].type
 			CASE XDC_ACT_APPEL
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_TELEPHONE++" "++
							tl_actions_affichees[vl_indice].sous_type_astreinte

			CASE XDC_APPEL_RADIO
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_RADIO

 			CASE XDC_ACT_NAV
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_NAV

 			CASE XDC_ACT_PMV
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_PMV

			CASE XDC_ACT_PRV
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_PRV

			CASE XDC_ACT_CFE
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_CFE

			CASE XDC_ACT_IMU
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_IMU

			CASE XDC_ACT_PMVA
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_PMVA

			CASE XDC_ACT_BAF
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_BAF

			CASE XDC_ACT_BAD
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_BAD

 			CASE XDC_ACT_PAL
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_PAL

 			CASE XDC_ACT_FAC
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_FAC

 			CASE XDC_ACT_FAU
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_FAU

 			CASE XDC_ACT_TUNNEL
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_TUNNEL

			/* GTC renovee */
			CASE XDC_ACT_GTC_SIG
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_GTC_SIG
			
			CASE XDC_ACT_GTC_SIG_ECH
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_GTC_SIG_ECH

			CASE XDC_ACT_GTC_ECL
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_GTC_ECL
				
			CASE XDC_ACT_GTC_VEN
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_GTC_VEN
				
			CASE XDC_ACT_GTC_ENR
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_GTC_ENR
				
			CASE XDC_ACT_GTC_EXP
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_GTC_EXP
				
			CASE XDC_ACT_GTC_INC
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_GTC_INC
			/* Fin GTC renovee */

 			CASE XDC_ACT_DEPANNEUR
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_DEPANNEUR

 			CASE XDC_ACT_AFF_GARE
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_AFF_GARE

 			CASE XDC_ACT_PAT_SIS
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_PAT_SIS

			CASE XDC_ACT_INTERVENTION
				tl_actions_affichees[vl_indice].type=
                              tl_actions_affichees[vl_indice].sous_type_astreinte

 			CASE XDC_ACT_PMV_REMORQUE
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_PMV_REMORQUE

 			CASE XDC_ACT_PMV_FOURGON
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_PMV_FOURGON

 			CASE XDC_ACT_TFM
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_TFM

 			CASE XDC_ACT_ECHANGEUR
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_ECHANGEUR

 			CASE XDC_ACT_FAX
				if tl_actions_affichees[vl_indice].sous_type_astreinte= "SMS"
					tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_SMS
				else
					tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_FAX

 			CASE XDC_ACT_BIP
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_BIP

 			CASE XDC_ACT_EXP
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_EXP

 			CASE XDC_ACT_EXPTFM
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_EXPTFM

 			CASE XDC_ACT_PMVDAT
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_PMVDAT

                        /* Ajout SAGA */
			CASE XDC_ACT_DATEX
				tl_actions_affichees[vl_indice].type= tl_actions_affichees[vl_indice].sous_type_astreinte

			CASE XDC_ACT_SAGA
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_SAGA
 			
			CASE XDC_ACT_CCH
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_CCH
			
			CASE XDC_ACT_SMS
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_SMS

			CASE XDC_ACT_PAU
				tl_actions_affichees[vl_indice].type=XDC_ACT_LIB_PAU

		ENDCASE
	NEXT vl_indice

	DB_TABLE_CLEAR_DATA@(vm_fenetre,"TA_actions_realisees",0,-1)	DB_TABLE_SET_NEW_DATA@(vm_fenetre,"TA_actions_realisees",
							tl_actions_affichees,0)

ENDFUNCTION






/*-----------------------------------------------------------------------------
* SERVICE RENDU :
* affiche la liste des commentaires
*
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION ITMA_TMC_formater_date_comment()

/*
* ARGUMENTS EN ENTREE :
*
*
* ARGUMENTS EN SORTIE :
* aucun
*
* CODE RETOUR :
* aucun
*
*
*
-----------------------------------------------------------------------------*/
VAR vl_indice

	FOR vl_indice=0 TO  ARRAY_SIZE@(tm_comment)-1
		IF (tm_comment[vl_indice].fin<>XDC_DATE_NULLE) AND 
			(tm_comment[vl_indice].fin <> "")
			tm_comment[vl_indice].fin = COM18_Date_SGBD_Formatee(tm_comment[vl_indice].fin)
		IF (tm_comment[vl_indice].validation<>XDC_DATE_NULLE) AND
			(tm_comment[vl_indice].validation <> "")
			tm_comment[vl_indice].validation = COM18_Date_SGBD_Formatee(tm_comment[vl_indice].validation)
	NEXT vl_indice

ENDMACRO






/*-----------------------------------------------------------------------------
* SERVICE RENDU :
* affiche la liste des commentaires
*
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION ITMA_TMC_affiche_comment()

/*
* ARGUMENTS EN ENTREE :
*
*
* ARGUMENTS EN SORTIE :
* aucun
*
* CODE RETOUR :
* aucun
*
*
*
-----------------------------------------------------------------------------*/
VAR FORMAT TMC_comment tl_comment
VAR vl_indice
VAR tl_pixmaps

	tl_comment=tm_comment
	FOR vl_indice=0 TO (ARRAY_SIZE@(tm_comment)-1)
		/* transforme les dates XDC_DATE_NULLE ou "" en null*/
		IF (tl_comment[vl_indice].fin=XDC_DATE_NULLE) OR 
			(tl_comment[vl_indice].fin = "")
			tl_comment[vl_indice].fin=null
		ELSE
			tl_comment[vl_indice].fin="x"
		IF (tl_comment[vl_indice].validation=XDC_DATE_NULLE)
			tl_comment[vl_indice].validation=null
		IF (tl_comment[vl_indice].numero=null)
			tl_comment[vl_indice].numero=0
		IF (tl_comment[vl_indice].site=vm_site)
			tl_pixmaps[vl_indice]=C_PICTO_ENRICHIR,null
		ELSE
			tl_pixmaps[vl_indice]=C_PICTO_PAR_DEFAUT,null
	NEXT vl_indice
	DB_TABLE_CLEAR_DATA@(vm_fenetre,"TA_comment",0,-1)
	DB_TABLE_SET_NEW_DATA@(vm_fenetre,"TA_comment",tl_comment,0)
	DB_TABLE_MARKER_PIXMAPS@(vm_fenetre,"TA_comment",0,tl_pixmaps)
ENDFUNCTION






/*-----------------------------------------------------------------------------
* SERVICE RENDU :
* valide la localisation
*
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION ITMA_TMC_valide_localisation (FORMAT COM_Localisation va_loc, va_valide_tete)

/*
* ARGUMENTS EN ENTREE :
*   va_loc            : localisation a valider.
*   va_valide_tete    : indicateur de validation de la tete de bouchon.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR :
*  OK / NOK selon la validite de la localisation
*
*
-----------------------------------------------------------------------------*/
VAR FORMAT TMC_fmc vl_fiche
VAR vl_sens
VAR vl_i
VAR localisation
VAR vl_boite_edition
VAR vl_config_terrain

	/*! note dans quelle boite d'edition afficher la localisation */
	IF (va_valide_tete = 1)
	{
		vl_boite_edition = "BE_local_tetebou"
	}
	ELSE
	{
		vl_boite_edition = "BE_localisation"
	}

	/* verifie la validite de la localisation choisie*/
	IF (vm_mode_appel = MODE_CREATION AND vm_etat_fmc = XDC_FMC_ETAT_TRAI) {
		vl_config_terrain = XDC_VRAI
	} ELSE {
		vl_config_terrain = XDC_FAUX
	}


	IF (ITMA_TMC_verif_localisation (va_loc, va_valide_tete, vl_config_terrain) = COM_OK) {
		/*! si calcul de la localisation tete de bouchon */
		IF (va_valide_tete = 1)
		{
			/*! recupere les infos de la fiche tete de bouchon */
			vl_fiche = vm_fiche_tete
		}
		ELSE
		{
			/*! recupere les infos de la fiche generique */
			vl_fiche = vm_fiche
			vm_fiche_queue = vm_fiche
		}

		/*! initialiser le libelle du sens a sa valeur par defaut */
		vl_i = COM45_IndexEnColonne (tm_sens_echangeur, TDO_NUMERO_SENS,
		                                vl_fiche.Sens)
		IF (vl_i < 0) {
			vl_sens = null
		} ELSE IF (vl_fiche.Sens = XDC_SENS_INCONNU)  and
			   (vm_type_fmc = XZAEC_FMC_Meteo  or
			    vm_type_fmc = XZAEC_FMC_Inondation  or
			    vm_type_fmc = XZAEC_FMC_TraitChaussees) {
			vl_sens = XDC_LIB_2_SENS
		} ELSE {
			vl_sens = "sens " ++ tm_sens_echangeur[vl_i].nom
		}

		/* suivant le type de point caracteristique */
		CASE OF va_loc.type_point_caract

		/* aire */
		CASE XDC_POINT_CARACT_AIRE
			vl_i = COM45_IndexEnColonne (tm_aires, TDO_NUMERO_AIRE,
			                                va_loc.point_caract)
			localisation[1] = "Sur l'aire " ++ tm_aires[vl_i].nom

		/* echangeur*/
		CASE XDC_POINT_CARACT_ECHANGEUR
			vl_i = COM45_IndexEnColonne (tm_echangeurs,TDO_NUMERO_ECH,
			                                     va_loc.point_caract)

			vl_sens = ARRAY_FROM_STRING@ (vl_sens, ",")
			IF (vl_sens[1] <> null) {
				localisation[1] = "Sur la " ++ vl_sens[1] ++
				      " de l'échangeur " ++ tm_echangeurs[vl_i].nom
			} ELSE {
				localisation[1] = "Sur l'échangeur " ++
				                     tm_echangeurs[vl_i].nom
			}
			vl_sens = vl_sens[0]

		/* peage */
		CASE XDC_POINT_CARACT_PEAGE
			vl_i = COM45_IndexEnColonne (tm_gares, TDO_NUMERO_GARE,
			                                va_loc.point_caract)
			localisation[1] = "Sur le péage " ++ tm_gares[vl_i].nom

		/* lit d'arret */
		CASE XDC_POINT_CARACT_LIT_ARRET
			vl_i = COM45_IndexEnColonne (tm_lits_arret, TDO_NUMERO_LIT,
			                                va_loc.point_caract)
			localisation[1] = "Sur le lit d'arrêt " ++
			                     tm_lits_arret[vl_i].nom

		/* section courante */
		DEFAULT
			localisation[1] = "Sur la section courante"
		ENDCASE


		/* nom de l'autoroute */
		vl_i = COM45_IndexEnColonne (tm_autoroutes, TDO_NUMERO_AUTOROUTE,
		                                vl_fiche.autoroute)

		/* Construire l'intitulé de la localisation et l'afficher */
		localisation[0] = "Autoroute " ++ tm_autoroutes[vl_i].nom ++
		                     ", " ++ vl_sens ++
		                     ", au PR " ++ (vl_fiche.pr / 1000)
		DB_EDITBOX_SET_DATA@ (vm_fenetre, vl_boite_edition, localisation)


		/* degriser le bouton de config terrain sauf pour une tete de bouchon */
		if (va_valide_tete = 0)
			DB_CTRL_GRAYED@ (vm_fenetre, "BP_config_terrain", FALSE)


		/* suppression : si on est au CI en creation, */
		/*  tester si la localisation est sur un site en mode degrade *
		IF (vm_mode_appel = MODE_CREATION AND vm_etat_fmc = XDC_FMC_ETAT_TRAI AND vm_site = XDC_CI)
		{
			vl_i = ARRAY_INDEX@ (ARRAY_COLUMN@ (tm_sites, TDO_NUMERO_DISTRICT),
			                             vl_fiche.district_loc)

			* fmc a creer est de type degrade *
			IF ((SYSTEM_VAR@(vg_comm_++tm_sites[vl_i] [TDO_CODE_DISTRICT])<> XDC_OK) AND
				(tm_sites[vl_i][TDO_TYPE_DISTRICT] = XDC_TYPE_PCNIVEAU2))
			{
				* afficher les widgets FMC origine *
				DB_CTRL_DISPLAY@(vm_fenetre,"BS_Com_FMC_Init",TRUE)
				DB_CTRL_DISPLAY@(vm_fenetre,"LI_FMC_Initiale",TRUE)
				DB_CTRL_DISPLAY@(vm_fenetre,"TAB_FMC_Initiale",TRUE)
				vm_fiche.degrade = XDC_OUI
			}
			* fmc a creer n'est pas de type degrade *
			ELSE
			{
				* afficher les widgets FMC origine *
				DB_CTRL_DISPLAY@(vm_fenetre,"BS_Com_FMC_Init",FALSE)
				DB_CTRL_DISPLAY@(vm_fenetre,"LI_FMC_Initiale",FALSE)
				DB_CTRL_DISPLAY@(vm_fenetre,"TAB_FMC_Initiale",FALSE)
				vm_fiche.degrade = XDC_NON
			}
		}
		*/

		RETURN (COM_OK)
	}

	RETURN (COM_NOK)

ENDFUNCTION






/*-----------------------------------------------------------------------------
* SERVICE RENDU :
* remplit les champs horodate avec l'horodate courante
*
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION ITMA_TMC_aide_horodate(va_controle)

/*
* ARGUMENTS EN ENTREE :
*
* ARGUMENTS EN SORTIE :
* aucun
*
* CODE RETOUR :
* aucun
*
*
*
-----------------------------------------------------------------------------*/
VAR	vl_string, vl_i, vl_date_fin_nulle
VAR	FORMAT TMC_neutral	tl_neutral

	/* recupere l'heure courante et la formate*/
	vl_string=COM09_Date_Courante(TRUE)

	CASE OF va_controle
		/* horodate debut prevu*/
		CASE "BP_horodebut_prevue"
			COM24_Afficher_Horodate(vl_string,vm_fenetre,
								"BS_jour_debut_prevu",
								"BS_mois_debut_prevu",
								"BS_annee_debut_prevu",
								"BS_heure_debut_prevu",
								"BS_minute_debut_prevu")
			/*! pour des travaux prévus, mettre les minutes de date début prévu à 0 */
			IF (vm_etat_fmc = XDC_FMC_ETAT_PREV) AND
			     (vm_type_fmc = XZAEC_FMC_Travaux OR
			      vm_type_fmc = XZAEC_FMC_ZoneStockage OR
			      vm_type_fmc = XZAEC_FMC_BasculTravaux)
			{
				DB_CTRL_VALUE@ (vm_fenetre, "BS_minute_debut_prevu", "00")
			}


		/* horodate debut*/
		CASE "BP_horodebut_reelle"
			COM24_Afficher_Horodate(vl_string,vm_fenetre,
								"BS_jour_debut_reel",
								"BS_mois_debut_reel",
								"BS_annee_debut_reel",
								"BS_heure_debut_reel",
								"BS_minute_debut_reel",
								"BS_seconde_debut_reel")


		/* horodate fin prevu*/
		CASE "BP_horofin_prevue"
			COM24_Afficher_Horodate(vl_string,vm_fenetre,
								"BS_jour_fin_prevue",
								"BS_mois_fin_prevue",
								"BS_annee_fin_prevue",
								"BS_heure_fin_prevue",
								"BS_minute_fin_prevue")
			/*! pour des travaux prévus, mettre les minutes de date fin prévue à 0 */
			IF (vm_etat_fmc = XDC_FMC_ETAT_PREV) AND
			     (vm_type_fmc = XZAEC_FMC_Travaux OR
			      vm_type_fmc = XZAEC_FMC_ZoneStockage OR
			      vm_type_fmc = XZAEC_FMC_BasculTravaux)
			{
				DB_CTRL_VALUE@ (vm_fenetre, "BS_minute_fin_prevue", "00")
			}


		/* horodate fin*/
		CASE "BP_horofin_reelle"
			/*! dans le cas de travaux, si des dates de fin sur voies */
			/*! neutralisees ne sont pas renseignees, les mettre a jour */
			IF (vm_type_fmc = XZAEC_FMC_Travaux) OR
			   (vm_type_fmc = XZAEC_FMC_ZoneStockage) OR
			   (vm_type_fmc = XZAEC_FMC_BasculTravaux)
			{
				tl_neutral = DB_TABLE_GET_DATA@ (vm_fenetre, "TA_neutral_trv")

				vl_date_fin_nulle = FALSE
				FOR vl_i = 0 TO ARRAY_SIZE@ (tl_neutral) - 1
					IF tl_neutral[vl_i].horodate_fin = NULL {
						vl_date_fin_nulle = TRUE
						tl_neutral[vl_i].horodate_fin = vl_string
					}
				NEXT vl_i

				IF (vl_date_fin_nulle) {
					DB_TABLE_CLEAR_DATA@ (vm_fenetre, "TA_neutral_trv", 0, -1)
					DB_TABLE_SET_DATA@(vm_fenetre, "TA_neutral_trv",tl_neutral)

					/* remettre la configuration des voies a la normale */
					FOR vl_i = 0 TO ARRAY_SIZE@ (tm_config) - 1
						IF (vl_i = 0) OR (vl_i = 5)
							tm_config[vl_i][1] = XDC_VOIE_BAU_NORMALE
						ELSE
							tm_config[vl_i][1] = XDC_VOIE_SENS_NORMAL
					NEXT vl_i
					ITMA_TMC_config_voies ()
				}
			}

			/* mettre a jour la date de fin reelle */
			COM24_Afficher_Horodate(vl_string,vm_fenetre,
								"BS_jour_fin_reelle",
								"BS_mois_fin_reelle",
								"BS_annee_fin_reelle",
								"BS_heure_fin_reelle",
								"BS_minute_fin_reelle",
								"BS_seconde_fin_reelle")


		/* horodate debut travaux*/
		CASE "BP_horohelp_debuttrv"
			COM24_Afficher_Horodate(vl_string,vm_fenetre,
								"BS_jd_trv",
								"BS_md_trv",
								"BS_ad_trv",
								"BS_hd_trv",
								"BS_mid_trv")
			/*! pour des travaux prévus, mettre les minutes de date début à 0 */
			IF (vm_etat_fmc = XDC_FMC_ETAT_PREV)
				DB_CTRL_VALUE@ (vm_fenetre, "BS_mid_trv", "00")


		/* horodate fin travaux*/
		CASE "BP_horohelp_fintrv"
			COM24_Afficher_Horodate(vl_string,vm_fenetre,
								"BS_jf_trv",
								"BS_mf_trv",
								"BS_af_trv",
								"BS_hf_trv",
								"BS_mif_trv")
			/*! pour des travaux prévus, mettre les minutes de date fin à 0 */
			IF (vm_etat_fmc = XDC_FMC_ETAT_PREV)
				DB_CTRL_VALUE@ (vm_fenetre, "BS_mif_trv", "00")
	ENDCASE
ENDFUNCTION






/*-----------------------------------------------------------------------------
* SERVICE RENDU :
* visualise ou cache les champs d'un certain type
*
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TMC_visible(va_type, va_visible)

/*
* ARGUMENTS EN ENTREE :
*   va_type    : indicateur du type des champs concernes ;
*   va_visible : indicateur de visibilite (vrai ou faux).
*
* ARGUMENTS EN SORTIE :
* aucun
*
* CODE RETOUR :
* aucun
*
*
*
-----------------------------------------------------------------------------*/
VAR vl_liste, i

	/* Determine selon le type les objets graphiques concernes */
	CASE OF va_type
		/* horodate debut */
		CASE "Date debut"
			vl_liste = "LI_horodate_début_réelle", "BP_horodebut_reelle",
						"LI_Slash1_début_réel", "LI_Slash2_début_réel",
						"LI_deux_points_début_réel", "BS_jour_debut_reel",
						"BS_mois_debut_reel", "BS_annee_debut_reel",
						"BS_heure_debut_reel", "BS_minute_debut_reel"

		/* horodate fin */
		CASE "Date fin"
			vl_liste = "LI_horodate_fin_réelle", "BP_horofin_reelle",
						"LI_slash1_fin_réelle", "LI_slash2_fin_réelle",
						"LI_deux_points_fin_réelle", "BS_jour_fin_reelle",
						"BS_mois_fin_reelle", "BS_annee_fin_reelle",
						"BS_heure_fin_reelle", "BS_minute_fin_reelle"

		/* horodate debut prevue */
		CASE "Date debut prevue"
			vl_liste = "LI_horodate_début_prévue", "BP_horodebut_prevue",
						"LI_slash1_début_prévu", "LI_slash2_début_prévu",
						"LI_deux_points_début_prévu", "BS_jour_debut_prevu",
						"BS_mois_debut_prevu", "BS_annee_debut_prevu",
						"BS_heure_debut_prevu", "BS_minute_debut_prevu"

		/* horodate fin prevue */
		CASE "Date fin prevue"
			vl_liste = "LI_horodate_fin_prévue", "BP_horofin_prevue",
						"LI_slash1_fin_prévue", "LI_slash2_fin_prévue",
						"LI_deux_points_fin_prévue", "BS_jour_fin_prevue",
						"BS_mois_fin_prevue", "BS_annee_fin_prevue",
						"BS_heure_fin_prevue", "BS_minute_fin_prevue"

		/* horodates travaux */
		CASE "Dates travaux"
			vl_liste = "BP_horohelp_debuttrv", "BP_horohelp_fintrv",
						"BS_jd_trv", "BS_md_trv", "BS_ad_trv",
						"BS_hd_trv", "BS_mid_trv",
						"BS_jf_trv", "BS_mf_trv", "BS_af_trv",
						"BS_hf_trv", "BS_mif_trv"
	ENDCASE


	FOR i = 0  TO ARRAY_SIZE@ (vl_liste) - 1
		DB_CTRL_DISPLAY@ (vm_fenetre, vl_liste[i], va_visible)
	NEXT i

ENDMACRO






/*-----------------------------------------------------------------------------
* SERVICE RENDU :
* gere les actions liees au bouton enrichir
*
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION ITMA_TMC_enrichir()

/*
* ARGUMENTS EN ENTREE :
*
* ARGUMENTS EN SORTIE :
* aucun
*
* CODE RETOUR :
* aucun
*
*
*
-----------------------------------------------------------------------------*/
VAR vl_titre
VAR tl_num_surcharge


	/*! si la surcharge est en cours pour cette fiche*/
	tl_num_surcharge=SYSTEM_VAR@(vg_fiche_surcharge)
	IF (SYSTEM_VAR@(vg_surcharge)=TRUE) {
	 	IF (tl_num_surcharge[0]=vm_fiche.numero) AND
			(tl_num_surcharge[1]=vm_fiche.cle) AND 
			(vm_mode_appel <> MODE_CREATION)
				INFO_MESSAGE@("Attention: l'événement est en surcharge au CI")
	}

	/* je dis a l'operateur qu'il enrichit*/
	DB_CTRL_DISPLAY@(vm_fenetre,"BP_libenrichir",TRUE)


ENDFUNCTION





/*-----------------------------------------------------------------------------
* SERVICE RENDU :
* recherche le numero de point caracteristique pour une fmc
*
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO Initialiser_Point_Caract_Fiche(va_fenetre,FORMAT TMC_fmc va_fiche)

/*
* ARGUMENTS EN ENTREE :
*    va_fenetre	:	ID de la fentre
*    va_fiche	:	description de la fmc 
*
* ARGUMENTS EN SORTIE :
* aucun
*
* CODE RETOUR :
* aucun
*
*
*
/*---------------------------------------------------------------------------*/

VAR	tl_noms_ptcar
VAR	vl_nom
VAR	i

	vl_nom = TRIM@ (SUBSTRING@ (va_fiche.nom_point_car, 1, 25))

	CASE OF va_fiche.point_car
		CASE XDC_POINT_CARACT_AIRE
			tl_noms_ptcar = ARRAY_COLUMN@ (tm_aires, TDO_NOM_AIRE)
			i = ARRAY_INDEX@ (tl_noms_ptcar, vl_nom)
			va_fiche.num_point_car = tm_aires[i].numero
			va_fiche.nom_point_car = tm_aires[i].numero

		CASE XDC_POINT_CARACT_ECHANGEUR
			tl_noms_ptcar = ARRAY_COLUMN@ (tm_echangeurs, TDO_NOM_ECHANGEUR)
			i = ARRAY_INDEX@ (tl_noms_ptcar, vl_nom)
			va_fiche.num_point_car = tm_echangeurs[i].numero
			va_fiche.nom_point_car = tm_echangeurs[i].numero

		CASE XDC_POINT_CARACT_PEAGE
			tl_noms_ptcar = ARRAY_COLUMN@ (tm_gares, TDO_NOM_GARE)
			i = ARRAY_INDEX@ (tl_noms_ptcar, vl_nom)
			va_fiche.num_point_car = tm_gares[i].numero
			va_fiche.nom_point_car = tm_gares[i].numero

		CASE XDC_POINT_CARACT_LIT_ARRET
			tl_noms_ptcar = ARRAY_COLUMN@ (tm_lits_arret, TDO_NOM_LIT)
			i = ARRAY_INDEX@ (tl_noms_ptcar, vl_nom)
			va_fiche.num_point_car = tm_lits_arret[i].numero
			va_fiche.nom_point_car = tm_lits_arret[i].numero

		DEFAULT
			va_fiche.num_point_car = NULL
			va_fiche.nom_point_car = NULL
	ENDCASE
ENDMACRO






/* ----------------------------------------------------------------------------
* SERVICE RENDU :
* charge les vehicules associes a l'evenement
*
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION  ITMA_TMC_compte_vehicules(va_numero_evt,va_cle_evt,va_horodate)

/*
* ARGUMENTS EN ENTREE :
* numero d'evenement
* cle d'evenement
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : Indefini
*
* CONDITION D'UTILISATION
*   MTMC
*
* FONCTION
-----------------------------------------------------------------------------*/
VAR FORMAT SQL_Procedure_Params@ vl_parametres
VAR FORMAT SQL_Procedure_Result@ vl_resultats
VAR vl_indice, vl_liste_vehicule

	vl_liste_vehicule = null

	/* preparation de la requete*/
	vl_indice=0
	vl_parametres[vl_indice].type = SYB#DATETIME_
	vl_parametres[vl_indice].data=va_horodate
	vl_parametres[vl_indice].output = FALSE
	vl_indice=vl_indice+1


	vl_parametres[vl_indice].type = SYB#INT4_
	vl_parametres[vl_indice].data = va_numero_evt
	vl_parametres[vl_indice].output = FALSE
	vl_indice=vl_indice+1

	vl_parametres[vl_indice].type = SYB#INT4_
	vl_parametres[vl_indice].data = va_cle_evt
	vl_parametres[vl_indice].output = FALSE

        /* * requete SYBASE*/
        IF (COM05_SQL_Procedure (XZAE95_Lire_Liste_Vehicule,
                           vl_parametres, vl_resultats, C_MODULE) <> COM_OK)
        {
                INFO_MESSAGE@("Impossible de lire les informations en base")
                RETURN (COM_NOK)
        }
	vl_liste_vehicule = vl_resultats.select_results[0]
	return(ARRAY_SIZE@(vl_liste_vehicule))
ENDMACRO





/*-----------------------------------------------------------------------------
* SERVICE RENDU :
* Affichage ou non du type precedent de la fmc
*
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO TMC_AffichageTypePrecedentFMC (va_fenetre, va_Type_FMC, va_Type_Precedent_FMC,
                                    FORMAT TDO_Type_FMC ta_types_fmc, va_mode_formation)

/*
* ARGUMENTS EN ENTREE :
*    va_fenetre	:	ID de la fentre
*    va_Type_FMC	:	type de la fmc 
*    va_Type_Precedent_FMC	:	type precedent de la fmc 
*    ta_types_fmc	:	tableau de toutes les types de fmc 
*    va_mode_formation	:	TRUE si en mode formation 
*
* ARGUMENTS EN SORTIE :
*    néant
*
* CODE RETOUR :
* aucun
*
*
-----------------------------------------------------------------------------*/
var vl_id

IF va_mode_formation=TRUE
	RETURN

/* Si la FMC a été retypée alors */
IF (va_Type_Precedent_FMC <> va_Type_FMC) AND (va_Type_Precedent_FMC <> NULL)
{
	/* afficher le type precedent et mettre a jour l'intitulé */
	DB_CTRL_DISPLAY@(va_fenetre,"LI_Type_Precedent",TRUE)
	DB_CTRL_DISPLAY@(va_fenetre,"LI_Nom_Type_Precedent",TRUE)
	vl_id = COM45_IndexEnColonne(ta_types_fmc,TDO_NUMERO_FMC,va_Type_Precedent_FMC)

	DB_CTRL_TITLE@ (va_fenetre, "LI_Nom_Type_Precedent", ta_types_fmc[vl_id].nom)
}
ELSE
{
	/* sinon ne pas afficher le type precedent */
	DB_CTRL_DISPLAY@(va_fenetre,"LI_Type_Precedent",FALSE)
	DB_CTRL_DISPLAY@(va_fenetre,"LI_Nom_Type_Precedent",FALSE)
}

ENDMACRO





/*-----------------------------------------------------------------------------
* SERVICE RENDU :
* Initialiser ou réinitialiser la liste des types fmc pour retypage
*
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION TMC_AffichageListeTypesFMC (va_fenetre, va_Type_FMC, va_Veracite,
					FORMAT TDO_Type_FMC ta_types_fmc,
					va_Etat_FMC, va_Mode_FMC, va_Enrichir)

/*
* ARGUMENTS EN ENTREE :
*    va_fenetre	:	ID de la fentre
*    va_Type_FMC	:	type de la fmc 
*    va_Veracite	:	veracite de la fmc 
*    ta_types_fmc	:	tableau de toutes les types de fmc 
*    va_Etat_FMC	:	etat de la fmc (prevision, traiter, clos)
*    va_Mode_FMC	:	mode de traitement la fmc (creation, modif.)
*    va_Enrichir	:	droits sur la fmc 
*
* ARGUMENTS EN SORTIE :
*    tl_ListeTypesFMC	:	tableau des types de fmc de retypage
*
* CODE RETOUR :
*
*
-----------------------------------------------------------------------------*/

VAR	FORMAT TDO_Type_FMC tl_ListeTypesFMC
VAR	vl_retypage_permis
VAR	vl_indice
VAR	i

/* Initialiser la liste des types avec le type fmc lui-même */
vl_indice = COM45_IndexEnColonne (ta_types_fmc, TDO_NUMERO_FMC, va_Type_FMC)
tl_ListeTypesFMC = { ta_types_fmc[vl_indice] }

/* On ne peut retyper une operation, une fiche close ou confirmee. */
/* Un operateur ne peut retyper que s'il a le droit d'enrichir la fiche */
vl_retypage_permis = TRUE
IF (tl_ListeTypesFMC[0].operation = XDC_VRAI)  OR
   (va_Etat_FMC = XDC_FMC_ETAT_CLOS)  OR
   (va_Veracite = XZAEC_FMC_CONFIRMEE)  OR
   (va_Enrichir = 0)
{
	vl_retypage_permis = FALSE
}
ELSE IF (va_Type_FMC = XZAEC_FMC_Meteo)  AND  (va_Mode_FMC <> MODE_CREATION)
{
	IF ITMA_TMC_met_nature_CCH (va_fenetre, va_Type_FMC) = XDC_VRAI
		vl_retypage_permis = FALSE
}

/* Si la fiche peut etre retypee alors */
IF (vl_retypage_permis = TRUE)
{
	DB_CTRL_RETURN_ON_CHANGE@(va_fenetre,"BO_TypeFMC",TRUE)

	/* ajouter a la liste les types de la meme classe */
	i = 1
	FOR vl_indice = 0 TO ARRAY_SIZE@ (ta_types_fmc) - 1
		IF (ta_types_fmc[vl_indice].classe = tl_ListeTypesFMC[0].classe AND 
			ta_types_fmc[vl_indice].numero <> va_Type_FMC AND
			ta_types_fmc[vl_indice].numero <> XZAEC_FMC_TeteBouchon AND
			ta_types_fmc[vl_indice].operation <> XDC_VRAI)  OR
		   (tl_ListeTypesFMC[0].classe = XZAEC_ClasseAccident AND
		       ta_types_fmc[vl_indice].classe = XZAEC_ClasseVehicule)  OR
		   (tl_ListeTypesFMC[0].classe = XZAEC_ClasseVehicule AND
		       ta_types_fmc[vl_indice].classe = XZAEC_ClasseAccident)
		{
			tl_ListeTypesFMC[i] = ta_types_fmc[vl_indice]
			i = i + 1
		}
	NEXT vl_indice
}

/* Initialiser le bouton de choix du type avec la liste */
/* et selectionner par defaut le type Fmc lui-meme */
DB_CTRL_STRINGS@ (va_fenetre, "BO_TypeFMC",
		     ARRAY_COLUMN@ (tl_ListeTypesFMC, TDO_NOM_FMC))
DB_CTRL_VALUE@(va_fenetre,"BO_TypeFMC",0)

	RETURN (tl_ListeTypesFMC)
ENDMACRO






/*-----------------------------------------------------------------------------
* SERVICE RENDU :
*  modifie la date de cloture pour purge
*
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION  ITMA_TMC_cloture_purge(va_numero,va_cle)

/*
* ARGUMENTS EN ENTREE :
* numero d'evenement
* cle d'evenement
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : Indefini
*
* CONDITION D'UTILISATION
*   MTMC
*
* FONCTION
-----------------------------------------------------------------------------*/
VAR FORMAT SQL_Procedure_Params@ vl_parametres
VAR FORMAT SQL_Procedure_Result@ vl_resultats
VAR vl_indice
VAR vl_msg
VAR vl_args, vl_DateCourante

	vl_DateCourante = COM09_Date_Courante(FALSE)

	/* preparation de la requete*/
	vl_indice=0
	vl_parametres[vl_indice].type = SYB#INT4_
	vl_parametres[vl_indice].data = va_numero
	vl_parametres[vl_indice].output = FALSE
	vl_indice=vl_indice+1

	vl_parametres[vl_indice].type = SYB#INT4_
	vl_parametres[vl_indice].data = va_cle
	vl_parametres[vl_indice].output = FALSE
	vl_indice=vl_indice+1

	vl_parametres[vl_indice].type = SYB#DATETIME_
	vl_parametres[vl_indice].data = vl_DateCourante
	vl_parametres[vl_indice].output = FALSE
	vl_indice=vl_indice+1

/*B Site local */
        vl_parametres[vl_indice].type = SYB#CHAR_
        vl_parametres[vl_indice].data = SYSTEM_VAR@(vg_nom_site)
        vl_parametres[vl_indice].output = FALSE
        vl_indice = vl_indice +1

        /* requete SYBASE*/
        IF (COM05_SQL_Procedure (XZAE110_Annuler_FMC_A_traiter,
                           vl_parametres, vl_resultats, C_MODULE) <> COM_OK)
        {
                INFO_MESSAGE@("Erreur lors de la tentative d'annulation de la FMC")
                RETURN (COM_NOK)
        }
        ELSE IF vl_resultats.status <> XDC_OK
        {
                CASE OF vl_resultats.status
                        CASE XDC_ARG_INV
                                vl_msg="Arguments en entrée invalides"

                        CASE XDC_PRC_INC
                                vl_msg="Procédure stockée inexistante en base"

                        CASE XZAEC_FMC_PAS_ENR
                                vl_msg="Evénement non modifiable par cet opérateur"

                        CASE XZAEC_FMC_ACT_NON_FIN
                                vl_msg="Actions relatives à l'événement non terminées"

                        CASE XZAEC_FMC_A_TRT
                                vl_msg="Evénement à traiter dans une région"

                        CASE XZAEC_FMC_NON_FIN
                                vl_msg="Evénement non terminé"

                        DEFAULT
                                vl_msg="impossible d'annuler la fmc en base"
                ENDCASE

			/* prevenir la liste a traiter du chgt d'etat de la fmc si evt en
			    cours sur un autre district : fmc terminee , et positionner
			    la date de fin */
			 IF	vl_resultats.status <> XZAEC_FMC_PAS_ENR AND 
				vl_resultats.status <> XDC_ARG_INV AND 
				vl_resultats.status <> XDC_PRC_INC
			{
				COM24_Afficher_Horodate(vl_DateCourante,vm_fenetre,
								"BS_jour_fin_reelle",
								"BS_mois_fin_reelle",
								"BS_annee_fin_reelle",
								"BS_heure_fin_reelle",
								"BS_minute_fin_reelle",
								"BS_seconde_fin_reelle")

				vl_args=0++COM_SEPAR_CHAMPS++0
				DB_SEND_POKE@(COM_CANAL_MTLT,vl_args)
 			}
				
                INFO_MESSAGE@(vl_msg)
                RETURN (COM_NOK)
        }
	return(COM_OK)
ENDMACRO






/*-----------------------------------------------------------------------------
* SERVICE RENDU :
*  Appel de la fenetre d'envoi de fax et envoi toutes les infos sur la fmc
*
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO  ITMA_TMC_Envoi_Fax(va_fenetre, FORMAT TMC_fmc va_fiche, va_tampon)

/*
* ARGUMENTS EN ENTREE :
*   va_fenetre        : ID de la fenetre
*   va_fiche          : infos generiques de la fmc
*   va_tampon         : infos specifiques de la fmc
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : Indefini
*
* CONDITION D'UTILISATION
*   MTMC
*
* FONCTION
-----------------------------------------------------------------------------*/
VAR tl_InfoGeneral

        /* parametres generaux (format des parametres d'action) */
        tl_InfoGeneral[0] = va_fiche.numero
        tl_InfoGeneral[1] = va_fiche.cle
        tl_InfoGeneral[2] = NULL
        tl_InfoGeneral[3] = NULL
        tl_InfoGeneral[4] = DB_CTRL_GET_TITLE@(va_fenetre, "LI_intitulé_fmc")           /* intitule FMC */
        tl_InfoGeneral[5] = NULL

	tl_InfoGeneral[7] = va_tampon[0]

        IF va_fiche.numero_cause <> NULL
                tl_InfoGeneral[8] = DB_CTRL_GET_TITLE@(va_fenetre, "LI_fmc_cause")      /* intitule FMC cause */
        ELSE    tl_InfoGeneral[8] = NULL
        tl_InfoGeneral[9] = DB_EDITBOX_GET_DATA@(va_fenetre,"BE_localisation")          /* intitule localisation */
        IF va_fiche.type = XZAEC_FMC_QueueBouchon
                tl_InfoGeneral[10] = DB_EDITBOX_GET_DATA@(va_fenetre,"BE_local_tetebou")/* intitule localisation tete */
        ELSE    tl_InfoGeneral[10] = NULL
        IF va_fiche.numero_alerte <> NULL
                tl_InfoGeneral[11] = DB_CTRL_GET_TITLE@(va_fenetre,"LIB_alerte")        /* intitule alerte */
        ELSE    tl_InfoGeneral[11] = NULL

        /* Appel de la fenetre d'envoi fax */
        PEND_FOR_NEW_TASK@( "ITMA_TFX_Envoi_Fax", "ITMA_TMC_Fiche_Main_courante", tl_InfoGeneral, va_fiche)

ENDMACRO






/* -----------------------------------------------------------------------
* SERVICE RENDU :
*
*  Creation automatique d'une fmc basculement consequence des travaux
*
-----------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

/******************************************************************************
 ******************************************************************************
 ******* Fonctionnalite remplacee par la fmc Basculement pour Travaux  ********
 ******************************************************************************
 *****************************************************************************/
MACRO  TMC_Genere_Bascul(va_fenetre)

/*
* ARGUMENTS EN ENTREE :
* va_fenetre :  ID de la fenetre
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : Indefini
*
* CONDITION D'UTILISATION
*   MTMC
*
* FONCTION
--------------------------------------------------------------------- */
VAR tl_retour
VAR vl_horodate
VAR vl_val,vl_deb
var FORMAT TMC_fmc vl_fiche_consequence

	/*recherche si on a deja une fmc bascul consequence*/
	tl_retour=PEND_FOR_NEW_TASK@("ITMA_TMC_cree_bascul_from_travaux",
					vm_fiche.numero,
					vm_fiche.cle)

	if (tl_retour=COM_OK) {
	  /*creation fmc basculement consequence*/
	  vl_horodate=COM09_Date_Courante(TRUE)
       vl_deb=vl_horodate
	  if vm_fiche.debut<>null and vm_fiche.debut_prevu<>null
	    vl_val=null
	  else
	    vl_val=vm_fiche.debut_prevu
	  tl_retour=PEND_FOR_NEW_TASK@("ITMA_TMC_creer_fiche",
						XZAEC_FMC_Basculement,
						vm_etat_fmc,
						vl_deb,
						vl_val,	
						SYSTEM_VAR@(vg_site),
						vm_fiche.degrade)

	  vl_val=DB_CTRL_GET_VALUE@(vm_fenetre,"BS_prtetetrv")
	  if (vl_val++""=NULL)
	    vl_val=vm_fiche.pr / 1000
	  vm_tampon_bascul.pr = vl_val * 1000
	  DB_CTRL_VALUE@(vm_fenetre,"BS_pr_bascul",vl_val)

	  vm_tampon_bascul.bau_i = vm_tampon_trv.bau_i
	  vm_tampon_bascul.vl_i = vm_tampon_trv.vl_i
	  vm_tampon_bascul.vm1_i = vm_tampon_trv.vm1_i
	  vm_tampon_bascul.vm2_i = vm_tampon_trv.vm2_i
	  vm_tampon_bascul.vr_i = vm_tampon_trv.vr_i
	  vm_tampon_bascul.bau = vm_tampon_trv.bau
	  vm_tampon_bascul.vl = vm_tampon_trv.vl
	  vm_tampon_bascul.vm1 = vm_tampon_trv.vm1
	  vm_tampon_bascul.vm2 = vm_tampon_trv.vm2
	  vm_tampon_bascul.vr = vm_tampon_trv.vr

	  ITMA_TMC_bascul_sauve(
		tl_retour[1],
		vm_tampon_bascul,
		vm_etat_fmc,
		vl_horodate,
		vm_fenetre,
		vm_fiche.autoroute,
		vm_fiche.pr,
		vm_fiche.sens,
		null)

 vl_fiche_consequence=vm_fiche
  vl_fiche_consequence.num_fmc_init=null
  vl_fiche_consequence.cle_fmc_init=null
  vl_fiche_consequence.numero=tl_retour[1][0]
  vl_fiche_consequence.cle=tl_retour[1][1]
  vl_fiche_consequence.type=XZAEC_FMC_Basculement
 vl_fiche_consequence.numero_cause=vm_fiche.numero
  vl_fiche_consequence.cle_cause=vm_fiche.cle
  vl_fiche_consequence.type_cause=vm_type_fmc
  vl_fiche_consequence.debut=vl_deb

  PEND_FOR_NEW_TASK@("ITMA_TMC_valide",
		vl_horodate,
		vl_fiche_consequence,
		vm_etat_fmc,
		tm_config,
		null,
		null,
		XZAEC_FMC_Basculement)

  INFO_MESSAGE@("Création d'une FMC basculement conséquence des travaux")
  }

ENDMACRO
/******************************************************************************
 ******************************************************************************
 ******************************************************************************
 *****************************************************************************/






/* -----------------------------------------------------------------------
* SERVICE RENDU :
*  Appel de la fenetre de selection de fmc initiale
*
-----------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO  TMC_Lier_FMC_Initiale()

/*
* ARGUMENTS EN ENTREE :
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : Indefini
*
* CONDITION D'UTILISATION
*   MTMC
*
* FONCTION
--------------------------------------------------------------------- */
VAR FORMAT COM_Intitule_FMC vl_fmc_initiale
VAR tl_retour

	IF vm_fiche.degrade = XDC_OUI and vm_site = XDC_CI
	{
		tl_retour = PEND_FOR_NEW_TASK@("ITMA_TMC_Lien_Fiche_Initiale", vm_fiche)
		IF tl_retour[0] <> COM_OK
			RETURN (tl_retour[0])

		/* mettre a jour FMC initiale */
		vl_fmc_initiale = tl_retour[1]
		IF NOT IS_NULL@(vl_fmc_initiale)
		{
			vm_fiche.num_fmc_init = 	vl_fmc_initiale.IdFMC.numero
			vm_fiche.cle_fmc_init = 	vl_fmc_initiale.IdFMC.cle
			vm_fiche.autoroute_fmc_init = vl_fmc_initiale.localisation.NumAuto
			vm_fiche.PR_fmc_init = vl_fmc_initiale.localisation.PR
			vm_fiche.sens_fmc_init =         
						vl_fmc_initiale.localisation.sens_circulation
			vm_fiche.debut_fmc_init = vl_fmc_initiale.date
			vm_fiche.type_fmc_init = vl_fmc_initiale.NumType
			DB_CTRL_TITLE@(vm_fenetre,"LI_FMC_Initiale",
			COM11_Libelle_FMC(	vl_fmc_initiale))
		}
		ELSE	
		{
			vm_fiche.num_fmc_init = 	NULL
			vm_fiche.cle_fmc_init = 	NULL
			vm_fiche.type_fmc_init = NULL
			vm_fiche.autoroute_fmc_init = NULL
			vm_fiche.PR_fmc_init = NULL
			vm_fiche.sens_fmc_init = NULL
			vm_fiche.debut_fmc_init = NULL
			DB_CTRL_TITLE@(vm_fenetre,"LI_FMC_Initiale","-")
		}
	}

	RETURN (COM_OK)

ENDMACRO






/* -----------------------------------------------------------------------
* SERVICE RENDU :
*  Gère l'affichage d'une FMC DATEX
*
-----------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO  TMC_DATEX()

/*
* ARGUMENTS EN ENTREE :
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : Indefini
*
* CONDITION D'UTILISATION
*   MTMC
*
* FONCTION
--------------------------------------------------------------------- */
VAR tl_retour
VAR vl_msg
VAR FORMAT sql_procedure_params@ param_in,vl_parametres
var 	i, vl_index
var FORMAT sql_procedure_result@ vl_resultats

	if (vm_fiche_queue.datex= XDC_VRAI)
	{
	/* Lecture du complement datex */
	vm_liste_niveaux =  SYSTEM_VAR@ ( vg_niv_diff )

	i=0
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].data=vm_fiche.numero
	vl_parametres[i].output = FALSE
	i=i+1

	vl_parametres[i].data=null 	'gravite
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	vl_parametres[i].data=null 	'trafic
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1

	vl_parametres[i].data=null 	'bloquant
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].output = TRUE
	i=i+1


	IF (COM05_SQL_Procedure (XZAE154_Lire_FMCDATEX,
				  vl_parametres, vl_resultats, C_MODULE) <> COM_OK)
	{
		vl_msg="Erreur dans la vérification de la configuration des voies"

		CASE OF vl_resultats.status
			CASE XDC_NOK
				vl_msg="Erreur dans la lecture de la gravite"

		ENDCASE
		INFO_MESSAGE@(vl_msg)
		RETURN (COM_NOK)
	}
if ( ( vl_resultats.return_parameters[0] = XDC_SANS_NTFMAX ) OR IS_NULL@ (vl_resultats.return_parameters[0]) )
	{
	DB_CTRL_TITLE@ (vm_fenetre, "LI_datex", "Gravite Datex : ")
	}
ELSE
	{
	vl_index=ARRAY_INDEX@( ARRAY_COLUMN@ ( vm_liste_niveaux,TDO_NIVEAU_TFM ), vl_resultats.return_parameters[0] )
	if ( vl_index <> -1 )
		DB_CTRL_TITLE@ (vm_fenetre, "LI_datex", "Gravite Datex : " ++ vm_liste_niveaux[vl_index].libelle)
	else
		DB_CTRL_TITLE@ (vm_fenetre, "LI_datex", "Gravite Datex : " ++"?")
	
	}
/*	DB_CTRL_TITLE@( vm_fenetre,"LI_datex","Gravite Datex : " ++ vl_resultats.return_parameters[0])*/

	DB_CTRL_DISPLAY@( vm_fenetre,"LI_datex",TRUE)
	}

	/* Ajout SAGA : Prise en compte du droit de propriete ESCOTA/DDE83 */
	i=0
	vl_parametres[i].type = SYB#INT4_
	vl_parametres[i].data=vm_fiche.numero 'va_evenement_in
	vl_parametres[i].output = FALSE
	i=i+1

	vl_parametres[i].type = SYB#INT1_
	vl_parametres[i].data=vm_fiche.cle      'va_cle_in
	vl_parametres[i].output = FALSE
	i=i+1

	vl_parametres[i].type = SYB#BIT_
	vl_parametres[i].data=null      'va_propriete_fmc_out
	vl_parametres[i].output = TRUE
	i=i+1

	vl_parametres[i].type = SYB#BIT_
	vl_parametres[i].data=null      'va_propriete_queue_out
	vl_parametres[i].output = TRUE
	i=i+1

	IF (COM05_SQL_Procedure (XZAE551_Droit_Propriete,
				  vl_parametres, vl_resultats, C_MODULE) <> COM_OK)
        {
		INFO_MESSAGE@("Erreur dans la lecture du droit de propriete")
		RETURN (COM_NOK)
	}

	/* On memorise le droit de propriete */
	SET_SYSTEM_VAR@ (vg_datex_propriete,vl_resultats.return_parameters[0])
	SET_SYSTEM_VAR@ (vg_datex_propriete_queue,vl_resultats.return_parameters[1])

	/* Masquage des parties non modifiable */
	/* Pas de propriete sur la FMC          */
	if (vl_resultats.return_parameters[0] = 0)
	{
		/* On n'a pas la propriete sur la FMC */
		/* Suppression des droits de modification */
		DB_CTRL_GRAYED@(vm_fenetre,"BO_veracite",TRUE)
		DB_CTRL_GRAYED@(vm_fenetre,"BA_FausseAlerte",TRUE)
		DB_CTRL_GRAYED@(vm_fenetre,"BO_TypeFMC",TRUE)

/*		DB_CTRL_DISPLAY@( vm_fenetre,"BP_transmettre",FALSE);*/
		DB_CTRL_DISPLAY@( vm_fenetre,"BP_Recup_Droits",FALSE);
		DB_CTRL_DISPLAY@( vm_fenetre,"BP_changer_poste",FALSE);
		DB_CTRL_DISPLAY@( vm_fenetre,"BP_config_terrain",FALSE);
		DB_CTRL_DISPLAY@( vm_fenetre,"BP_effacer_cause",FALSE);
		DB_CTRL_DISPLAY@( vm_fenetre,"BP_autres_causes",FALSE);
		DB_CTRL_DISPLAY@( vm_fenetre,"BP_cause",FALSE);
		DB_CTRL_DISPLAY@( vm_fenetre,"LI_fmc_cause",FALSE);

		ITMA_TMC_visible("Date debut prevue", FALSE)

		DB_CTRL_DISPLAY@(vm_fenetre,"BP_libenrichir",FALSE)

		if (vl_resultats.return_parameters[1] = 1)
		{
			DB_CTRL_TITLE@(vm_fenetre,"BP_valider","Valider queue")
                }
		else
		{
		   	DB_CTRL_GRAYED@(vm_fenetre,"BP_valider",TRUE)
	      		DB_CTRL_DISPLAY@( vm_fenetre,"BP_valider",FALSE);
			DB_CTRL_DISPLAY@( vm_fenetre,"BP_Annuler_FMC",FALSE);
		}
	}
	if (vl_resultats.return_parameters[1] = 0)
	{
		DB_CTRL_DISPLAY@( vm_fenetre,"BP_localisation",FALSE);
   	}

	RETURN (COM_OK)

ENDMACRO






/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Determine si une FMC d'identifiant donné est conséquence d'une autre.
*
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION  ITMA_TMC_Est_Consequence (va_numero,va_cle,va_numero_conseq,va_cle_conseq)

/*
* ARGUMENTS EN ENTREE :
* numero d'evenement
* cle d'evenement
* numero d'evenement conseq?
* cle d'evenement conseq?
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : Indefini
*
* CONDITION D'UTILISATION
*   MTMC
*
* FONCTION
--------------------------------------------------------------------- */
VAR FORMAT SQL_Procedure_Params@ vl_parametres
VAR FORMAT SQL_Procedure_Result@ vl_resultats
VAR vl_taille, i, vl_indice, vl_data
VAR vl_args, vl_DateCourante

	vl_DateCourante = COM09_Date_Courante(FALSE)

	/* preparation de la requete*/
	vl_indice=0
	vl_parametres[vl_indice].type = SYB#INT4_
	vl_parametres[vl_indice].data = va_numero
	vl_parametres[vl_indice].output = FALSE
	vl_indice=vl_indice+1

	vl_parametres[vl_indice].type = SYB#INT4_
	vl_parametres[vl_indice].data = va_cle
	vl_parametres[vl_indice].output = FALSE
	vl_indice=vl_indice+1

	vl_parametres[vl_indice].type = SYB#DATETIME_
	vl_parametres[vl_indice].data = vl_DateCourante
	vl_parametres[vl_indice].output = FALSE
	vl_indice=vl_indice+1

	vl_parametres[vl_indice].type = SYB#INT1_
	vl_parametres[vl_indice].data = 1
	vl_parametres[vl_indice].output = FALSE
	vl_indice=vl_indice+1

        /* requete SYBASE*/
        IF (COM05_SQL_Procedure (XZAE68_ListeConsequences,
                           vl_parametres, vl_resultats, C_MODULE) <> COM_OK)
        {
                RETURN (COM_NOK)
        }

	vl_taille=ARRAY_SIZE@(vl_resultats.select_results[0])
	vl_data = vl_resultats.select_results[0]

	i=0
	WHILE ( i<vl_taille ) and ((vl_data[i][0]<>va_numero_conseq) or (vl_data[i][1]<>va_cle_conseq))
		i=i+1
	WEND

	if (vl_data[i][0]=va_numero_conseq) and (vl_data[i][1]=va_cle_conseq) {
		RETURN (XDC_VRAI)
	} else {
		RETURN (XDC_FAUX)
	}

ENDMACRO






/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Construit le libellé de la FMC en fonction de ses informations.
*
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION TMC_libelle_fiche (FORMAT TMC_fmc va_fiche)

/*
* ARGUMENTS EN ENTREE :
*   va_fiche  : les informations actuellement saises de la fiche MC.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : Indefini
*
* CONDITION D'UTILISATION
*   MTMC
*
* FONCTION
-----------------------------------------------------------------------------*/

VAR	FORMAT COM_Intitule_FMC  info_fmc

info_fmc.idfmc.numero = va_fiche.numero
info_fmc.idfmc.cle = va_fiche.cle
info_fmc.numtype = va_fiche.type
info_fmc.localisation.numauto = va_fiche.autoroute
info_fmc.localisation.pr = va_fiche.pr
info_fmc.localisation.sens_circulation = va_fiche.sens

IF NOT IS_NULL@ (va_fiche.debut)
	info_fmc.date = COM18_Date_SGBD_Formatee (va_fiche.debut)
ELSE
	info_fmc.date = COM18_Date_SGBD_Formatee (va_fiche.debut_prevu)

RETURN (COM11_Libelle_FMC (info_fmc))

ENDFUNCTION






/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Affiche les schemas d'ecoulement a une position donnee du reseau.
*
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TMC_ecoulement (va_autoroute, va_pr, va_sens, va_pt_car)

/*
* ARGUMENTS EN ENTREE :
*   va_autoroute      : numero d'autoroute ;
*   va_pr             : PR en metres ;
*   va_sens           : sens de circulation.
*	va_pt_car		  : point caractéristique (aire, échangeur...)
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : COM_OK
*
* CONDITION D'UTILISATION
*   MTMC
*
* FONCTION
*
-----------------------------------------------------------------------------*/

  VAR vl_nom_auto
  VAR vl_pr1,vl_pr2
  VAR vl_prefix, vl_visu
	
  VAR tl_fichiers, tl_champs_loc, tl_champs_pr
  VAR vl_debut, vl_fin
  VAR vl_repertoire, vl_num_ecran
  VAR vl_cr
  VAR i, vl_indice

  VAR vl_fichier_tops
  VAR vl_lignes
  VAR vl_array
  VAR vl_display_IPaddress
  VAR vl_display_number
  VAR vl_display_cmd
  VAR vl_screen_number
  VAR vl_taille
  
  /* Recherche du fichier TOPS pour recuperer l'adresse de laffichage distant */

  vl_display_IPaddress="xxx"
  vl_fichier_tops = SYSTEM_VAR@ (vg_repertoire_migrazur) ++ COM_SOUS_REP_ADM ++ "TOPS_" ++ SYSTEM_VAR@(vg_poste) ++ ".txt"

if FILE_EXISTS@(vl_fichier_tops)
  {
		OPEN_ASCII_FILE@ (vl_fichier_tops,"r")
		vl_lignes = READ_ASCII_FILE@(vl_fichier_tops)
		vl_taille = ARRAY_SIZE@(vl_lignes) -1
		for i = 0 to vl_taille
			if (SUBSTRING@(vl_lignes[i],1,1) <> "#" )
			{
				if (SUBSTRING@(vl_lignes[i],1,8) = "display1")
				{
					vl_array = ARRAY_FROM_STRING@(vl_lignes[i],"\t")
					vl_display_IPaddress= vl_array[1]
					vl_display_number = vl_array[2]
					vl_screen_number = vl_array[3]
				}
			}
		next i
		CLOSE_FILE@(vl_fichier_tops)
  }
  
  /* Si l'evenement est sur bretelle echangeur, considerer le meme PR en section courante */
  /*IF (va_sens = XDC_SENS_ENTREE_NORD) OR (va_sens = XDC_SENS_SORTIE_NORD)
  {
    va_sens = XDC_SENS_NORD
  }
  ELSE IF (va_sens = XDC_SENS_ENTREE_SUD) OR (va_sens = XDC_SENS_SORTIE_SUD)
  {
    va_sens = XDC_SENS_SUD
  }*/

  /* determiner l'ecran ou afficher les schemas d'ecoulement */
  vl_num_ecran = 1
  IF (SYSTEM_VAR@ (vg_numero_display) = XDC_ECRAN_UNIQUE)
  {
    vl_num_ecran = 0
  }

  vl_indice = COM45_IndexEnColonne (tm_autoroutes, TDO_NUMERO_AUTOROUTE, va_autoroute)
  IF vl_indice >= 0
    vl_nom_auto = tm_autoroutes[vl_indice].nom
  ELSE
    vl_nom_auto = "???"

   
  vl_prefix=".pdf"
  vl_visu="DISPLAY=:0.%s ; evince -w %s/%s%s "
  
						 
  /*recherche les fichiers dans le bon repertoire */
  vl_cr = XDC_NOK
  vl_repertoire = SYSTEM_VAR@ (vg_repertoire_migrazur) ++ COM_SOUS_REP_SCH_ECOULT

  if (va_pt_car = XDC_POINT_CARACT_AIRE)
  {
    tl_fichiers = FILE_SYSTEM_FILES@ (vl_repertoire, FORMAT@ ("AIRE_%s_%s*%s", vl_nom_auto, va_sens, vl_prefix))
  }
  else
  {
    tl_fichiers = FILE_SYSTEM_FILES@ (vl_repertoire, FORMAT@ ("%s_%s*%s", vl_nom_auto, va_sens, vl_prefix))
  } 
  
  FOR i = 0 TO ARRAY_SIZE@(tl_fichiers) -1
    /* on extrait les champs des noms de la forme nomAutoroute_NumeroSens_PRdebut-PRfin[-index].pdf */
    /* ou AIRE_nomAutoroute_NumeroSens_PRdebut-PRfin[-index].pdf si point caractéristique aire      */
    tl_fichiers[i]=SUBSTRING@(tl_fichiers[i],1, LEN@(tl_fichiers[i])-4)	' enlever l extension
    
    if (va_pt_car = XDC_POINT_CARACT_AIRE)
    {
      tl_fichiers[i]=SUBSTRING@(tl_fichiers[i],6, LEN@(tl_fichiers[i]))	' enlever le prefixe AIRE_
    }
    
    tl_champs_loc = ARRAY_FROM_STRING@ (tl_fichiers[i], "_")
    tl_champs_pr = ARRAY_FROM_STRING@ (tl_champs_loc[2], "-")
    vl_debut = REPLACE_SUBSTR@ (tl_champs_pr[0], ".", ",")
    vl_fin = REPLACE_SUBSTR@ (tl_champs_pr[1], ".", ",")

    IF ( (tl_champs_loc[0] = vl_nom_auto)  AND
       ( IS_NUMERIC_STRING@ (tl_champs_loc[1]) AND (tl_champs_loc[1] +0 = va_sens +0) )  AND
         IS_NUMERIC_STRING@ (vl_debut) AND IS_NUMERIC_STRING@ (vl_fin) )
    {
      vl_pr1 = MIN@ (vl_debut, vl_fin)
      vl_pr2 = MAX@ (vl_debut, vl_fin)
      /*intersection avec l evt*/
      IF (vl_pr1*1000 <= va_pr) AND (vl_pr2*1000 >= va_pr)
      {
        vl_cr = XDC_OK
	
	/* On construit le display avec le display TOPS si il existe */
	if (vl_display_IPaddress <> "xxx")
	{
		vl_display_cmd = "DISPLAY=" ++ vl_display_IPaddress ++ ":" ++ vl_display_number ++ "." ++ vl_screen_number
	}
	else
	{
		vl_display_cmd = "DISPLAY=:" ++ "0." ++ vl_num_ecran
	}

        /*on affiche le fichier : si sur une aire, on ajoute AIRE_ dans le nom de fichier */
        if (va_pt_car = XDC_POINT_CARACT_AIRE)
        {
          SHELL_COMMAND@ (FORMAT@ ("rm -rf /produits/migrazur/appliSD/.gnome2/accels/evince /produits/migrazur/appliSD/.gnome2/evince; %s ; evince  %s/%s%s%s &",
                                   vl_display_cmd, vl_repertoire, "AIRE_", tl_fichiers[i], vl_prefix))
        }
        else
        {
	  SHELL_COMMAND@ (FORMAT@ ("rm -rf /produits/migrazur/appliSD/.gnome2/accels/evince /produits/migrazur/appliSD/.gnome2/evince; %s ; evince  %s/%s%s &",
                                   vl_display_cmd, vl_repertoire, tl_fichiers[i], vl_prefix))          
        }  	
      }
    }
  NEXT i

  IF (vl_cr <> XDC_OK)
    INFO_MESSAGE@("Pas de fichier d'ecoulement a cette localisation")

  RETURN (COM_OK)
        
ENDMACRO


MACRO  TMC_charge_multi()
  VAR vl_indice
  VAR tl_ligne
  VAR FORMAT TMC_multi_auto vl_multi
  VAR vl_index,vl_indice2

    tm_multi=NULL
    vl_index=0
    IF (FILE_EXISTS@("/produits/migrazur/appliSD/fichiers/dra/"++XDF_CONF_FMC_MULTI_AUTO)) {
      tl_ligne=READ_ASCII_FILE@("/produits/migrazur/appliSD/fichiers/dra/"++XDF_CONF_FMC_MULTI_AUTO)

		for vl_indice = 0 TO ARRAY_SIZE@(tl_ligne)-1
			if (SUBSTRING@(tl_ligne[vl_indice],1,1)<>"#") {
				vl_multi=ARRAY_FROM_STRING@(tl_ligne[vl_indice],"	")
				vl_indice2 = ARRAY_INDEX@(ARRAY_COLUMN@(tm_autoroutes,TDO_NOM_AUTOROUTE),
						vl_multi.autoroute_queue)
				vl_multi.autoroute_queue=tm_autoroutes[vl_indice2].numero
				vl_indice2 = ARRAY_INDEX@(ARRAY_COLUMN@(tm_autoroutes,TDO_NOM_AUTOROUTE),
						vl_multi.autoroute_tete)
				vl_multi.autoroute_tete=tm_autoroutes[vl_indice2].numero
				vl_indice2 = ARRAY_INDEX@(ARRAY_COLUMN@(tm_autoroutes,TDO_NOM_AUTOROUTE),
						vl_multi.autoroute_tete_inter)
				vl_multi.autoroute_tete_inter=tm_autoroutes[vl_indice2].numero
				vl_indice2 = ARRAY_INDEX@(ARRAY_COLUMN@(tm_autoroutes,TDO_NOM_AUTOROUTE),
						vl_multi.autoroute_queue_inter)
				vl_multi.autoroute_queue_inter=tm_autoroutes[vl_indice2].numero
				tm_multi[vl_index]=vl_multi
				vl_index= vl_index+1
			}
		next vl_indice
	}

	RETURN (COM_OK)
ENDMACRO

FUNCTION TMC_check_PR_multi()
VAR vl_multi_ok

			vl_multi_ok=0
			if (vm_fiche.sens MOD 2 = 0 ) {
				if ( 
					( (vm_fiche.autoroute = 8) AND (vm_fiche.PR <= vm_multi.pr_tete_inter)) 
					OR
					( (vm_fiche.autoroute <> 8) AND (vm_fiche.PR >= vm_multi.pr_tete_inter))
				   )	
				  AND
				  (
					((vm_fiche_tete.autoroute <> 8) AND (vm_fiche_tete.sens MOD 2 = XDC_SENS_SUD) AND (vm_fiche_tete.PR >= vm_multi.pr_queue_inter))
					OR
					((vm_fiche_tete.autoroute <> 8) AND (vm_fiche_tete.sens MOD 2 = 0) AND (vm_fiche_tete.PR <= vm_multi.pr_queue_inter))
				  	OR 
					((vm_fiche_tete.autoroute = 8) AND (vm_fiche_tete.sens MOD 2 = XDC_SENS_SUD) AND (vm_fiche_tete.PR <= vm_multi.pr_queue_inter))
					OR
					((vm_fiche_tete.autoroute = 8) AND (vm_fiche_tete.sens MOD 2 = 0) AND (vm_fiche_tete.PR >= vm_multi.pr_queue_inter))
				  )
					vl_multi_ok=1
			}
			else {
				if ( 
					( (vm_fiche.autoroute = 8) AND (vm_fiche.PR >= vm_multi.pr_tete_inter)) 
					OR
					( (vm_fiche.autoroute <> 8) AND (vm_fiche.PR <= vm_multi.pr_tete_inter))
				   )	
				  AND
				  (
					((vm_fiche_tete.autoroute <> 8) AND (vm_fiche_tete.sens MOD 2 = XDC_SENS_SUD) AND (vm_fiche_tete.PR >= vm_multi.pr_queue_inter))
					OR
					((vm_fiche_tete.autoroute <> 8) AND (vm_fiche_tete.sens MOD 2 = 0) AND (vm_fiche_tete.PR <= vm_multi.pr_queue_inter))
				  	OR
					((vm_fiche_tete.autoroute = 8) AND (vm_fiche_tete.sens MOD 2 = XDC_SENS_SUD) AND (vm_fiche_tete.PR <= vm_multi.pr_queue_inter))
				  	OR
					 ((vm_fiche_tete.autoroute = 8) AND (vm_fiche_tete.sens MOD 2 = 0) AND (vm_fiche_tete.PR >= vm_multi.pr_queue_inter))
				  )
					vl_multi_ok=1
			}
return (vl_multi_ok)
ENDFUNCTION






/*-----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Ecrit en base les horodates de début et fin de consultation de la FMC
*   ainsi que le poste où elle est consultée.
*
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TMC_Tracer_Consultation (va_numero, va_cle)

/*
* ARGUMENTS EN ENTREE :
*  va_numero          : numero de l'evenement
*  va_cle             : cle de l'evenement
*
* ARGUMENTS EN SORTIE :
* aucun
*
* CODE RETOUR :
* COM_OK si la trace est écrite en base de données, COM_NOK sinon.
*
-----------------------------------------------------------------------------*/

VAR	FORMAT SQL_Procedure_Params@	tl_parametres
VAR	FORMAT SQL_Procedure_Result@	vl_resultats
VAR	vl_heure_fermeture_fiche
VAR	vl_cr

	vl_cr = COM_OK

	IF (COM04_Operateur_A_Le_Droit_De (XDC_FAM_EXPLOITATION_DISTRICT)  OR
	    COM04_Operateur_A_Le_Droit_De (XDC_FAM_EXPLOITATION_PC2)  OR
	    COM04_Operateur_A_Le_Droit_De (XDC_FAM_EXPLOITATION_CI))
	{
		IF (IS_NULL@ (va_numero)  OR  IS_NULL@ (va_cle)  OR  IS_NULL@ (vm_heure_ouverture_fiche))
		{
			vl_cr = COM_NOK
		}
		ELSE
		{
			vl_heure_fermeture_fiche = COM09_Date_Courante (TRUE)

			tl_parametres = COM15_Parametres_Requete ( {
				{ FALSE,	SYB#INT4_,	va_numero },
				{ FALSE,	SYB#INT1_,	va_cle },
				{ FALSE,	SYB#DATETIME_,	vm_heure_ouverture_fiche },
				{ FALSE,	SYB#DATETIME_,	vl_heure_fermeture_fiche },
				{ FALSE,	SYB#INT2_,	SYSTEM_VAR@ (vg_numero_poste) }
			} )
			vl_cr = COM05_SQL_Procedure (XZAI601_Tracer_Ouverture_FMC, tl_parametres, vl_resultats, C_MODULE)
		}
	}

	/* Réinitialiser l'horodate de début de consultation, en cas de continuation de saisie d'une autre fiche */
	vm_heure_ouverture_fiche = vl_heure_fermeture_fiche

	RETURN (vl_cr)
ENDMACRO
