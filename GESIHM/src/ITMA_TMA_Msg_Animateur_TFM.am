/*E*/
/*  Fichier : $Id: ITMA_TMA_Msg_Animateur_TFM.am,v 1.75 2021/06/07 13:57:47 gesconf Exp $        Release : $Revision: 1.75 $        Date : $Date: 2021/06/07 13:57:47 $
-------------------------------------------------------------------------------
* STERIA *  PROJET MIGRAZUR
-------------------------------------------------------------------------------
* SOUS-SYSTEME  GESIHM
-------------------------------------------------------------------------------
* MODULE ITMA_TMA * FICHIER ITMA_TMA_Msg_Animateur_TFM.am
-------------------------------------------------------------------------------
* DESCRIPTION DU MODULE :
*
* Liste des messages a l'animateur Trafic FM.
*
*   Cf. DCG 2.4.51
*
-------------------------------------------------------------------------------
* HISTORIQUE :
*
* Lecrivain 08 Sep 1994 : Creation
* Lecrivain 17 Oct 1994 : Decomposition horodate par fonction             V1.8
* Lecrivain ?? Nov 1994 : Constantes de types en entree de Sybase         V1.9
* Lecrivain 15 Dec 1994 : Formatage de la date lue en base de donnees     V1.10
* Guilhou   23 dec 1994 : aide composition de l'heure                     V1.11
* Lecrivain 23 Dec 1994 : Changt. localisation des fichiers pictogrammes  V1.12
* Noel	  28 Dec 1994 : Changt. de l'interface TMA_Acquitter_Diffusion	V1.13
* Lecrivain 20 Fev 1995 : Ajout de l'impression d'un message              V1.14
* Lecrivain 20 Fev 1995 : Mise a jour du format d'impression              V1.15
* Noel	    21 Sep 1995 : Introduction de la procedure commune
*				d'impression				  V1.18
* Torregrossa	10 Nov 1995 : Remplacer code du site par le numero du site V1.19
* Torregrossa	02 Fev 1996 : Modifier la police de caractere du message  V1.20
* Torregrossa	18 Mar 1996 : Grisage du bouton diffuser sur selection de message
*                            a supprimer, reinitialisation de la selection du
*                            message apres diffusion  (1073)V1.21
* Niepceron	04 Nov 1996 : Ajout de la qualification des msg TFM (dem/1248) v1.22
* Guilhou	12 nov 1996 : amelioration de la presentation (DEM/1276) 1.23
* Niepceron	12 Nov 1996 : Ajout de la qualification des msg TFM suite (dem/1248) v1.24
* Niepceron     10 Mar 1997 : Modification de l'interface de avec XZAE111 dem/tdp v1.26
* Cluchague     20 Aout 2001: Diffusion implicite lors de la lecture d'un message  1.27
* Cluchague     07 Juin 2002: garder le focus sur l'evenement pointe, meme apres rafraichissement
			      REPERE1 1.28
* Hilmarcher    02 juin 2003: Prise en compte des secondes lors des heure_succes et heure_fin pour affichage
*                             synthese (DEM 250 V1.29)
* Hilmarcher    15 oct  2003: probleme coherence versions sccs V1.31 1.32
* Cluchague     23 sep  2004: renomage colonnes 1.33
* Hilmarcher	19 avr  2005: gestion des zones de decrochage TFM par sens DEM457 v1.34
* Hilmarcher    02 mai  2005: gestion des messages a diffuser au niveau de TFM DEM459 v1.35
* F. Lizot      05 mars 2004: ajout des messages de TFM_DTX (SAGA) V1.36
* F.Lizot	27 juin 2005: Modif pour SAGA 1.36 DEM473
* Hilmarcher    22 juin 2005: Modif: les msgs TFM de niveau > 1 doivent etre Z1 et Z2 DEM478 v1.37
* Hilmarcher    4 juill 2005: Creation de messages TDP en debut de liste DEM481 v1.38
* Hilmarcher    18 aout 2005: Maj versions apres disfonctionnement v1.40
* Hilmarcher    18 aout 2005: Modif: les msgs TFM de niveau > 1 doivent etre Z1 et Z2 DEM478 v1.41
* Hilmarcher    06 sept 2005: Modif numero/cle msg tdp pour ne pas gener message datex v1.42
* Niepceron	14 nov 2005:  correction de la memorisation de la ligne selctionnée lors du raf DEM536 1.44
* Niepceron	12 dec 2005:  Recalcul du msg TDP uniquement sur timer DEM481 1.45
* JPL		08 nov 2007 : Restructuration ; identique a la version precedente (prealable DEM 727) 1.46
* JPL		20 nov 2007 : Restauration ACTION selectionnee; Plus d'acquittement du message TdP;
*		               Tests aucune selection; De-selection des boutons (DEM 727) 1.47
* JPL		26 nov 2007 : Correction bugs: lire le choix de la zone; test zone 2 (DEM 731) 1.48
* JPL		27 nov 2007 : Le message TdP reste selectionne sur reinit de la liste (DEM 731) 1.49
* JPL		07/04/09 : Simplifications ; identique a la version precedente 1.50
* JPL		08/04/09 : Affectation zone de diffusion pour toutes localisations (DEM 543) 1.51
* JPL		08/09/09 : Inhibition selection durant mise a jour liste messages a diffuser (DEM 907) 1.52
* JPL		22/10/09 : Version intermediaire, identique a la precedente 1.53
* JPL		02/11/09 : Sur selection d'un message, toujours indiquer les periodes de diffusion 1.54
* JPL		05/11/09 : Performances: memorisation donnees, filtrage zone ... (DEM 917) 1.55
* JPL		12/11/09 : Correction: conserver le texte de l'ACTION precedente et non l'evenement 1.56
* JPL		23/12/11 : Suppression lancement timer ITMA_TIME_TDP_RTFM, remplace par timer tstim.x (DEM 1007)  1.57
* LCL         26/01/12 : Ajout autoroute sur zones de TdP (DEM 1014)  1.58
* JPL		28/08/12 : Plus de calcul du message TdP sur top timer, mais sur selection operateur (DEM 1039)  1.59
* PNI		11/10/12 : Suppression de la Diffusion implicite lors de la lecture d'un message  1.60 DEM1054
* PNI		27/11/12 : Retour à la version 1.59  1.61
* PNI		27/11/12 : degriser Imprimer pour le msg TdP 1.62
* PNI         	09/10/14 : Suppression des réveils pour le msg TdP 1.63 DEM 1104
* PNI           09/10/14 : Filtre le reveil globale en tenant compte des message affiches par zone 1.64 DEM 1104
* JMG		06/10/14 : SAE Lot 20 1.65 DEM1098
* PNI           30/10/14 : Filtre le reveil globale en tenant compte des message affiches par zone 1.66 DEM 1104
* JMG		06/10/14 : SAE Lot 20 1.67 DEM1098
* PNI           3/11/14 : Correctif sur icone rouge pour accident et le selection conservée lors des rafraichissements 1.68 DEM1098
* PNI           26/11/14 : Degriser bouton supprimer pour les msg à supprimer 1.96
* NDE		17/07/15 : Ajout bloc pour Veh en BAU (DEM1140)
* PNI/RGR       20/03/19 : Ajout de trace pour monitorer l'acquitement
* PNI		27/05/2019 : IHM revue
* PNI           27/09/2019 : Correctif sur localisation DEM1357 1.73
* PNI		06/04/2021 : ajout de traces
---------------------------------------------------------------------------- */

INCLUDE "dbase_.am"

INCLUDE	"XDMICG/inc/xdc_ax.h"
INCLUDE	"XDMICG/inc/xzic_ax.h"
INCLUDE	"XDMICG/inc/xzaec_ax.h"


INCLUDE	"GESIHM/inc/ITMA_COM.h"
INCLUDE	"GESIHM/inc/ITMA_TDO.h"
INCLUDE	"GESIHM/inc/ITMA_TAR.h"

INCLUDE	"GESIHM/inc/xzai04sp.h"
INCLUDE	"GESIHM/inc/xzai05sp.h"
INCLUDE	"GESIHM/inc/xzai06sp.h"
INCLUDE	"GESIHM/inc/xzac44sp.h"
INCLUDE	"GESIHM/inc/xzae111sp.h"
INCLUDE "GESIHM/inc/xzai502sp.h"
INCLUDE "GESIHM/inc/xzao434sp.h"
INCLUDE "GESIHM/inc/xzao435sp.h"


DEFINE	C_MODULE	"MTMA"			' Nom du module



DEFINE	C_MODELE_MSG		"ITMA_TMA_Message_TFM"		' Modele d'impression
DEFINE	C_SOUS_REP_MODELES	COM_SOUS_REP_IHM		' Repertoire des modeles


DEFINE	TMA_MAX_PERIODE		3600


DEFINE	CM_CONSERVER_TDP		1			' Modes de reinitialisation
DEFINE	CM_REINIT_TDP			2


/*A
 * Noms des images digitalisees particularisant
 * un message diffuse, non diffuse et a supprimer
 * ----------------------------------------------
 */

DEFINE	CM_PICTO_DIFFUSE		NULL
DEFINE	CM_PICTO_NON_DIFFUSE		"pix_designer"
DEFINE	CM_PICTO_A_SUPPRIMER		"pix_croix"
DEFINE	CM_PICTO_EVIDENCE		"pix_reveil_rouge"

DEFINE C_TYPES {XZAEC_FMC_Accident,XZAEC_FMC_VehFeu,XZAEC_FMC_Contresens,XZAEC_FMC_VehArrete,XZAEC_FMC_VehPanne,XZAEC_FMC_PietonChaussee,XZAEC_FMC_AnimalErrant,XZAEC_FMC_Obstacle}


/*A
 * Description du format des donnees de configuration
 * --------------------------------------------------
 */

/*B Format de la table des zones de diffusion */
FORMAT	TMA_Zone_TFM
	nom,					' Nom de la zone de diffusion
	sens,					' Sens
	troncon1				' premier troncon
	'...					' troncons suivants ...


/*B Format de la table des troncons TFM */
FORMAT	TMA_Troncon_TFM
	nom,					' Nom du troncon
	autoroute,				' Nom autoroute
	pr_debut,				' PR debut de troncon
	pr_fin					' PR fin de troncon


/*B Format de la table des modes de diffusion */
DEFINE 	TMA_MOD_NIVEAU		0

FORMAT	TMA_Mode_TFM
	niveau,					' Valeur du niveau de diffusion
	nom_niveau,				' Nom du niveau
	couleur,				' Couleur associee
	mode1,					' Mode de diffusion 1
	mode2					' Mode de diffusion 2


/*B Format de la table des periodes de diffusion */
DEFINE	TMA_PER_TRC		0


/*B Format de la table des couleurs */
DEFINE	TMA_NOM_COUL	0		' nom de la couleur
DEFINE	TMA_VAL_COUL	1		' valeur de la couleur



/*A
 * Description du format des donnees affichees
 * -------------------------------------------
 */

FORMAT	TMA_Message_TFM
	numero,					' Numero message
	intitule,				' Intitule evenement (25 car)
	niveau,
	nb_diffusions,
	date	,				' Date 1ere diffusion (16 car)
	numero_type,
	deja_diffuse



/*A
 * Description du format des donnees internes
 * ------------------------------------------
 */

/* Dans le cas des messages DATEX : table TFM_DTX        */
/* tous les champs sont a 0 sauf :                       */
/* message qui contient le message a diffuser            */

DEFINE	TMA_INFO_ID	0

FORMAT	TMA_Info_Message_TFM
	FORMAT COM_Identifiant_FMC id_evt,	' Identifiant evenement
	type,					' Type evenement
	fin,					' Indicateur de fin de diffusion
	num_action,				' Numero d'action
	site,
	niveau,
	message,                                ' Message a diffuser        (ajout SAGA)
	code_partenaire,                        ' Code du partenaire DATEX  (ajout SAGA)
	reference_datex,                        ' Reference DATEX           (ajout SAGA)
	numero_type,
	texte,					' Le texte du message (une fois lu)
	type_archive				' XDC_TMA_BLOC_MSG = pas archive, XDC_TMA_BLOC_ENT = entete archive, XDC_TMA_BLOC_ARC = archive


/*A
 * Description du format des donnees lues en base
 * ----------------------------------------------
 */

FORMAT	TMA_Donnees_Message_TFM
	num_evt,				' Numero evenement
	cle_evt,				' Cle evenement
	type,					' Type evenement
	nb_diffusions,
	date,					' Date 1ere diffusion
	fin,					' Indicateur de fin de diffusion
	num_action,				' Numero d'action
	site,
	niveau,
	message1,                               ' Message a diffuser        (ajout SAGA)
	message2,                               ' Message a diffuser        (ajout SAGA)
	code_partenaire,                        ' Code du partenaire DATEX  (ajout SAGA)
	reference_datex  ,                       ' Reference DATEX           (ajout SAGA)
	numero_type,
	deja_diffuse,
	priorite_arc



/*A
 * Description du format des troncons orientes ou un evenement est situe
 * ---------------------------------------------------------------------
 */

FORMAT	TMA_Troncon_Oriente
	nom,					' Nom troncon
	sens					' Sens de l'evenement



/*A
 * Description du format des localisations lues en base
 * ----------------------------------------------------
 */

FORMAT	TMA_Localisations_FMC
	autoroute,				' Nom autoroute
	sens,
	pr_debut,
	pr_fin



VAR	FORMAT COM_Identifiant_FMC	CM_EVT_TDP		' Evenement particulier representant le message TDP
VAR	FORMAT COM_Identifiant_FMC	CM_EVT_DATEX		' Evenement particulier representant UN message DATEX


VAR	FORMAT TMA_Message_TFM		tm_messages		' Table des messages (filtres par zone affichee)
VAR	FORMAT TMA_Info_Message_TFM	tm_infos		' Table des infos internes (filtrees par zone)

VAR	tm_titres						' Titres colonnes de la table
VAR	tm_pictos						' Liste des pictogrammes associes

VAR	vm_contenu_message_tdp					' Texte du message Temps De Parcours
VAR	vm_nouveau_msg_tdp					' Indicateur d'arrivee d'un nouveau message TDP

VAR	vm_lib_niveau, vm_periodes				' Consignes du message selectionne

VAR	FORMAT TMA_Mode_TFM	tm_modes_TFM			' Configuration des modes de diffusion
VAR	FORMAT TMA_Troncon_TFM	tm_troncons_TFM			' Configuration des troncons TFM
VAR	FORMAT TMA_Zone_TFM	tm_zones_TFM			' Configuration des zones de diffusion
VAR	tm_periodes_diff, tm_periodes_diff_TA			' Configuration des periodes de diffusion

VAR	tm_numeros_districts

VAR	tm_couleurs
VAR     vm_reveil_a_afficher



/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Visualisation des messages a diffuser et du nombre de diffusions
*  precedentes.
*  Rafraichissement de la liste sur arrivee d'un signal de modification.
*  Enregistement (acquittement) des diffusions.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TMA_Msg_Animateur_TFM (va_appelant)

/*
* ARGUMENTS EN ENTREE :
*  va_appelant        : Nom de la macro Applix ayant invoque la presente.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : Indefini
*
* CONDITION D'UTILISATION
*   A l'initialisation du poste (si le profil le permet).
*
* FONCTION
*   Lit en base de donnees puis affiche la liste des messages TFM a diffuser.
*   Se met en attente d'un signal (message d'une autre tache) de changements
*   et sur occurrence du signal, reinitialise la liste des messages.
*   Sur selection d'un message par l'operateur, lit en base de donnees et
*   affiche le texte du message, et propose la date courante pour dater la
*   diffusion.
*   Sur acquittement, enregistre une diffusion avec la date eventuellement
*   modifiee par l'operateur et incremente le compteur de diffusions.
*
---------------------------------------------------------------------------- */

    VAR     vl_fenetre			' Nom de la fenetre du module
    VAR     vl_objet_selecte			' L'objet courant de la fenetre
    VAR     vl_les_messages_acceptes		' Pour reception de signaux
    VAR     vl_la_fenetre_est_active
    VAR     vl_installer_traitement_erreur

    VAR     tl_selection			' Selection(s) dans la table
    VAR	FORMAT TMA_Message_TFM vl_ligne		' Donnees de la ligne selectee
    VAR     vl_date                             ' Date sous forme de chaine
    VAR     vl_texte, vl_niveau			' Donnees d'un message RTFM

    VAR     tl_params				' Parametres d'un message Poke
    VAR     vl_commande, vl_action, vl_site	' Donnees d'un message Poke
    VAR     vl_cmd, tl_args
    VAR     vl_fichier
    VAR     vl_i
    VAR     vl_cr

/*A
 * Traitements en cas d'erreur durant l'initialisation :
 * informer l'operateur, tracer l'erreur et abandonner
 * -----------------------------------------------------
 */

'ON ERROR {
'	ERROR_BOX@
'	COM01_Trace (COM_WARNING, COM03_Message_Erreur (C_MODULE))
'	RETURN
'}


/*A
 * Charger la fenetre "Messages animateur TFM"
 * -------------------------------------------
 */


if (GET_ENV_VAR@("RTARCH")="hp700_hpux") or (STRING_INDEX@(SYSTEM_VAR@(vg_poste),"RVAV")>0) {
vl_fenetre = DB_LOAD@ ("ITMA_TMA_low")
DB_WINDOW_REMAIN@ (vl_fenetre, TRUE)
DB_XPOS@ (vl_fenetre, 0)
DB_YPOS@ (vl_fenetre, 93)
DB_WIDTH@ (vl_fenetre, 1264)
}
else
{
vl_fenetre = DB_LOAD@ ("ITMA_TMA")
DB_WINDOW_REMAIN@ (vl_fenetre, TRUE)
DB_XPOS@ (vl_fenetre, 0)
DB_YPOS@ (vl_fenetre, 93)
DB_WIDTH@ (vl_fenetre, 1680)
}

COM02_Attacher_Aide (vl_fenetre, "ITMA_TMA_Msg_Animateur_TFM")


/*A
 * Mettre en place la reception des messages
 * -----------------------------------------
 */

vl_les_messages_acceptes[0] = COM_CANAL_FIN
vl_les_messages_acceptes[1] = COM_CANAL_MTMA
vl_les_messages_acceptes[2] = COM_CANAL_MTDP_TIMER
DB_ACCEPT_POKES@ (vl_fenetre, vl_les_messages_acceptes)


/*A
 * Definir les caracteristiques (initiales) des objets graphiques
 * --------------------------------------------------------------
 */

DB_CTRL_DISPLAY@ (vl_fenetre, "ID_Liste_Modifiee", FALSE)
vm_reveil_a_afficher=XDC_FAUX

DB_CTRL_VALID_CHARS@ (vl_fenetre, "BS_Jour_Diffusion", COM_CHIFFRES)
DB_CTRL_VALID_CHARS@ (vl_fenetre, "BS_Mois_Diffusion", COM_CHIFFRES)
DB_CTRL_VALID_CHARS@ (vl_fenetre, "BS_Annee_Diffusion", COM_CHIFFRES)
DB_CTRL_VALID_CHARS@ (vl_fenetre, "BS_Heure_Diffusion", COM_CHIFFRES)
DB_CTRL_VALID_CHARS@ (vl_fenetre, "BS_Minute_Diffusion", COM_CHIFFRES)
DB_CTRL_VALID_CHARS@ (vl_fenetre, "BS_Seconde_Diffusion", COM_CHIFFRES)

DB_TABLE_SET_MARKER_WIDTH@ (vl_fenetre, "TA_Msg_Diffuser", 23)
DB_TABLE_ALLOW_COLUMN_RESIZING@ (vl_fenetre, "TA_Msg_Diffuser", FALSE)
DB_CTRL_HORIZ_SCROLL@ (vl_fenetre, "TA_Msg_Diffuser", FALSE)
DB_CTRL_RETURN_ON_CHANGE@ (vl_fenetre, "TA_Msg_Diffuser", TRUE)
DB_CTRL_RETURN_ON_CHANGE@ (vl_fenetre, "BO_zone", TRUE)

DB_CTRL_GRAYED@ (vl_fenetre, "BP_Imprimer", TRUE)
DB_CTRL_GRAYED@ (vl_fenetre, "BP_Supprimer", TRUE)
DB_CTRL_GRAYED@ (vl_fenetre, "BP_Acquitter", TRUE)

DB_CTRL_TITLE@ (vl_fenetre, "LI_Niveau","")

DB_CTRL_FONT@(vl_fenetre, "BE_Message", "-adobe-courier-bold-r-normal--24-240-75-75-m-150-iso8859-1")


/*A
 * Lire la configuration (consignes TFM)
 * -------------------------------------
 */

ITMA_TMA_Lire_Configuration_TFM ()


/*A
 * Initialiser la visualisation (liste des messages)
 * -------------------------------------------------
 */

IF TMA_Init_Visualisation (vl_fenetre) <> COM_OK
	RETURN (COM_NOK)
/*A
* Demarrer le timer de mise a jour du message de synthese des Temps de Parcours
* -----------------------------------------------------------------------------
*/
 
/* NEW_TASK@ ("ITMA_TIME_TDP_RTFM") */
tl_args = { XDC_VRAI }                      ' Pour activation du timer
ITMA_TIR_EXEC (MTAR_FCT_TIMER_TDP, 1, tl_args)


/*A
 * Traitements en cas d'erreur durant la visualisation :
 * informer l'operateur, tracer l'erreur et continuer
 * -----------------------------------------------------
 */

vl_installer_traitement_erreur = TRUE
WHILE vl_installer_traitement_erreur
	vl_installer_traitement_erreur = FALSE

	ON ERROR {
		ERROR_BOX@
		IF ERROR_NUMBER@() <> COM_ERR_DATE_INVAL
			COM01_Trace (COM_WARNING, COM03_Message_Erreur (C_MODULE))
		vl_installer_traitement_erreur = TRUE
	}
WEND


/*A
 * Visualiser la fenetre tant que la tache
 * n'est pas stoppee par le signal de fin
 * ---------------------------------------
 */

vl_la_fenetre_est_active = TRUE
WHILE vl_la_fenetre_est_active

    /* Afficher la fenetre en autorisant les actions operateur */
    DB_CTRL_PICKABLE@ (vl_fenetre, "TA_Msg_Diffuser", TRUE)

    DB_DISPLAY_ONLY@ (vl_fenetre, FALSE)
    DB_DISPLAY@ (vl_fenetre)
    DB_DISPLAY_ONLY@ (vl_fenetre, TRUE)

    vl_objet_selecte = DB_EXIT_CTRL@ (vl_fenetre)

    /*A
     * Apres toute action operateur, effacer le pictogramme de changement
     * ------------------------------------------------------------------
     */

    DB_CTRL_DISPLAY@ (vl_fenetre, "ID_Liste_Modifiee", FALSE)


    CASE OF vl_objet_selecte

    CASE "poke_"
	CASE OF  DB_GET_POKE@ (vl_fenetre)
	CASE COM_CANAL_FIN
	    vl_la_fenetre_est_active = FALSE


	/*A
	 * Sur reception d'un signal, selon la nature de la modification :
	 * ---------------------------------------------------------------
	 */

	CASE COM_CANAL_MTMA
		tl_params = DB_GET_POKE_DATA@ (vl_fenetre)
		tl_params = ARRAY_FROM_STRING@ (tl_params[0], MTAR_CAR_SEPAR)
		vl_commande = tl_params[0]
		vl_action = tl_params[1]
		vl_site = tl_params[2]

		CASE OF  vl_commande

		/*A
		 * un nouveau message entraine la fin de tout autre message relatif a l'evenement ;
		 * relire la liste: le message sera a sa place et les precedents marques pour fin
		 * --------------------------------------------------------------------------------
		 */

		CASE XDC_AJOUT
			vm_reveil_a_afficher=XDC_FAUX
			TMA_Init_Liste_Messages (vl_fenetre, CM_CONSERVER_TDP)
			IF (vm_reveil_a_afficher=XDC_VRAI) {
				DB_CTRL_DISPLAY@ (vl_fenetre, "ID_Liste_Modifiee", TRUE)
			}


		/*A
		 * lorsqu'un message est signale termine, mettre a jour les donnees et les visualiser
		 * ----------------------------------------------------------------------------------
		 */

		CASE XDC_TERMINE
			/* rechercher le message c'est a dire l'action TFM */
			FOR vl_i = 0  TO ARRAY_SIZE@ (tm_messages) -1
				IF (tm_infos[vl_i].num_action = vl_action) AND (tm_infos[vl_i].site = vl_site)
					BREAK vl_i
			NEXT vl_i

			/* si le message est trouve alors marquer sa fin et la visualiser */
			IF vl_i < ARRAY_SIZE@ (tm_messages) {
				DB_CTRL_DISPLAY@ (vl_fenetre, "ID_Liste_Modifiee", TRUE)

				tm_infos[vl_i].fin = XDC_VRAI
				tm_pictos[vl_i] = { CM_PICTO_A_SUPPRIMER }
				DB_TABLE_MARKER_PIXMAPS@ (vl_fenetre, "TA_Msg_Diffuser", 0, tm_pictos)

				/* et si ce message est selectionne alors mettre a jour les boutons */
				tl_selection = DB_TABLE_GET_SELECTIONS@ (vl_fenetre, "TA_Msg_Diffuser")
				IF (ARRAY_SIZE@ (tl_selection) > 0)  AND  (tl_selection[0] = vl_i) {
					DB_CTRL_GRAYED@ (vl_fenetre, "BP_Acquitter", FALSE)
					DB_CTRL_GRAYED@ (vl_fenetre, "BP_Supprimer", FALSE)
				}
			}
		ENDCASE


	/*A
	 * Sur reception du top du timer Temps De Parcours,
	 * reveiller le message de synthese des Temps De Parcours
	 * ------------------------------------------------------
	 */

	CASE COM_CANAL_MTDP_TIMER
		COM01_Trace (COM_INFO, "TOP timer TdP")
		TMA_Init_Liste_Messages(vl_fenetre, CM_CONSERVER_TDP)

		/*DB_CTRL_DISPLAY@ (vl_fenetre, "ID_Liste_Modifiee", TRUE)*/

		/*TMA_Init_Message_TDP (vl_fenetre)*/
		/*vm_nouveau_msg_tdp = XDC_VRAI*/

	/*	tm_pictos[0] = { CM_PICTO_NON_DIFFUSE }
		DB_TABLE_MARKER_PIXMAPS@ (vl_fenetre, "TA_Msg_Diffuser", 0, tm_pictos) */
	ENDCASE


	/*A
	 * Sur choix d'une zone, reinitialiser la liste des messages
	 * ---------------------------------------------------------
	 */

    CASE "BO_zone"
	TMA_Init_Liste_Messages (vl_fenetre, CM_CONSERVER_TDP)



    /*A
     * Sur action du bouton d'aide a la composition de
     * l'horodate lire et afficher l'horodate coutante
     * -----------------------------------------------
     */

    CASE "BP_horohelp"
	COM24_Afficher_Horodate (COM09_Date_Courante(TRUE), vl_fenetre,
				    "BS_Jour_Diffusion", "BS_Mois_Diffusion", "BS_Annee_Diffusion",
				    "BS_Heure_Diffusion", "BS_Minute_Diffusion", "BS_Seconde_Diffusion")



    /*A
     * Sur selection d'un message mettre a jour la date,
     * lire le texte du message a diffuser et l'afficher
     * -------------------------------------------------
     */

    CASE "TA_Msg_Diffuser"
	IF (DB_EXIT_CODE@ (vl_fenetre) = EV_TBL_SELECTION_CHANGE_)
    	{
COM01_Trace (COM_INFO, "Clique sur message")
		tl_selection = DB_EXIT_DATA@ (vl_fenetre)
		vl_i = tl_selection[0]

		vl_date = COM09_Date_Courante (TRUE)
		COM24_Afficher_Horodate (vl_date, vl_fenetre,
					    "BS_Jour_Diffusion", "BS_Mois_Diffusion", "BS_Annee_Diffusion",
					    "BS_Heure_Diffusion", "BS_Minute_Diffusion", "BS_Seconde_Diffusion")

		/* Cas du message TdP en premiere position */
		vl_cr = COM_OK
		IF (vl_i = 0)
		{
COM01_Trace (COM_INFO, "Clique sur message TDP")
			TMA_Effacer_Consignes (vl_fenetre)

	MACRO_WINS_BUSY@()
			IF (vm_nouveau_msg_tdp = XDC_VRAI)
			{
				vm_nouveau_msg_tdp = XDC_FAUX
				DB_EDITBOX_SET_DATA@ (vl_fenetre, "BE_Message", "")
				DB_DISPLAY@ (vl_fenetre)
				TMA_Init_Message_TDP (vl_fenetre)
			}

			tm_infos[0].message = vm_contenu_message_tdp
			DB_EDITBOX_SET_DATA@ (vl_fenetre, "BE_Message", vm_contenu_message_tdp)

			tm_messages[vl_i].date = null
			vl_ligne = { tm_messages[vl_i] }
			DB_TABLE_SET_NEW_DATA@ (vl_fenetre, "TA_Msg_Diffuser", vl_ligne, vl_i)

			tm_pictos[vl_i] = { CM_PICTO_DIFFUSE }
			DB_TABLE_MARKER_PIXMAPS@ (vl_fenetre, "TA_Msg_Diffuser", 0, tm_pictos)
			
		}
		/* Clic sur l'entete des messages archives, ne fait rien */
		ELSE IF (tm_infos[vl_i].type_archive = XDC_TMA_BLOC_ENT)
		{
COM01_Trace (COM_INFO, "Clique sur message entete des messages archives")
			TMA_Effacer_Consignes (vl_fenetre)
			DB_EDITBOX_CLEAR@ (vl_fenetre, "BE_Message")
			DB_DISPLAY@ (vl_fenetre)
		}
		ELSE
		{
COM01_Trace (COM_INFO, "Clique sur message autre message")
			/* Ajout SAGA : dans le cas d'un message DATEX,      */
			/*              le texte du message a diffuser est dans le champ message */
			IF (tm_infos[vl_i].id_evt = CM_EVT_DATEX)
			{
COM01_Trace (COM_INFO, "Clique sur message Pas DATEX")
				DB_EDITBOX_SET_DATA@ (vl_fenetre, "BE_Message", tm_infos[vl_i].message)
			}
			ELSE
			{
COM01_Trace (COM_INFO, "Clique sur message Pas DATEX")
				IF (tm_infos[vl_i].texte = NULL) {
COM01_Trace (COM_INFO, "Clique sur message tm_infos[vl_i].texte = NULL")
					vl_cr = TMA_Infos_Action_TFM (tm_infos[vl_i].num_action, tm_infos[vl_i].site,
									 vl_niveau, tm_infos[vl_i].texte)
				}
COM01_Trace (COM_INFO, "Clique sur message TMA_Definir_Selection/ TMA_Annuler_Selection")
				IF (vl_cr = COM_OK) {
					TMA_Definir_Selection (vl_fenetre, vl_i)
				} ELSE {
					TMA_Annuler_Selection (vl_fenetre, vl_i)
				}
				IF (tm_infos[vl_i].texte <> NULL)
				{
					if (tm_messages[vl_i].deja_diffuse=0)
					  Db_CTRL_GRAYEd@(vl_fenetre,"BP_Acquitter",FALSE)
					  else
					  Db_CTRL_GRAYEd@(vl_fenetre,"BP_Acquitter",TRUE)

COM01_Trace (COM_INFO, "Clique sur message texte et les consignes")
					/*B Afficher le texte et les consignes et acquitter le message */
					DB_EDITBOX_SET_DATA@ (vl_fenetre, "BE_Message", { tm_infos[vl_i].texte })
					vl_cr = TMA_Calcul_Consignes (vl_fenetre, tm_infos[vl_i].id_evt, vl_niveau)

					/*bouton diffuser grisé donc je diffuse automatiquement*/
					if (DB_CTRL_GET_GRAYED@(vl_fenetre,"BP_Acquitter")= TRUE) AND
						 (DB_CTRL_GET_GRAYED@(vl_fenetre,"BP_Supprimer")= TRUE)
						TMA_Acquitter_Diffusion (vl_fenetre, vl_i, vl_date)
COM01_Trace (COM_INFO, "Clique sur message TMA_Acquitter_Diffusion")
				IF (vl_cr = COM_OK) {
					TMA_Definir_Selection (vl_fenetre, vl_i)
				} ELSE {
					TMA_Annuler_Selection (vl_fenetre, vl_i)
				}

				}

			}
		}
COM01_Trace (COM_INFO, "Clique sur message")
    	}



    /*A
     * Sur acquittement, enregistrer la diffusion,
     * puis incrementer le nombre de diffusions
     * -------------------------------------------
     */

    CASE "BP_Acquitter"
		vl_date = COM09_Date_Courante (TRUE)
		COM24_Afficher_Horodate (vl_date, vl_fenetre,
					    "BS_Jour_Diffusion", "BS_Mois_Diffusion", "BS_Annee_Diffusion",
					    "BS_Heure_Diffusion", "BS_Minute_Diffusion", "BS_Seconde_Diffusion")

	tl_selection = DB_TABLE_GET_SELECTIONS@ (vl_fenetre, "TA_Msg_Diffuser")
	IF ARRAY_SIZE@ (tl_selection) > 0 {
		vl_i = tl_selection[0]
	} ELSE {
		vl_i = -1
	}

	vl_date = COM23_Horodate (vl_fenetre, "BS_Jour_Diffusion",
				    "BS_Mois_Diffusion", "BS_Annee_Diffusion",
				    "BS_Heure_Diffusion", "BS_Minute_Diffusion",
				    "BS_Seconde_Diffusion")

	IF (vl_i < 0)
	{
		NOTHING
	}

        /* Ajout SAGA : dans le cas d'un message DATEX, */
        /*              la procedure d'acquittement est differente */
	ELSE IF (tm_infos[vl_i].id_evt = CM_EVT_DATEX)
	{
		TMA_Acquitter_Diffusion_Datex (tm_infos[vl_i].code_partenaire,
		                               tm_infos[vl_i].reference_datex,
		                               vl_date)
		/*A
		 * puis supprimer le message de la liste et annuler la selection
		 * -------------------------------------------------------------
		 */

		tm_messages = ARRAY_DELETE@ (tm_messages, vl_i)
		tm_infos = ARRAY_DELETE@ (tm_infos, vl_i)
		tm_pictos = ARRAY_DELETE@ (tm_pictos, vl_i)
		DB_TABLE_SET_DATA@ (vl_fenetre, "TA_Msg_Diffuser", tm_messages, tm_titres, tm_pictos)

		TMA_Annuler_Selection (vl_fenetre)
	}

	/* Cas general d'un message relatif a un evenement (message TdP exclu) */
	ELSE IF (vl_i <> 0)
	{
		/*B Acquitter le message et conserver la selection */
		TMA_Acquitter_Diffusion (vl_fenetre, vl_i, vl_date)
		DB_CTRL_GRAYED@(vl_fenetre,"BP_Acquitter",true)
		DB_TABLE_SET_SELECTIONS@ (vl_fenetre, "TA_Msg_Diffuser", tl_selection)
	}

	DB_CTRL_DEFAULT_BUTTON@ (vl_fenetre, "BP_Acquitter", FALSE)



    /*A
     * Sur choix "Supprimer", demander la suppression du message a la base
     * -------------------------------------------------------------------
     */

    CASE "BP_Supprimer"
		vl_date = COM09_Date_Courante (TRUE)
		COM24_Afficher_Horodate (vl_date, vl_fenetre,
					    "BS_Jour_Diffusion", "BS_Mois_Diffusion", "BS_Annee_Diffusion",
					    "BS_Heure_Diffusion", "BS_Minute_Diffusion", "BS_Seconde_Diffusion")

	DB_CTRL_GRAYED@ (vl_fenetre, "BP_Supprimer", TRUE)

	tl_selection = DB_TABLE_GET_SELECTIONS@ (vl_fenetre, "TA_Msg_Diffuser")

	vl_date = COM23_Horodate (vl_fenetre, "BS_Jour_Diffusion",
				    "BS_Mois_Diffusion", "BS_Annee_Diffusion",
				    "BS_Heure_Diffusion", "BS_Minute_Diffusion",
				    "BS_Seconde_Diffusion")

	IF ARRAY_SIZE@ (tl_selection) > 0 {
		vl_i = tl_selection[0]
		TMA_Supprimer_Message (tm_infos[vl_i].num_action, tm_infos[vl_i].site, vl_date)
		'COM01_Trace(COM_INFO, "*** Suppression Msg N°:" ++ tm_infos[vl_i].num_action)

		/*A
		 * puis supprimer le message de la liste et annuler la selection
		 * -------------------------------------------------------------
		 */

		tm_messages = ARRAY_DELETE@ (tm_messages, vl_i)
		tm_infos = ARRAY_DELETE@ (tm_infos, vl_i)
		tm_pictos = ARRAY_DELETE@ (tm_pictos, vl_i)
		DB_TABLE_SET_DATA@ (vl_fenetre, "TA_Msg_Diffuser", tm_messages, tm_titres, tm_pictos)

		TMA_Annuler_Selection (vl_fenetre)
	}



    /*A
     * Sur choix "Imprimer", produire un fichier contenant
     * le texte du message puis demander l'impression du fichier
     * ---------------------------------------------------------
     */

    CASE "BP_Imprimer"
	DB_CTRL_GRAYED@ (vl_fenetre, "BP_Imprimer", TRUE)

	/*B Ouvrir une fenetre ApplixWord non visible et charger le modele */
	WP_APPLICATION_DLG@ (NULL, TRUE)
	WP_LOAD_FILE@ (SYSTEM_VAR@ (vg_repertoire_migrazur) ++
			    C_SOUS_REP_MODELES ++ C_MODELE_MSG ++ ".aw")
	WP_SET_DOC_VAR@("message", DB_EDITBOX_GET_DATA@ (vl_fenetre, "BE_Message"))

	WP_SET_DOC_VAR@("consignes", "\nConsignes de diffusion :\n\n\tNIVEAU DU MESSAGE : " ++
	                vm_lib_niveau ++ "\n\t\t" ++ vm_periodes ++ "\n\tZONE(S) TOUCHEE(S) PAR LA FMC :\n\t\t" ++
	                DB_CTRL_GET_TITLE@ (vl_fenetre, "LI_Zone1") ++ "\n\t\t" ++
	                DB_CTRL_GET_TITLE@ (vl_fenetre, "LI_Zone2") ++ "\n\t" ++
	                "MODE(S) DE DIFFUSION :\n\t\t" ++
	                DB_CTRL_GET_TITLE@ (vl_fenetre, "LI_Mode1") ++ "\n\t\t" ++
	                DB_CTRL_GET_TITLE@ (vl_fenetre, "LI_Mode2") ++ "\n")

	/*B Formater le texte actuellement ouvert en PCL */
	vl_fichier = C_MODELE_MSG ++ "_" ++ SYSTEM_VAR@ (vg_numero_poste)
	COM36_Imprimer_Texte(vl_fichier)



    CASE "BP_Synthese"
	MACRO_WINS_BUSY@()
	PEND_FOR_NEW_TASK@ ("ITMA_TMA_Synthese_TFM ")

    ENDCASE
WEND
ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Definit l'etat de l'IHM lorsque le message de rang indique est selectionne.
*
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO TMA_Definir_Selection (va_fenetre, va_rang_message)

/*
* ARGUMENTS EN ENTREE :
*   va_fenetre        : Id. de la fenetre ;
*   va_rang_message   : Index du message selectionne dans la liste.
*
*
* ARGUMENTS EN SORTIE : COM_OK si le rang indique est valide, COM_NOK sinon.
*
*
* CODE RETOUR         : Indefini
*
* CONDITION D'UTILISATION
*   Toute macro du module MTMA.
*
* FONCTION
*
---------------------------------------------------------------------------- */
VAR vl_texte

/* Verifier la validite du rang de message indique */
IF (va_rang_message < 0)  OR  (va_rang_message >= ARRAY_SIZE@ (tm_messages)) {
	RETURN (COM_NOK)
}

/* Definir la selection selection */
DB_TABLE_SET_SELECTIONS@ (va_fenetre, "TA_Msg_Diffuser", { va_rang_message} )


/* Le message Temps de Parcours ne peut faire l'objet d'aucune action */
IF (va_rang_message = 0) {
	DB_CTRL_GRAYED@ (va_fenetre, "BP_Imprimer", FALSE)
	DB_CTRL_GRAYED@ (va_fenetre, "BP_Supprimer", TRUE)
	DB_CTRL_GRAYED@ (va_fenetre, "BP_Acquitter", TRUE)
} ELSE {
	DB_CTRL_GRAYED@ (va_fenetre, "BP_Imprimer", FALSE)
	IF (tm_infos[va_rang_message].fin = XDC_VRAI) {
		DB_CTRL_GRAYED@ (va_fenetre, "BP_Acquitter", FALSE)
		DB_CTRL_GRAYED@ (va_fenetre, "BP_Supprimer", FALSE)
		'COM01_Trace(COM_INFO, "*** degraisage pour : " ++ tm_infos[va_rang_message].num_action)
	} ELSE {
		IF (tm_messages[va_rang_message].nb_diffusions = 0)
			DB_CTRL_GRAYED@ (va_fenetre, "BP_Acquitter", FALSE)
		else
			DB_CTRL_GRAYED@ (va_fenetre, "BP_Acquitter", TRUE)

		DB_CTRL_GRAYED@ (va_fenetre, "BP_Supprimer", TRUE)
	}
}

RETURN (COM_OK)

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Annule la selection d'un message dans la liste.
*  Efface toutes les valeurs affichees relatives a ce message.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO TMA_Annuler_Selection (va_fenetre)

/*
* ARGUMENTS EN ENTREE :
*   va_fenetre        : Id. de la fenetre ;
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : Indefini
*
* CONDITION D'UTILISATION
*   Toute macro du module MTMA.
*
* FONCTION
*
---------------------------------------------------------------------------- */

/* Effacer le texte du message, la date et les consignes */
DB_EDITBOX_CLEAR@ (va_fenetre, "BE_Message")

COM24_Afficher_Horodate (NULL, va_fenetre,
                            "BS_Jour_Diffusion", "BS_Mois_Diffusion", "BS_Annee_Diffusion",
                            "BS_Heure_Diffusion", "BS_Minute_Diffusion", "BS_Seconde_Diffusion")

TMA_Effacer_Consignes (va_fenetre)


/* Annuler la selection dans la liste et inhiber les actions sur la selection */
DB_TABLE_SET_SELECTIONS@ (va_fenetre, "TA_Msg_Diffuser", NULL)

DB_CTRL_GRAYED@ (va_fenetre, "BP_Imprimer", TRUE)
DB_CTRL_GRAYED@ (va_fenetre, "BP_Supprimer", TRUE)
DB_CTRL_GRAYED@ (va_fenetre, "BP_Acquitter", TRUE)

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*   Initialise les donnees de configuration des consignes Trafic FM.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO ITMA_TMA_Lire_Configuration_TFM

/*
* ARGUMENTS EN ENTREE : Aucun
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : COM_OK.
*
* CONDITION D'UTILISATION
*
*
* FONCTION
*   Lit les fichiers de configuration TFM et initialise les donnees.
*
---------------------------------------------------------------------------- */

VAR	vl_chemin
VAR	vl_rgb


vl_chemin = SYSTEM_VAR@( vg_repertoire_migrazur ) ++ COM_SOUS_REP_NTFM


/*A Chargement du fichier de configuration des troncons Trafic FM
 *  ------------------------------------------------------------- */

tm_troncons_TFM = COM47_LireTable (vl_chemin ++ "/troncon_TFM.txt", { "#" }, ",")


/*A Chargement du fichier de configuration des modes de diffusion
 *  ------------------------------------------------------------- */
tm_modes_TFM = COM47_LireTable (vl_chemin ++ "/mode_diffusion.txt", { "#" }, ",")


/*A Chargement du fichier de configuration des zones de diffusion
 *  ------------------------------------------------------------- */
tm_zones_TFM = COM47_LireTable (vl_chemin ++ "/zones_diffusion.txt", { "#" }, ",")


/*A Chargement des fichiers de configuration des periodes de diffusion
 *  ------------------------------------------------------------------ */
tm_periodes_diff = COM47_LireTable (vl_chemin ++ "/periode_diffusion.txt", { "#" }, ",")
tm_periodes_diff_TA = COM47_LireTable (vl_chemin ++ "/periode_diffusion_TA.txt", { "#" }, ",")


/*A
 * Initialisation des couleurs
 * ---------------------------
 */

vl_rgb = { 0,0,0 }
tm_couleurs[0] = { "noir", vl_rgb }
vl_rgb = { 255,0,50 }
tm_couleurs[1] = { "rouge", vl_rgb }
vl_rgb = { 0,150,0 }
tm_couleurs[2] = { "vert", vl_rgb }
vl_rgb = { 0,0,255 }
tm_couleurs[3] = { "bleu", vl_rgb }

RETURN (COM_OK)

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Initialise la visualisation.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO TMA_Init_Visualisation (va_fenetre)

/*
* ARGUMENTS EN ENTREE :
*   va_fenetre        : Id. de la fenetre a initialiser.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : COM_OK en cas d'execution correcte, COM_NOK sinon.
*
* CONDITION D'UTILISATION
*   ITMA_TMA_Msg_Animateur_TFM
*
* FONCTION
*   Initialise les valeurs a afficher et le fonctionnement general du module.
*
---------------------------------------------------------------------------- */

VAR	FORMAT TDO_District	tl_les_districts

/*A
 * Definir les valeurs de constantes du module
 * -------------------------------------------
 */

CM_EVT_TDP.numero = 1		' Evenement particulier representant le message TDP
CM_EVT_TDP.cle = 1

CM_EVT_DATEX.numero = 0		' Evenement particulier representant UN message DATEX
CM_EVT_DATEX.cle = 0


/*A
 * Lire dans l'environnement la liste des districts
 * ------------------------------------------------
 */

tl_les_districts = SYSTEM_VAR@ (vg_les_districts)
tm_numeros_districts = ARRAY_COLUMN@ (tl_les_districts, TDO_NUMERO_DISTRICT)


/*A
 * Definir les titres des colonnes de la table
 * -------------------------------------------
 */

tm_titres = {					' Titre colonne,taille en pixels
	{ "Numéro",		100 },
	{ "Intitulé",		420 },
	{ "Niv",		45 },
	{ "Consult.",	60 },
	{ "Heure transmission",	175 },
	{ "", 0 }
}

DB_DISPLAY_ONLY@ (va_fenetre, TRUE)                     ' Pour avoir acces
DB_DISPLAY@ (va_fenetre)                                '  a l'objet table

DB_TABLE_SET_DATA@(va_fenetre, "TA_Msg_Diffuser", NULL, tm_titres)


TMA_Effacer_Consignes (va_fenetre)


/*A
 * Valuer ensuite les donnees de la table
 * --------------------------------------
 */

IF (TMA_Init_Liste_Messages (va_fenetre, CM_REINIT_TDP) <> COM_OK)
	RETURN (COM_NOK)

/* Pas de calcul de Temps de Parcours, mais a la prochaine action operateur */
/*TMA_Init_Message_TDP (va_fenetre)*/
vm_nouveau_msg_tdp = XDC_VRAI

RETURN (COM_OK)

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Initialise la liste des messages a diffuser ;
*  met en evidence les messages dont le nombre de diffusions est 0.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO TMA_Init_Liste_Messages (va_fenetre, va_init_tdp)

/*
* ARGUMENTS EN ENTREE :
*   va_fenetre        : Id. de la fenetre contenant les objets a initialiser.
*   va_init_tdp       : Indicateur de conservation du message TdP.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : COM_OK en cas d'execution correcte, COM_NOK sinon.
*
* CONDITION D'UTILISATION
*   TMA_Init_Visualisation      a l'initialisation ;
*   ITMA_TMA_Msg_Animateur_TFM	sur signal de modification dans la liste.
*
* FONCTION
*   (re)initialise les valeurs de la liste des messages a diffuser.
*   Selon la consigne, reinitialise ou non le message TdP.
*
---------------------------------------------------------------------------- */

VAR	FORMAT TMA_Donnees_Message_TFM		tl_data
VAR	FORMAT TMA_Localisations_FMC		tl_localisations

VAR	FORMAT TMA_Message_TFM		tl_msg
VAR	FORMAT TMA_Info_Message_TFM	tl_infos, tl_infos_prec

VAR	FORMAT SQL_Procedure_Params@	vl_parametres
VAR	FORMAT SQL_Procedure_Result@	vl_resultats

VAR	tl_selections, vl_idx_selecte
VAR	vl_zone_choisie, vl_nom_zone_choisie

VAR	FORMAT TDO_Dictionnaire		tl_evt_et_loc	' les localisations par evenement
VAR	FORMAT TMA_Troncon_Oriente	tl_trc

VAR	vl_district
VAR	vl_msg_a_visualiser
VAR	vl_msg_a_traiter
VAR	i,j, z,t, vl_i_evt

/*B
 * Desactiver la selection d'un message dans la liste durant la reinitialisation
 * -----------------------------------------------------------------------------
 */

DB_CTRL_PICKABLE@ (va_fenetre, "TA_Msg_Diffuser", FALSE)
MACRO_WINS_BUSY@ ()

vm_reveil_a_afficher=XDC_FAUX

/*B Memoriser la selection actuelle */
vl_idx_selecte = -1
tl_selections = DB_TABLE_GET_SELECTIONS@ (va_fenetre, "TA_Msg_Diffuser")
IF ARRAY_SIZE@ (tl_selections) > 0 {
	vl_idx_selecte = tl_selections[0]

	/* Annuler la selection d'un message DATEX */
	IF (tm_infos[vl_idx_selecte].id_evt = CM_EVT_DATEX) {
		vl_idx_selecte = -1
	}
}


/*B
 * Effacer les structures de donnees (pour reinitialisation)
 * ---------------------------------------------------------
 */

tl_infos_prec = tm_infos


/*A
 * Definir le premier message (synthese des temps de parcours)
 * -----------------------------------------------------------
 */

IF (va_init_tdp = CM_CONSERVER_TDP) {
	tm_messages	= { tm_messages[0] }
	tm_infos	= { tm_infos[0] }
	tm_pictos	= { tm_pictos[0] }
} ELSE {
	tm_messages[0] = { }
	tm_messages[0].intitule = "Synthese des Temps de Parcours"
	vm_contenu_message_tdp = ""

	tm_infos[0] = { }
	tm_infos[0].id_evt = CM_EVT_TDP
	tm_infos[0].fin = XDC_FAUX

	tm_pictos = NULL
}


/*A
 * Lire la nouvelle liste de messages a diffuser
 * ---------------------------------------------
 */

IF COM05_SQL_Procedure ("XZAI400"/*XZAI04_Liste_Messages*/, NULL, vl_resultats, C_MODULE) = COM_OK
{
	tl_data = vl_resultats.select_results[0]
}

FOR i = 0  TO ARRAY_SIZE@ (tl_data) - 1
	tl_infos[i].id_evt.numero = tl_data[i].num_evt
	tl_infos[i].id_evt.cle = tl_data[i].cle_evt
	tl_infos[i].type = tl_data[i].type
	tl_infos[i].fin = tl_data[i].fin
	tl_infos[i].num_action = tl_data[i].num_action
	tl_infos[i].site = tl_data[i].site
	tl_infos[i].niveau = tl_data[i].niveau
	tl_infos[i].message = tl_data[i].message1 ++ tl_data[i].message2 /* SAGA */
	tl_infos[i].code_partenaire = tl_data[i].code_partenaire         /* SAGA */
	tl_infos[i].reference_datex = tl_data[i].reference_datex         /* SAGA */
	tl_infos[i].numero_type = tl_data[i].numero_type         
	tl_infos[i].texte = NULL
	tl_infos[i].type_archive = tl_data[i].priorite_arc

	tl_msg[i].niveau = tl_data[i].niveau
	tl_msg[i].nb_diffusions = tl_data[i].nb_diffusions
	tl_msg[i].date = COM18_Date_SGBD_Formatee (tl_data[i].date)
	tl_msg[i].numero_type = tl_data[i].numero_type
	tl_msg[i].deja_diffuse = tl_data[i].deja_diffuse
	/* Ajout SAGA : dans le cas d'un message DATEX                */
	/*              on affiche le partenaire a la place du numero */
	/*              et la reference datex a la place de l'intitule */
	IF (tl_infos[i].id_evt = CM_EVT_DATEX)
	{
		tl_msg[i].numero = tl_data[i].code_partenaire
		tl_msg[i].intitule = tl_data[i].reference_datex
	}
	ELSE
	{
		tl_msg[i].intitule = tl_data[i].type
		vl_district = ARRAY_INDEX@ (tm_numeros_districts, tl_data[i].cle_evt)
		IF vl_district >= 0 {
			tl_msg[i].numero = tl_data[i].num_evt ++ " - " ++ tl_data[i].cle_evt
		} ELSE {
			tl_msg[i].numero = tl_data[i].num_evt
		}
	}

	/* Conserver les donnees supplementaires precedentes du message */
	FOR j = 0  TO ARRAY_SIZE@ (tl_infos_prec) - 1
		IF (tl_infos_prec[j].num_action = tl_infos[i].num_action)
		   AND (tl_infos_prec[j].site = tl_infos[i].site)
		{
			tl_infos[i].texte = tl_infos_prec[j].texte
			BREAK j
		}
	NEXT j
NEXT i


/*A
 * Filtrer les messages en fonction de la zone choisie,
 * du niveau des messages et de leur(s) localisation(s)
 * ----------------------------------------------------
 */

vl_zone_choisie = DB_CTRL_GET_VALUE@ (va_fenetre, "BO_zone")
IF (vl_zone_choisie = 1) {
	vl_nom_zone_choisie = "Z1"
} ELSE IF (vl_zone_choisie = 2) {
	vl_nom_zone_choisie = "Z2"
}

j = 1
FOR i = 0 TO ARRAY_SIZE@ (tl_msg) - 1
	vl_msg_a_visualiser = FALSE
	vl_msg_a_traiter=TRUE
	/* Si toutes les zones sont visualisees alors le message doit l'etre */
	IF (vl_zone_choisie = 0) {
		vl_msg_a_visualiser = TRUE
		 COM01_Trace(COM_DEBUG1,"Localisation toute zone:"++tl_infos[i].id_evt[0])
		if (tl_infos[i].id_evt[0]="") {
			 vl_msg_a_visualiser = TRUE }
		else {
		 IF (TMA_PR_FMC (tl_infos[i].id_evt, tl_localisations) = COM_OK) {
		 COM01_Trace(COM_DEBUG1,"Localisation toute zone:"++tl_localisations[0][0]++";"++tl_localisations[0][1]++";"++tl_localisations[0][2]++";"++tl_localisations[0][3])
		 if (tl_localisations[0][0]="A0") {
		 	vl_msg_a_visualiser = FALSE }
		}
		}
	}
	ELSE IF (tl_infos[i].niveau > 1)  OR  (tl_infos[i].id_evt = CM_EVT_DATEX) OR (tl_infos[i].type_archive = XDC_TMA_BLOC_ENT)
	{
		/* et si la nature ou le niveau du message l'exige egalement */
		vl_msg_a_visualiser = TRUE
	}
	ELSE
	{
		/*DEM459*/
		/* sinon rechercher la localisation ou se situe l'evenement */
		vl_i_evt = COM45_IndexEnColonne (tl_evt_et_loc, TDO_DICO_CLE, tl_infos[i].id_evt)
		IF (vl_i_evt >= 0) {
			tl_localisations = tl_evt_et_loc[vl_i_evt].valeur
		} ELSE IF (TMA_PR_FMC (tl_infos[i].id_evt, tl_localisations) = COM_OK) {
			COM01_Trace(COM_DEBUG1,"Localisation:"++tl_localisations[0][0]++";"++tl_localisations[0][1]++";"++tl_localisations[0][2]++";"++tl_localisations[0][3])
			if (tl_localisations[0][0]<>"A0") {
				tl_evt_et_loc[ARRAY_SIZE@ (tl_evt_et_loc)] = { tl_infos[i].id_evt, tl_localisations }
			}
			else {
			 vl_msg_a_traiter=FALSE	
			COM01_Trace(COM_DEBUG1,"Localisation:"++ARRAY_SIZE@ (tl_localisations))
				}
		}
		IF ( vl_msg_a_traiter=TRUE) AND (ARRAY_SIZE@ (tl_localisations) > 0) {
			/* puis les troncons ou se situe l'evenement */
			tl_trc = TMA_Troncons_Evenement (tl_localisations)

			/* et pour chacun de ces troncons orientes */
			z = 0
			WHILE (vl_msg_a_visualiser = FALSE)  AND  (z < ARRAY_SIZE@ (tm_zones_TFM))
				IF (tm_zones_TFM[z].nom = vl_nom_zone_choisie) {
					/* determiner s'il est sur la zone visualisee dans la meme direction */
					t = 0
					WHILE (vl_msg_a_visualiser = FALSE)  AND  (t < ARRAY_SIZE@ (tl_trc))
						IF TMA_Sens_Compatible_Avec (tl_trc[t].sens, tm_zones_TFM[z].sens)
						   AND (ARRAY_INDEX@ (tm_zones_TFM[z], tl_trc[t].nom) >= 0)
						{
							vl_msg_a_visualiser = TRUE
						}
						t = t + 1
					WEND
				}
				z = z + 1
			WEND
		}
	}

	/* si le message est a visualiser alors l'ajouter a la liste */
	IF (vl_msg_a_visualiser = TRUE) {
		tm_messages[j] = tl_msg[i]
		tm_infos[j] = tl_infos[i]
		j = j + 1
	}
NEXT i


/*A
 * attacher le pictogramme voulu a chaque message (sauf le message TDP)
 * --------------------------------------------------------------------
 */

FOR i = 1  TO ARRAY_SIZE@ (tm_messages) - 1
	IF (tm_infos[i].fin = XDC_VRAI) {
		tm_pictos[i] = { CM_PICTO_A_SUPPRIMER }
		vm_reveil_a_afficher=XDC_VRAI
	} ELSE IF tm_messages[i].nb_diffusions = 0 {
		if (ARRAY_INDEX@(C_TYPES,tm_messages[i].numero_type)) >= 0 {
			if (tm_messages[i].deja_diffuse=0)
				tm_pictos[i] = { CM_PICTO_EVIDENCE }
			else
				tm_pictos[i] = { CM_PICTO_NON_DIFFUSE }
			vm_reveil_a_afficher=XDC_VRAI
		} else {
			tm_pictos[i] = { CM_PICTO_NON_DIFFUSE }
		vm_reveil_a_afficher=XDC_VRAI
		}
	} ELSE 
		tm_pictos[i] = { CM_PICTO_DIFFUSE }
NEXT i


/*A
 * (re)initialiser la table affichee
 * ---------------------------------
 */

DB_TABLE_SET_DATA@ (va_fenetre, "TA_Msg_Diffuser", tm_messages, tm_titres, tm_pictos)


/* REPERE1 */
/* Rechercher dans les nouvelles donnees le message selectionne (sauf le message TDP) */
IF (vl_idx_selecte > 0) {
	FOR i = 1  TO ARRAY_SIZE@ (tm_messages) - 1
		IF (tm_infos[i].num_action = tl_infos_prec[vl_idx_selecte].num_action)
		   AND (tm_infos[i].site = tl_infos_prec[vl_idx_selecte].site)
			BREAK i
	NEXT i
	/* et s'il est trouve alors noter son nouveau rang */
	IF (i < ARRAY_SIZE@ (tm_messages)) {
		vl_idx_selecte = i
	} ELSE {
		vl_idx_selecte = -1
	}
}
/* on repointe sur le meme evenement */
IF (vl_idx_selecte >= 0) {
	TMA_Definir_Selection (va_fenetre, vl_idx_selecte)
} ELSE {
	TMA_Annuler_Selection (va_fenetre)
}


/*A
 * Afficher les messages a l'operateur et attendre avant d'autoriser une selection
 * -------------------------------------------------------------------------------
 */

DB_DISPLAY@ (va_fenetre)
DELAY@ (1)

RETURN (COM_OK)

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Calcul du message Temps De Parcours
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FORMAT  TMA_Message_TDP
	origine,
	destination,
	tdp

MACRO TMA_Init_Message_TDP (va_fenetre)

/*
* ARGUMENTS EN ENTREE :
*   va_fenetre        : Id. de la fenetre contenant les objets a initialiser.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : COM_OK en cas d'execution correcte, COM_NOK sinon.
*
* CONDITION D'UTILISATION
*   TMA_Init_Visualisation      a l'initialisation ;
*   ITMA_TMA_Msg_Animateur_TFM	sur choix du message TdP par l'operateur.
*
* FONCTION
*   (re)initialise le message Temps de Parcours.
*
---------------------------------------------------------------------------- */

VAR	FORMAT SQL_Procedure_Params@	vl_parametres
VAR	FORMAT SQL_Procedure_Result@	vl_resultats

VAR	FORMAT TMA_Message_TDP		vl_msg_tdp1, vl_msg_tdp2

VAR	vl_select, vl_i

VAR	tl_data, tl_data_tdp
VAR	vl_lib_sens1, vl_lib_sens2
VAR	vl_ligne
VAR	vl_horo

VAR	i, j, k


/*B Memoriser la selection actuelle */
vl_select = DB_TABLE_GET_SELECTIONS@ (va_fenetre, "TA_Msg_Diffuser")
IF ARRAY_SIZE@ (vl_select) > 0 {
	vl_i = vl_select[0]
} ELSE {
	vl_i = -1
}


tm_infos[0].message = null


/*B Recuperation du tableau 4 colonnes: autoroute, sens, origine, destination recherches */
vl_parametres[0].type = SYB#INT1_
vl_parametres[0].data = 0
vl_parametres[0].output = FALSE

vl_parametres[1].type = SYB#INT1_
vl_parametres[1].data = 0
vl_parametres[1].output = FALSE

vl_parametres[2].type = SYB#INT1_
vl_parametres[2].data = 0
vl_parametres[2].output = FALSE

vl_parametres[3].type = SYB#CHAR_
vl_parametres[3].data = "toutes"
vl_parametres[3].output = FALSE

vl_parametres[4].type = SYB#CHAR_
vl_parametres[4].data = "toutes"
vl_parametres[4].output = FALSE

IF COM05_SQL_Procedure (XZAO434_Liste_Origines_Destinations,
                           vl_parametres, vl_resultats, C_MODULE) <> COM_OK
{
	RETURN (COM_NOK)
}
tl_data = vl_resultats.select_results[0]


j = 0
k = 0
vl_parametres = NULL
FOR i=0 TO ARRAY_SIZE@(tl_data)-1
	vl_resultats = null
	vl_parametres[0].type = SYB#INT1_		' sens
	vl_parametres[0].data = tl_data[i,1]
	vl_parametres[0].output = FALSE

	vl_parametres[1].type = SYB#CHAR_		' origine
	vl_parametres[1].data = tl_data[i,2]
	vl_parametres[1].output = FALSE

	vl_parametres[2].type = SYB#CHAR_		' destination
	vl_parametres[2].data = tl_data[i,3]
	vl_parametres[2].output = FALSE

	vl_parametres[3].type = SYB#INT1_               ' autoroute
	vl_parametres[3].data = tl_data[i,4]
	vl_parametres[3].output = FALSE

	IF COM05_SQL_Procedure (XZAO435_Calcul_TDP_RTFM,
	                           vl_parametres, vl_resultats, C_MODULE) <> COM_OK
	{
		RETURN (COM_NOK)
	}
	tl_data_tdp = vl_resultats.select_results[0]

	vl_horo = COM18_Date_SGBD_Formatee(tl_data_tdp[0,4])

	IF (tl_data_tdp[0,0] = 1)
	{
		vl_msg_tdp1[j].origine = "   * " ++  tl_data_tdp[0,1]
		vl_msg_tdp1[j].destination =  " -> " ++ tl_data_tdp[0,2]
		vl_msg_tdp1[j].tdp = ": " ++ tl_data_tdp[0,3]
		j = j + 1
	}
	ELSE
	{
		vl_msg_tdp2[k].origine = "   * " ++ tl_data_tdp[0,1]
		vl_msg_tdp2[k].destination =  " -> " ++ tl_data_tdp[0,2]
		vl_msg_tdp2[k].tdp = ": " ++ tl_data_tdp[0,3]
		k = k + 1
	}
NEXT i


vl_lib_sens1 = null
FOR i=0 TO ARRAY_SIZE@(vl_msg_tdp1) -1
	vl_lib_sens1 = vl_lib_sens1 ++ "\n" ++ ARRAY_TO_STRING@(vl_msg_tdp1[i], "")
NEXT i
vl_lib_sens1 = "Sens 1:" ++ "\n" ++ vl_lib_sens1 ++ "\n"


vl_lib_sens2 = null
FOR i=0 TO ARRAY_SIZE@(vl_msg_tdp2) -1
	vl_lib_sens2 = vl_lib_sens2 ++  "\n" ++ ARRAY_TO_STRING@(vl_msg_tdp2[i], "")
NEXT i
vl_lib_sens2 = "Sens 2:" ++ "\n" ++ vl_lib_sens2 ++ "\n"


tm_messages[0].numero = null
tm_messages[0].intitule = "Synthese des Temps de Parcours"
tm_messages[0].niveau = null
tm_messages[0].nb_diffusions = null
tm_messages[0].date = null


tm_infos[0].id_evt = CM_EVT_TDP
tm_infos[0].type = null
tm_infos[0].fin = XDC_FAUX
tm_infos[0].num_action  = null
tm_infos[0].niveau = null

vm_contenu_message_tdp = vl_lib_sens1 ++ "\n" ++ vl_lib_sens2 ++ "\n" ++ "Tdp relevés le: " ++ vl_horo
tm_infos[0].message = vm_contenu_message_tdp
tm_infos[0].code_partenaire = null
tm_infos[0].reference_datex = null


vl_ligne = { tm_messages[0] }
DB_TABLE_SET_NEW_DATA@ (va_fenetre, "TA_Msg_Diffuser", vl_ligne, 0)


/*A
 * Indiquer que le message TDP est mis a jour
 * et s'il est selectionne alors l'afficher
 * ------------------------------------------
 */

vm_nouveau_msg_tdp = XDC_FAUX

IF (vl_i = 0) {
	DB_EDITBOX_SET_DATA@ (va_fenetre, "BE_Message", vm_contenu_message_tdp)
}

/* Restaurer la selection */
DB_TABLE_SET_SELECTIONS@ (va_fenetre, "TA_Msg_Diffuser", vl_select)

RETURN (COM_OK)

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Recherche les donnees (niveau, texte, dates) relatives a une action TFM.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO TMA_Infos_Action_TFM (va_num_action, va_site, va_niveau, va_texte)

/*
* ARGUMENTS EN ENTREE :
*   va_num_action     : Numero de l'action ;
*   va_site           : Identifiant su site.
*
*
* ARGUMENTS EN SORTIE :
*   va_niveau         : Niveau de diffusion ;
*   va_texte          : Texte du message.
*
*
* CODE RETOUR         : COM_OK en cas d'execution correcte, COM_NOK sinon.
*
* CONDITION D'UTILISATION
*   ITMA_TMA_Msg_Animateur_TFM
*
* FONCTION
*   Lit en base et retourne les donnees de l'action TFM indiquee.
*
---------------------------------------------------------------------------- */

VAR	vl_texte					' Texte du message (chaine)

VAR	FORMAT SQL_Procedure_Params@	vl_parametres
VAR	FORMAT SQL_Procedure_Result@	vl_resultats
VAR	i


/* Valeurs par defaut des donnees retournees */
va_niveau = NULL
va_texte = NULL


vl_parametres[0].type = SYB#INT4_
vl_parametres[0].data = va_num_action
vl_parametres[0].output = FALSE

vl_parametres[1].type = SYB#INT1_
vl_parametres[1].data = va_site
vl_parametres[1].output = FALSE

vl_parametres[2].type = SYB#DATETIME_			' Horodate lancement
vl_parametres[2].output = TRUE

vl_parametres[3].type = SYB#DATETIME_			' Horodate lancement fin
vl_parametres[3].output = TRUE

vl_parametres[4].type = SYB#DATETIME_			' Horodate 1e diffusion
vl_parametres[4].output = TRUE

vl_parametres[5].type = SYB#DATETIME_			' Horodate suppression
vl_parametres[5].output = TRUE

vl_parametres[6].type = SYB#INT4_			' Nombre diffusions
vl_parametres[6].output = TRUE

vl_parametres[7].type = SYB#INT1_
vl_parametres[7].output = TRUE

IF COM05_SQL_Procedure (XZAC44_Lire_ActionTFM,
			   vl_parametres, vl_resultats, C_MODULE) <> COM_OK
{
	RETURN (COM_NOK)
}


va_niveau = vl_resultats.return_parameters[5]
if va_niveau>3
{
	va_niveau=2
}
FOR i = 0  TO ARRAY_SIZE@ (vl_resultats.select_results[0]) - 1
	vl_texte = vl_texte ++ vl_resultats.select_results[0, i, 0]
NEXT i
va_texte = vl_texte

RETURN (COM_OK)

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Recherche des localisations (autoroute, PR) d'une FMC.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO TMA_PR_FMC (FORMAT COM_Identifiant_FMC va_id_evt, FORMAT TMA_Localisations_FMC ta_localisations)

/*
* ARGUMENTS EN ENTREE :
*   va_id_evt     : Identifiant de l'evenement.
*
*
* ARGUMENTS EN SORTIE :
*   ta_localisations  : (Liste de) localisation(s) de l'evenement.
*
*
* CODE RETOUR         : COM_OK en cas d'execution correcte, COM_NOK sinon.
*
* CONDITION D'UTILISATION
*   ITMA_TMA_Msg_Animateur_TFM
*
* FONCTION
*   Lit en base de donnees la (les) localisation(s) (autoroute, PR) de la FMC.
*
---------------------------------------------------------------------------- */

VAR	FORMAT SQL_Procedure_Params@		vl_parametres
VAR	FORMAT SQL_Procedure_Result@		vl_resultats

/* Valeurs par defaut des donnees retournees */
ta_localisations = { }


/* Ajout SAGA : ne rien faire pour un message DATEX */
/*              ne rien faire pour le message TDP */
IF (va_id_evt = CM_EVT_DATEX)  OR  (va_id_evt = CM_EVT_TDP)
{
	RETURN (COM_OK)
}


vl_parametres[0].type = SYB#INT4_
vl_parametres[0].data = va_id_evt.numero
vl_parametres[0].output = FALSE

vl_parametres[1].type = SYB#INT1_
vl_parametres[1].data = va_id_evt.cle
vl_parametres[1].output = FALSE


IF COM05_SQL_Procedure (XZAE111_Lire_Localisation_FMC,
			   vl_parametres, vl_resultats, C_MODULE) <> COM_OK
{
	RETURN (COM_NOK)
}


ta_localisations = vl_resultats.select_results[0]

RETURN (COM_OK)

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Enregistre la diffusion d'un message TFM DATEX et sa date.
*  (Ajout SAGA)
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO TMA_Acquitter_Diffusion_Datex (va_code_partenaire, va_reference_datex, va_horodate)

/*
* ARGUMENTS EN ENTREE :
*   va_code_partenaire : Code du partenaire DATEX
*   va_reference_datex : Reference DATEX
*   va_horodate        : Date de diffusion.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : COM_OK en cas d'execution correcte, COM_NOK sinon.
*
* CONDITION D'UTILISATION
*   ITMA_TMA_Msg_Animateur_TFM
*
* FONCTION
*   Execute simplement la requete adequate pour memoriser l'acquittement.
*
---------------------------------------------------------------------------- */

	VAR	FORMAT SQL_Procedure_Params@ vl_parametres
	VAR	FORMAT SQL_Procedure_Result@ vl_resultats

	vl_parametres[0].type = SYB#CHAR_
	vl_parametres[0].data = va_code_partenaire
	vl_parametres[0].output = FALSE

	vl_parametres[1].type = SYB#CHAR_
	vl_parametres[1].data = va_reference_datex
	vl_parametres[1].output = FALSE

	vl_parametres[2].type = SYB#DATETIME_
	vl_parametres[2].data = va_horodate
	vl_parametres[2].output = FALSE

	'COM01_Trace (COM_FONCTION, "Acquitter_Message DATEX " ++ va_code_partenaire ++ "/" ++ va_reference_datex)
	IF COM05_SQL_Procedure (XZAI502_Acquitter_Messages_DATEX,
				   vl_parametres, vl_resultats, C_MODULE) <> COM_OK
	       RETURN (COM_NOK)

       RETURN (COM_OK)

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Enregistre la diffusion d'un message TFM et sa date.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO TMA_Acquitter_Diffusion (va_fenetre, va_idx_msg, va_horodate)

/*
* ARGUMENTS EN ENTREE :
*   va_fenetre        : Identifiant de la fenetre de dialogue
*   va_idx_msg        : Index du message a acquitter
*   va_horodate       : Date de diffusion.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : COM_OK en cas d'execution correcte, COM_NOK sinon.
*
* CONDITION D'UTILISATION
*   ITMA_TMA_Msg_Animateur_TFM
*
* FONCTION
*   Execute simplement la requete adequate pour memoriser l'acquittement.
*
---------------------------------------------------------------------------- */

VAR	FORMAT SQL_Procedure_Params@	vl_parametres
VAR	FORMAT SQL_Procedure_Result@	vl_resultats
VAR	vl_ligne


vl_parametres[0].type = SYB#INT4_
vl_parametres[0].data = tm_infos[va_idx_msg].num_action
vl_parametres[0].output = FALSE

vl_parametres[1].type = SYB#INT1_
vl_parametres[1].data = tm_infos[va_idx_msg].site
vl_parametres[1].output = FALSE

vl_parametres[2].type = SYB#DATETIME_
vl_parametres[2].data = va_horodate
vl_parametres[2].output = FALSE

COM01_Trace(COM_FONCTION,"Acquitter_Message " ++DB_CTRL_GET_GRAYED@(va_fenetre,"BP_Acquitter")++"/"++tm_infos[va_idx_msg].num_action ++ "/" ++ tm_infos[va_idx_msg].site)
IF COM05_SQL_Procedure (XZAI05_Acquitter_Message,
			   vl_parametres, vl_resultats, C_MODULE) <> COM_OK
{
	RETURN (COM_NOK)
}


/*B Si l'acquittement est effectue, mettre a jour le nombre de diffusions */
tm_messages[va_idx_msg].nb_diffusions = tm_messages[va_idx_msg].nb_diffusions + 1

/*B et si c'est la premiere diffusion, mettre a jour la date et le pictogramme */
IF tm_messages[va_idx_msg].nb_diffusions >= 1 {
	tm_messages[va_idx_msg].date = va_horodate
	tm_pictos[va_idx_msg] = { CM_PICTO_DIFFUSE }
	DB_TABLE_MARKER_PIXMAPS@ (va_fenetre, "TA_Msg_Diffuser", 0, tm_pictos)
	tm_messages[va_idx_msg].deja_diffuse = 1
}

vl_ligne = { tm_messages[va_idx_msg] }
DB_TABLE_SET_NEW_DATA@ (va_fenetre, "TA_Msg_Diffuser", vl_ligne, va_idx_msg)

RETURN (COM_OK)

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Supprime un message de la liste a diffuser.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO TMA_Supprimer_Message (va_num_action, va_num_site_action, va_horodate)

/*
* ARGUMENTS EN ENTREE :
*   va_num_action      : Numero de l'action
*   va_num_site_action : Numero du site de l'action
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : COM_OK en cas d'execution correcte, COM_NOK sinon.
*
* CONDITION D'UTILISATION
*   ITMA_TMA_Msg_Animateur_TFM
*
* FONCTION
*   Execute simplement la requete adequate pour supprimer le message.
*
---------------------------------------------------------------------------- */

VAR	FORMAT SQL_Procedure_Params@	vl_parametres
VAR	FORMAT SQL_Procedure_Result@	vl_resultats


vl_parametres[0].type = SYB#INT4_
vl_parametres[0].data = va_num_action
vl_parametres[0].output = FALSE

vl_parametres[1].type = SYB#INT1_
vl_parametres[1].data = va_num_site_action
vl_parametres[1].output = FALSE

vl_parametres[2].type = SYB#DATETIME_
vl_parametres[2].data = va_horodate
vl_parametres[2].output = FALSE

'COM01_Trace (COM_FONCTION, "Supprimer_Message " ++ va_num_action ++ "/" ++ va_num_site_action)
IF COM05_SQL_Procedure (XZAI06_Supprimer_Message_TFM,
			   vl_parametres, vl_resultats, C_MODULE) <> COM_OK
{
	RETURN (COM_NOK)
}

RETURN (COM_OK)

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Calcule les consignes relatives a un evenement pour l'animateur.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO TMA_Calcul_Consignes (va_fenetre, FORMAT COM_Identifiant_FMC va_evt, va_niveau)

/*
* ARGUMENTS EN ENTREE :
*   va_fenetre        : Id. de la fenetre ;
*   va_evt            : Evenement ;
*   va_niveau         : Niveau de diffusion.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : COM_OK en cas d'execution correcte, COM_NOK sinon.
*
* CONDITION D'UTILISATION
*   ITMA_TMA_Msg_Animateur_TFM
*
* FONCTION
*
---------------------------------------------------------------------------- */

VAR	FORMAT TMA_Localisations_FMC	tl_localisations

VAR vl_couleur, vl_mode1, vl_mode2, tl_zones, vl_zone2
VAR tl_trc
VAR vl_periodeT, vl_periodeTA
VAR vl_index, vl_indice, i, j


/*A S'il n'y a pas de niveau de message TFM alors on vide les champs */
IF ( ( IS_NULL@(va_niveau) ) OR (va_niveau = XDC_SANS_NTFMAX) ){
	TMA_Effacer_Consignes (va_fenetre)
	RETURN (COM_OK)
}

/*A Rechercher la ou les localisations de la FMC */
IF ( TMA_PR_FMC (va_evt, tl_localisations) <> COM_OK ) {
	TMA_Effacer_Consignes (va_fenetre)
	RETURN (COM_NOK)
}
COM01_Trace(COM_DEBUG1,"Localisation ci:"++tl_localisations[0][0]++";"++tl_localisations[0][1]++";"++tl_localisations[0][2]++";"++tl_localisations[0][3])

/*B Recherche des troncons ou se situe l'evenement */
tl_trc = TMA_Troncons_Evenement (tl_localisations)


/*A Calcul des consignes */

/*B Determination des modes de diffusion et couleur associee */
DB_CTRL_TITLE@(va_fenetre, "LI_T", "")
vl_index=COM45_IndexEnColonne (tm_modes_TFM, TMA_MOD_NIVEAU, va_niveau)
IF ( vl_index >= 0 ) {
	vl_mode1=tm_modes_TFM[vl_index].mode1
	vl_mode2=tm_modes_TFM[vl_index].mode2
	vm_lib_niveau= tm_modes_TFM[vl_index].nom_niveau
	vl_couleur=tm_modes_TFM[vl_index].couleur
} ELSE {
	vm_lib_niveau=	"?"
}
DB_CTRL_TITLE@(va_fenetre, "LI_Mode1", vl_mode1)
DB_CTRL_TITLE@(va_fenetre, "LI_Mode2", vl_mode2)


/*B Determination des zones de diffusion */
/* si les consignes pour le niveau l'indiquent (niveau > 1) alors affichage toutes zones */
IF (va_niveau > 1)
{
	DB_CTRL_TITLE@(va_fenetre, "LI_Zone1", "Z1")
	DB_CTRL_TITLE@(va_fenetre, "LI_Zone2", "Z2")
} ELSE {
	/*B Calcul des zones de diffusion */
	vl_indice=0
	FOR i = 0 TO ARRAY_SIZE@(tm_zones_TFM)-1
		/*B si la zone n'a pas deja ete prise en compte alors */
		IF (ARRAY_INDEX@ (tl_zones, tm_zones_TFM[i].nom) < 0) {
			j = 0
			WHILE j < ARRAY_SIZE@(tl_trc)
				IF (ARRAY_INDEX@(tm_zones_TFM[i],tl_trc[j,0]) >= 0)
				    AND (TMA_Sens_Compatible_Avec (tl_trc[j,1], tm_zones_TFM[i].sens))
				{
					tl_zones[vl_indice]=tm_zones_TFM[i].nom
					vl_indice=vl_indice+1
					j = ARRAY_SIZE@(tl_trc)
				}
				j = j + 1
			WEND
		}
	NEXT i

	DB_CTRL_TITLE@(va_fenetre, "LI_Zone1", "")
	DB_CTRL_TITLE@(va_fenetre, "LI_Zone2", "")
	IF ( ARRAY_SIZE@ (tl_zones) > 0 ) {
		DB_CTRL_TITLE@(va_fenetre, "LI_Zone1", tl_zones[0])
		vl_zone2 = ARRAY_TO_STRING@ (ARRAY_DELETE@ (tl_zones, 0), "  ")
		DB_CTRL_TITLE@(va_fenetre, "LI_Zone2", vl_zone2)
	}
} /* fin si niveau > 1 */


/*B Calcul des periodes de diffusions */
TMA_Periodes_Diffusion (va_niveau, ARRAY_COLUMN@(tl_trc, 0), vl_periodeT, vl_periodeTA)
IF (IS_NUMBER@ (vl_periodeT)) {
	IF ( vl_periodeT = TMA_MAX_PERIODE ) {
		vl_periodeT = " "
	} ELSE {
		vl_periodeT = vl_periodeT ++ " mn"
	}
}
IF (IS_NUMBER@ (vl_periodeTA)) {
	IF ( vl_periodeTA = TMA_MAX_PERIODE ) {
		vl_periodeTA = " "
	} ELSE {
		vl_periodeTA = vl_periodeTA ++ " mn"
	}
}

vm_periodes = FORMAT@ ("( T = %s; T-TA = %s )", vl_periodeT, vl_periodeTA)
DB_CTRL_TITLE@ (va_fenetre, "LI_Niveau", vm_lib_niveau ++ "     " ++ vm_periodes)


/*B Mise en couleur */
TMA_Couleur_Consignes( va_fenetre , vl_couleur )

RETURN (COM_OK)

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Calcule les periodes de diffusion d'un message
*  en fonction de son niveau et des troncons qu'il concerne.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO TMA_Periodes_Diffusion (va_niveau, ta_troncons, va_periode_t, va_periode_ta)

/*
* ARGUMENTS EN ENTREE :
*   va_niveau         : niveau du message;
*   ta_troncons       : liste des troncons impactes.
*
*
* ARGUMENTS EN SORTIE : 
*   va_periode_t      : Premiere periode calculee ;
*   va_periode_ta     : Deuxieme periode calculee.
*
*
* CODE RETOUR         : Indefini
*
* CONDITION D'UTILISATION
*   TMA_Calcul_Consignes
*
* FONCTION
*
---------------------------------------------------------------------------- */

VAR	vl_i_trc, vl_j_niveauT, vl_j_niveauTA, i
VAR	vl_valeur
VAR	vl_arret_T, vl_arret_TA

/* Initialiser les periodes avec leur valeur par defaut */
va_periode_t=TMA_MAX_PERIODE
va_periode_ta=TMA_MAX_PERIODE

/* Colonnes correspondant au niveau dans les fichiers de configuratoin */
vl_j_niveauT = ARRAY_INDEX@(tm_periodes_diff[0], va_niveau)
vl_j_niveauTA = ARRAY_INDEX@(tm_periodes_diff_TA[0], va_niveau)

/* Determiner la plus petite valeur de chaque periode pour l'ensemble des troncons */
vl_arret_T=FALSE
vl_arret_TA=FALSE
FOR i = 0 TO ARRAY_SIZE@(ta_troncons) -1
	IF vl_arret_T=FALSE
	{
		vl_i_trc = COM45_IndexEnColonne (tm_periodes_diff, TMA_PER_TRC, ta_troncons[i])
		IF ( vl_i_trc <> -1 )
		{
			vl_valeur=tm_periodes_diff[vl_i_trc,vl_j_niveauT]
			IF ( IS_NUMERIC_STRING@(vl_valeur) )
			{
				vl_valeur=vl_valeur+0
				IF ( vl_valeur < va_periode_t )
					va_periode_t=vl_valeur
			}
			ELSE
			{
				va_periode_t=vl_valeur
				vl_arret_T=TRUE
			}
		}
	}

	IF vl_arret_TA=FALSE
	{
		vl_i_trc = COM45_IndexEnColonne (tm_periodes_diff_TA, TMA_PER_TRC, ta_troncons[i])
		IF ( vl_i_trc <> -1 )
		{
			vl_valeur=tm_periodes_diff_TA[vl_i_trc,vl_j_niveauTA]
			IF ( IS_NUMERIC_STRING@(vl_valeur) )
			{
				vl_valeur=vl_valeur+0
				IF ( vl_valeur < va_periode_ta )
					va_periode_ta=vl_valeur
			}
			ELSE
			{
				va_periode_ta=vl_valeur
				vl_arret_TA=TRUE
			}
		}
	}
NEXT i

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Efface les valeurs des consignes affichees.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO TMA_Effacer_Consignes (va_fenetre)

/*
* ARGUMENTS EN ENTREE :
*   va_fenetre        : Id. de la fenetre ;
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : Indefini
*
* CONDITION D'UTILISATION
*   Toute macro du module MTMA.
*
* FONCTION
*
---------------------------------------------------------------------------- */

DB_CTRL_TITLE@ (va_fenetre, "LI_Niveau", "")
DB_CTRL_TITLE@ (va_fenetre, "LI_T", "")

DB_CTRL_TITLE@ (va_fenetre, "LI_Mode1", "")
DB_CTRL_TITLE@ (va_fenetre, "LI_Mode2", "")

DB_CTRL_TITLE@ (va_fenetre, "LI_Zone1", "")
DB_CTRL_TITLE@ (va_fenetre, "LI_Zone2", "")

/* Restaurer la couleur par defaut des consignes */
TMA_Couleur_Consignes (va_fenetre, "noir")

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Change la couleur des consignes pour l'animateur.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO TMA_Couleur_Consignes (va_fenetre, va_couleur)

/*
* ARGUMENTS EN ENTREE :
*   va_fenetre        : Id. de la fenetre ;
*   va_couleur        : nom de la couleur.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : Indefini
*
* CONDITION D'UTILISATION
*   Toute macro du module MTMA.
*
* FONCTION
*
---------------------------------------------------------------------------- */

DEFINE	TMA_SPACE_RGB	1		' car WCSPACE#RGB non trouve dans les .am Applix

VAR	tl_couleur, vl_couleur, vl_index


/*A Rechercher la couleur par son nom */
vl_index = COM45_IndexEnColonne (tm_couleurs, TMA_NOM_COUL, va_couleur)

/*A Si la couleur demandee est inconnue alors par defaut c'est noir */
IF ( vl_index < 0 ) {
	vl_index=0
}

vl_couleur = tm_couleurs[vl_index, TMA_VAL_COUL]

tl_couleur = { TMA_SPACE_RGB, vl_couleur }

DB_CTRL_LABEL_COLOR@(va_fenetre, "LI_Niveau", tl_couleur)
DB_CTRL_LABEL_COLOR@(va_fenetre, "LI_Mode1", tl_couleur)
DB_CTRL_LABEL_COLOR@(va_fenetre, "LI_Mode2", tl_couleur)
DB_CTRL_LABEL_COLOR@(va_fenetre, "LI_Zone1", tl_couleur)
DB_CTRL_LABEL_COLOR@(va_fenetre, "LI_Zone2", tl_couleur)
DB_CTRL_LABEL_COLOR@(va_fenetre, "LI_T", tl_couleur)

DB_CTRL_LABEL_COLOR@(va_fenetre, "LI_NIVEAU_MESSAGE", tl_couleur)
DB_CTRL_LABEL_COLOR@(va_fenetre, "LI_ZONES", tl_couleur)
DB_CTRL_LABEL_COLOR@(va_fenetre, "LI_Libelle_MODE", tl_couleur)

RETURN (COM_OK)

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Determine l'ensemble des troncons ORIENTES (auxquels est adjoint un sens)
*  concernes par un evenement.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION TMA_Troncons_Evenement (FORMAT TMA_Localisations_FMC ta_localisations)

/*
* ARGUMENTS EN ENTREE :
*   ta_localisations  : (liste des) localisations de l'evenement.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         :
*   Liste des troncons ou se situe l'evenement.
*
* CONDITION D'UTILISATION
*   TMA_Init_Liste_Messages	a chaque signal de modification de la liste recu ;
*   TMA_Calcul_Consignes	sur selection d'un message dans la liste.
*
* FONCTION
*
---------------------------------------------------------------------------- */

VAR	FORMAT TMA_Troncon_Oriente	tl_troncons
VAR	vl_idx_troncon, i, j

tl_troncons = { }

vl_idx_troncon = 0

/*B Pour chaque troncon Trafic FM, */
FOR i = 0  TO ARRAY_SIZE@ (tm_troncons_TFM) -1
	/*B pour chacune des localisations de l'evenement, */
	FOR j = 0  TO ARRAY_SIZE@ (ta_localisations) -1
		/*B si tout ou partie de l'evenement est situe sur le troncon */
		IF TMA_Evenement_Sur_Troncon (ta_localisations[j], tm_troncons_TFM[i])
		{
			/*B alors ajouter le couple (troncon, sens) */
			tl_troncons[vl_idx_troncon].nom = tm_troncons_TFM[i].nom
			tl_troncons[vl_idx_troncon].sens = ta_localisations[j].sens
			vl_idx_troncon = vl_idx_troncon + 1
		}
	NEXT j
NEXT i

RETURN (tl_troncons)

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Indique si un evenement est situe (en totalite ou en partie)
*  sur un troncon donne.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION TMA_Evenement_Sur_Troncon (FORMAT TMA_Localisations_FMC va_localisation,
				       FORMAT TMA_Troncon_TFM va_troncon)

/*
* ARGUMENTS EN ENTREE :
*   va_localisation   : Localisation de l'evenement ;
*   va_troncon        : Troncon concerne.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : TRUE si l'evenement est sur le troncon, FALSE sinon.
*
* CONDITION D'UTILISATION
*   TMA_Troncons_Evenement.
*
* FONCTION
*   Determine si le PR de l'une des extremites de la localisation
*    est situee dans les limites du troncon.
*
---------------------------------------------------------------------------- */

VAR	vl_evt_sur_troncon

vl_evt_sur_troncon = FALSE
COM01_Trace(COM_DEBUG1,"Localisation fmc:"++va_localisation[0]++";"++va_localisation[1]++";"++va_localisation[2]++";"++va_localisation[3])
COM01_Trace(COM_DEBUG1,"Localisation troncon :"++va_troncon[0]++";"++va_troncon[1]++";"++va_troncon[2]++";"++va_troncon[3])

IF (va_troncon.autoroute = va_localisation.autoroute) {
	IF ( (va_troncon.pr_debut <= va_localisation.pr_debut) AND
	     (va_troncon.pr_fin >= va_localisation.pr_debut) )
	OR
	   ( (va_troncon.pr_debut <= va_localisation.pr_fin) AND
	     (va_troncon.pr_fin >= va_localisation.pr_fin) )
	{
	COM01_Trace(COM_DEBUG1,"Localisation troncon :trouve")
		vl_evt_sur_troncon = TRUE
	}
}

RETURN (vl_evt_sur_troncon)

ENDFUNCTION




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Indique si le sens d'un evenement, de valeur quelconque,
*  est compatible avec un sens de circulation general (soit Nord ou Sud).
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION TMA_Sens_Compatible_Avec (va_sens, va_direction)

/*
* ARGUMENTS EN ENTREE :
*   va_sens           : Sens d'un evenement ;
*   va_direction      : Sens (direction) de reference, suppose Nord ou Sud.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : TRUE si le sens correspond a la direction, FALSE sinon.
*
* CONDITION D'UTILISATION
*   TMA_Init_Liste_Messages	a chaque signal de modification de la liste recu ;
*   TMA_Calcul_Consignes	sur selection d'un message dans la liste.
*
* FONCTION
*   Compare les valeurs des sens en tenant compte des cas particuliers
*    (2 sens, bretelles d'acces ...).
*
---------------------------------------------------------------------------- */

VAR	vl_compatible

vl_compatible = FALSE

CASE OF  va_direction
CASE XDC_SENS_SUD
	CASE OF  va_sens
	CASE XDC_SENS_SUD
	CASE XDC_SENS_SORTIE_SUD
	CASE XDC_SENS_ENTREE_SUD
	CASE XDC_SENS_INCONNU
		vl_compatible = TRUE
	ENDCASE
CASE XDC_SENS_NORD
	CASE OF  va_sens
	CASE XDC_SENS_NORD
	CASE XDC_SENS_SORTIE_NORD
	CASE XDC_SENS_ENTREE_NORD
	CASE XDC_SENS_INCONNU
		vl_compatible = TRUE
	ENDCASE
ENDCASE

RETURN (vl_compatible)

ENDFUNCTION
