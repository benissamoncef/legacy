/*E*/
/*  Fichier : $Id: ITMA_COM.am,v 1.163 2020/11/03 17:36:54 pc2dpdy Exp $        $Revision: 1.163 $        $Date: 2020/11/03 17:36:54 $
-------------------------------------------------------------------------------
* ESCOTA *  PROJET MIGRAZUR
-------------------------------------------------------------------------------
* SOUS-SYSTEME  GESIHM
-------------------------------------------------------------------------------
* MODULE ITMA_COM * FICHIER ITMA_COM.am
-------------------------------------------------------------------------------
* DESCRIPTION DU MODULE :
*
* Module de donnees et primitives communes aux modules de la tache IHM
* textuelle TITMA
*
*   Non decrit dans le DCG
*
-------------------------------------------------------------------------------
* HISTORIQUE :
*
* Lecrivain 30 Aug 1994	: Creation
* Lecrivain 14 Oct 1994	: Ajout fonction libelle zone competence          V1.22
* Lecrivain 17 Oct 1994	: Ajout fonction DATETIME_ -> j,m,a,h,m           V1.23
* Lecrivain 18 Oct 1994 : Type table des familles est {TRUE,FALSE}        V1.24
* Lecrivain 24 Oct 1994 : Ajout fonction de formatage d'un PR             V1.25
* Lecrivain 26 Oct 1994 : Ajout controles de validite de dates
* 			   et fonction de differences de dates            V1.26
* Lecrivain 07 Nov 1994 : Ajout fonction de conversion des dates
* 			 venant de la base et fonction de cryptage        V1.28
* Lecrivain 09 Nov 1994 : Ajout filtrage de NULL en entree Sybase         V1.29
* Guilhou   10 Nov 1994	: modif filtrage des NULL pour sybase,
*                          ajout fonction conversion date "eclate"        V1.30
* Lecrivain 10 Nov 1994 : Ajout fonction d'extraction des chiffres        V1.30
* Lecrivain 24 Nov 1994 : Test noms de mois sans min. accentuées          V1.35
* Lecrivain 24 Nov 1994 : Changement fonction de cryptage                 V1.36
* Lecrivain 24 Nov 1994 : Changement temporaire COM05_SQL_Procedure       V1.37
* Lecrivain 24 Nov 1994 : Retablisst fonctionnement COM05_SQL_Procedure   V1.38
* Noel 	    29 Nov 1994	: Ajout du format du Pr			          V1.39
* Lecrivain 02 Dec 1994 : Trace en entree et sortie COM05_SQL_Procedure   V1.41
* Lecrivain 02 Dec 1994 : Ajout fonction COM21_Tache_De_La_Macro          V1.44
* Lecrivain 02 Dec 1994 : Ajout fonction COM22_Fenetre_De_La_Tache        V1.45
* Lecrivain 14 Dec 1994 : Ajout COM23_Horodate, COM24_Afficher_Horodate   V1.46
* Lecrivain 15 Dec 1994 : Adaptation de COM22_Fenetre_De_La_Tache         V1.47
* Lecrivain 16 Dec 1994 : Cas localisation NULLe dans COMxx_Localisation  V1.48
* Guilhou   19 dec 1994 : modif COM10_Localisation pour une local nulle   V1.51
* Lecrivain 19 Dec 1994 : Ajout fonction COM25_Pictogramme                V1.52
* Guilhou	20 dec 1994  : numero fiche sur 4 car (COM11)		  V1.53
* Lecrivain 22 Dec 1994 : Difference de dates plus precise (minute)       V1.55
* Noel	    26 Dec 1994	: Chgt du PATH pour tracer en local		  V1.57
* Lecrivain 22 Dec 1994 : Ajout fonction COM27_Agrandir_Fenetre           V1.58
* Lecrivain 30 Dec 1994 : Modif. COM06_Date_Formatee (pour les secondes)  V1.60
* Lecrivain 02 Jan 1995 : Ajout fonction COM28_Exec_Synoptique            V1.61
* Lecrivain 11 Jan 1995 : Recreation du fichier de trace au demarrage     V1.64
* Lecrivain 15 Fev 1995 : Numero fiche sur 4 car dans tous les cas (COM11)V1.68
* Lecrivain 27 Fev 1995 : Ajout fonction COM30_Appliquer                  V1.69
* Lecrivain 27 Mar 1995 : Suppression fonction COM25_Pictogramme          V1.71
* Lecrivain 03 Avr 1995 : Changement du format d'une localisation (COM10) V1.72
* Lecrivain 07 Avr 1995 : Mise en place de la trace reelle                V1.77
* Lecrivain 24 Avr 1995 : Traces SQL uniquement si erreur ou simulation   V1.78
* Lecrivain 27 Avr 1995 : Tentative desesperee sequentialisation requetes V1.80
* Lecrivain 28 Avr 1995 : Autres tentatives de seq. requetes        V1.81, 1.82
* Lecrivain 05 Mai 1995 : Ajout de la date a la trace en fichier           1.86
* Lecrivain 24 Mai 1995 : Ajout de la fonction COM32_Format_Caracteres     1.87
* Lecrivain 07 Jun 1995 : Ajout de la fonction COM33_Aide                  1.88
* Noel      15 Jun 1995 : Ajout de la fonction COM34_Exec_Synoptique_cfg   1.89
* Torregrossa 28 Jun 1995 : Ajout de la fonction COM35_DateAffichee_En_Secondes
*                           et modif COM33_Aide (repositionner du 
*                           currentdir)                                    1.90
* Torregrossa 10 Jul 1995 : Modif libelle FMC                              1.91
* Guilhou   18 Sep 1995	: Modif COM05_SqlProcedure pour traitement erreurs 1.92
* Noel      21 Sep 1995 : Ajout de la procédure de demande d'impression    1.94
* Torregrossa 25 Oct 1995 : Modif COM05_SQL_Procedure, COM18_Date_SGBD_Formatee
*                           COM19_Date_SGBD_Eclatee pour version applix 4.1 1.95
*
* Torregrossa 27 Nov 1995 : Modif COM18_Date_SGBD_Formatee pour version applix 4.1 1.95
* Torregrossa 16 Fev 1996 : Modif COM14, COM23 et COM24 pour ajout seconde 	1.97
* Noel 	      19 Fev 1996 : Prise en compte du type d'imprimante envoyé par
*				le noyau de supervision via la tache relais (DEM 91) 	1.98
* Torregrossa 26 Mar 1996 : Correction COM14 pour ajout seconde 	1.99
* Torregrossa 07 Mai 1996 : Correction calcul pour annee en cours bissextile COM35  	1.100 (DEM 1103)
* Torregrossa 18 Jui 1996 : Impression en pcl sur imprimante couleur 1.101
* Verdier 	19 Aou 1996 : Ajout COM37 lecture des libelles predefinis V1.102
* Guilhou	20 Aou 1996 : correction COM24_Horodate pour traiter les secondes (DEM 1151) V1.103
* Guilhou	03 Sep 1996 : interface COM05_SqlProcedure pour passer autre canal de connexion (radt) V1.104
* Verdier 03 Sep 1996 : Ajout COM38_Lecture_Param
			definition de C_FORMAT_LOCALISATIOn a partir du xdc.h 
		+ Suppression message "Impression en cours" dans COM36 (DEM1028)
* Guilhou	10 Sep 1996 : modif dans COM39 (RADT) V.105
* Guilhou	24 sep 1996 : ajout COM40_Teste_Connexion_Site (V1.106)
* Torregrossa 08 Oct 1996 : Modif COM18_Date_SGBD_Formatee pour obtenir les secondes
*                           quand le format est avec AM ou PM (V1.107) 
*                           (pour correction pb de modif fmc bouchon close)
* Guilhou   	14 oct 1996 : modif COM18 pour pas reformater une date formatee (1.108)
* Torregrossa   23 oct 1996 : Ajout COM42_ConvertirPREnKm (1.109)
* Guilhou	29 nov 1996 : Modif COM05_SqlProcedure pour traitement erreurs (DEM/1289) 1.110
* Guilhou	08 dec 1996 : correction COM19_Date_Eclatee 1.111
* Torregrossa   04 Mar 1998 : Ajout COM43_SQL_CONNECT (dem/158x) (1.109)
* Torregrossa   04 Mar 1998 : Modif le cas de mode degrade COM39 (1.110)
* Torregrossa   28 Avr 1998 : Modif le cas de mode degrade COM39 (1.116) (1632)
* Niepceron     04 Jun 1998 : Ajout de COM50_DateHistorique (dem/1699) 1.117
* Niepceron     19 Oct 1998 : Correction date < 100 devient < 1000 1.118
* Niepceron     13 Jan 1999 : modif intergest dem/1723 1.119
* ESCOTA	09 avr 1999 : format du numero de fmc plus long 1.121
* Niepceron     20 dec 2005 : Correction des site de COM41 1.123
* Niepceron     13 jan 2006 : Creation COM41_SQL_Procedure_Distante_New 1.125
* Lecrivain     12 Fev 2007 : Creation COM44_ValeursEnColonne 1.126
* Lecrivain     14 Fev 2007 : COM24_Afficher_Horodate: gestion secondes ok 1.127
* Lecrivain     19 Fev 2007 : Ajout fonction COM45_IndexEnColonne 1.128
* Lecrivain     26 Fev 2007 : COM45_IndexEnColonne: distinction des valeurs NULLes 1.129
* Claudel       09 Jul 2007 : Suppression DY 1.130
* JPL		30/07/07 : COM17_Difference_Dates : prise en compte des secondes 1.131
* JMG		13/11/07: ajout COM51_NomSite
* JBL		01/12/07 : GTC renovee DEM 665
* JPL		23/06/08 : Ajout des macros COM46_LireTexte et COM47_LireTable 1.134
* JPL		09/10/08 : Ajout de la macro COM52_Exec_Differee 1.135
* JPL		05/05/09 : Formatage de dates: distinction dates saisies et Applix 1.136
* JPL		05/05/09 : COM41_SQL_Procedure_Distante identique a la version '_New' 1.137
* JPL		12/05/09 : Gestion complete des cas d'appels COM05_SQL_Procedure et connexions SGBD 1.138
* JPL		17/06/09 : Traces des appels procedures SGBD (serveur, parametres, erreurs) 1.139
* JPL		18/06/09 : Ajout COM53_Lancer_Tache; formatage de dates selon un motif 1.140
* JPL		01/07/09 : Memorisation du chemin d'acces au fichier de trace (par tache) 1.141
* JPL		06/07/09 : Gestion des barres de menu personnalisees Applix et leur id. pour l'aide 1.142
* JMG           29/09/09 : SECTO DEM 887 1.143
* JPL		19/10/09 : Traces: module appelant indique si attente fin procedure en cours 1.144
* JPL		19/07/10 : Ajout COM54_Lire_Fichier et COM55_Lire_Et_Faire 1.145
* JPL		01/10/10 : Ajout COM15_Parametres_Requete 1.146
* JPL	---->	04/10/10 : Supression COM33_Aide, surchargee par COM33_Aide_Renov  1.147
* JMG	|	22/11/10 : ajout COM54  1.148, 1.149
* JPL	L___	16/02/11 : ... oui, mais ... (punaise, 16 ans ! ...)  1.150
* JPL		10/03/11 : Ajout COM56_Valeur  1.151
* JMG		31/01/12 : portage linux 1.152
* JPL		28/11/12 : Ajout COM48_Annee, COM48_Jours, COM23_Champs_Date, COM24_Afficher_Champs_Date  1.153
* JPL		05/12/12 : Ajout COM08_Date_Validee; correction regression annee 'aa' COM06 (v 1.140)  1.154
* PCL		18/04/14 : Ajout COM50_Verifie_Recul_dates DEM1093 1.155
* JPL		07/10/14 : Ajout du sens au libelle de zone de competence COM12 (DEM 1100)  1.156
* JMG   09/03/17        : REGIONALISATION - DEM1220 1.157
* JPL		27/07/17 : Ajout de la macro COM_Index_En_Liste_Triee  1.158
* JPL		15/03/18 : Ajout predicats COM_Is_Digit_String, COM_Is_Int[eger]_String (pour DEM 1277)  1.159
* JPL		13/08/18 : Nommage, fonctions ... Identique precedente  1.160
* JPL		14/08/18 : Ajout COM17_Ecart_Dates, difference entre deux dates en secondes (pour DEM 1300)  1.161
* PNI		22/01/20 : Modif COM43 pour la connexion à SQL_HIS 1.162
* LCL   	22/04/20        : MOVIS Ajout site local pilotage DEM-SAE93
* PNI		22/04/21 : L'erreur 7211, 7210 et 7205 doit être tracé dans trace_applix et ne pas provoqué de message devant être acquitté par l'opérateur SAE-271
--------------------------------------------------------------------------- */

INCLUDE	"dbase_.am"
INCLUDE "datetim_.am"
INCLUDE "windows_.am"
INCLUDE "fileinf_.am"
INCLUDE "wp_.am"

INCLUDE	"XDMICG/inc/xdc_ax.h"
INCLUDE	"XDMICG/inc/xzic_ax.h"
INCLUDE	"XDMICG/inc/xzsa_ax.h"

INCLUDE	"GESIHM/inc/ITMA_COM.h"
INCLUDE	"GESIHM/inc/ITMA_TDO.h"
INCLUDE	"GESIHM/inc/ITMA_TAR.h"
INCLUDE	"GESIHM/inc/ITMA_TBR.h"

INCLUDE "GESIHM/inc/isyn_svu_applix_ax.h"
INCLUDE "GESIHM/inc/xzae92sp.h"
INCLUDE "GESIHM/inc/xzae108sp.h"



/*A
 * Definition et localisation des fichiers de trace
 * ------------------------------------------------
 */

DEFINE	CM_REPERTOIRE_TRACE	"/produits/migrazur/appliSD/traces/"
DEFINE	CM_FICHIER_TRACE	"trace_applix"



/*A
 * Definition des modes d'execution d'une procedure stockee
 * --------------------------------------------------------
 */

DEFINE	CM_MODE_PROC_LOCAL	0		' doit valoir NULL pour compatibilite
DEFINE	CM_MODE_PROC_DISTANT	1
DEFINE	CM_MODE_PROC_HISTO	2
DEFINE	CM_MODE_PROC_PCSIMPL	3



/*A
 * Definition des formats de messages d'erreur et de trace
 * -------------------------------------------------------
 */

DEFINE	CM_FORMAT_MSG_ERR_STANDARD	"Module %s, erreur %s - %s%s"
DEFINE	CM_FORMAT_MSG_ERR_SGBD		"Requete %s invoquee par module %s, erreur SGBD %s"
DEFINE	CM_FORMAT_MSG_ERR_PROC_SQL	"Requete %s invoquee par module %s, code retour %s"

DEFINE	CM_FMT_MSG_RQT_SQL		"%s %s sur %s invoquee par %s"
DEFINE	CM_FMT_PRC_ARG_IN		"  ==> Type %3s: %s"
DEFINE	CM_FMT_PRC_ARG_OUT		"  <== Type %3s: %s"



/*A
 * Noms des mois dans une chaine d'horodate PROVENANT DE la base
 * -------------------------------------------------------------
 */

DEFINE	CM_NOMS_MOIS	{ "jn", "fv", "mr", "ar", "mi", "ji", "xx", "xx", "sp", "ot", "nv", "dc" }

/*DEFINE  CM_NOMS_MOIS_LX  { "Jn", "Fb", "Mr", "Ar", "My", "Jn", "Jl", "Ag", "Sp", "Ot", "Nv", "Dc" }*/
DEFINE  CM_NOMS_MOIS_LX  CM_NOMS_MOIS


/*A
 * Constantes de nombres de jours pour calculs sur les dates
 * ---------------------------------------------------------
 */

DEFINE	CM_NB_JOURS		{ 31, 29, 31, 30,  31,  30,  31,  31,  30,  31,  30,  31 }
DEFINE	CM_JOURS_CUMULES	{  0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 }



DEFINE	CM_CHAINE	{ 118, 39, 121, 26, 91, 53, 74, 38, 107, 83, 58, 102 }



/*A
 * Definition du format d'un Pr
 * ----------------------------
 */

DEFINE	CM_FORMAT_PR	"%s.%3s"


/*A
 * Definition du format d'une localisation evenement
 * -------------------------------------------------
 */

/* DEFINE	CM_FORMAT_LOCALISATION	"%4s-%s-%7s" */
DEFINE       CM_FORMAT_LOCALISATION   XDC_FORMAT_LOCALISATION



/*A
 * Definition du format d'une zone de competence
 * ---------------------------------------------
 */

DEFINE	CM_FORMAT_COMPETENCE	"%4s s%1s pr %3s.%3s à %3s.%3s"



/*A
 * Definition du format d'un intitule Fiche Main Courante
 * ------------------------------------------------------
 */

DEFINE	CM_FORMAT_INTITULE_FMC	"N%s %2s %10s %s %s"



/*A
 * Libelles a afficher a l'opérateur
 * ---------------------------------
*/
DEFINE  CM_LIBELLE_IMPRESSION    "L'IMPRESSION N'A PAS PU ABOUTIR"



/*A Nom du fichier de trace */
VAR	vm_fichier_trace



/*A macro vide de meme nom pour charger le module*/
MACRO ITMA_COM
	DELAY@(0)
ENDMACRO



/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Effectue une trace de l'execution (selon le niveau indique).
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO COM01_Trace (va_niveau_msg, va_message)

/*
* ARGUMENTS EN ENTREE :
*   va_niveau_msg     : Niveau du message a tracer ;
*   va_message        : Message d'erreur a tracer.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : Indefini
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Si le niveau indique est active, effectue la trace du message indique.
*
---------------------------------------------------------------------------- */

    VAR     vl_fich_trace			' Fichier trace
    VAR     vl_message				' Msg. envoye a la tache relais
    VAR     vl_nom_niveau			' Nom du niveau de message

/* Si le niveau du message est invalide alors eviter de tracer */
IF NOT IS_NUMBER@ (va_niveau_msg) {
	RETURN
}
IF (va_niveau_msg + 0 <= 0) {
	RETURN
}

IF SYSTEM_VAR@ (vg_simuler_trace) {
	/* Definir le nom du fichier de trace si ce n'est pas fait pour cette tache */
	IF IS_NULL@ (vm_fichier_trace) {
		vm_fichier_trace = CM_REPERTOIRE_TRACE ++
		                      CM_FICHIER_TRACE ++ SYSTEM_VAR@ (vg_numero_display)
		IF NOT SYSTEM_VAR@ ("vg_fichier_trace_ok") {		' La 1ere fois
			SET_SYSTEM_VAR@ ("vg_fichier_trace_ok", TRUE)
			IF FILE_EXISTS@ (vm_fichier_trace)
				MOVE_FILE@ (vm_fichier_trace, vm_fichier_trace ++ ".old")
		}
	}

	CASE OF va_niveau_msg
		CASE COM_DEBUG1		vl_nom_niveau = "DEBUG1"
		CASE COM_DEBUG2		vl_nom_niveau = "DEBUG2"
		CASE COM_DEBUG3		vl_nom_niveau = "DEBUG3"
		CASE COM_FONCTION	vl_nom_niveau = "FONCTION"
		CASE COM_INFO		vl_nom_niveau = "INFO"
		CASE COM_MESSAGE	vl_nom_niveau = "MESSAGE"
		CASE COM_SGBD		vl_nom_niveau = "SGBD"
		CASE COM_WARNING	vl_nom_niveau = "WARNING"
		CASE COM_FATAL		vl_nom_niveau = "FATAL"
		CASE COM_INTERFACE	vl_nom_niveau = "INTERFACE"
		DEFAULT			vl_nom_niveau = "<Inconnu>"
	ENDCASE

	OPEN_ASCII_FILE@ (vm_fichier_trace, "a")
	WRITE_FILE@ (vm_fichier_trace, FORMAT@ ("%s -%s- %s",
	                                        COM09_Date_Courante(TRUE), vl_nom_niveau, va_message))
	CLOSE_FILE@ (vm_fichier_trace)
} ELSE {
	vl_message = ARRAY_TO_STRING@ ({ va_niveau_msg, va_message }, MTAR_CAR_SEPAR)
	vl_message = { MTAR_MSG_EXEC, 1, MTAR_FCT_TRACE, vl_message }
	DB_SEND_POKE@ (COM_CANAL_TAR01, vl_message)
}

ENDMACRO



/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Attache a une fenetre dont l'identifiant est fourni un fichier d'aide
*  portant le nom indique.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO COM02_Attacher_Aide (va_la_fenetre, va_nom_aide)

/*
* ARGUMENTS EN ENTREE :
*   va_la_fenetre     : Ident. de la fenetre a laquelle l'aide est attachee ;
*   va_nom_aide       : Nom du fichier contenant le texte d'aide.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* CODE RETOUR         : Indefini
*
* CONDITION D'UTILISATION
*   Toute macro gerant une boite de dialogue
*
* FONCTION
*   Attache a la fenetre indiquee le fichier d'aide indique.
*   Le nom intermediaire necessaire sera pris egal au nom du fichier.
*
---------------------------------------------------------------------------- */

DEFINE_HELPFILE@ (va_nom_aide,
		    SYSTEM_VAR@ (vg_repertoire_migrazur) ++
			COM_SOUS_REP_AIDE ++ va_nom_aide ++ COM_SUFFIXE_AIDE)
DB_HELP_TOPIC@ (va_la_fenetre, va_nom_aide)

ENDMACRO



/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Construit un message d'erreur standard contenant le nom du module ou
*  l'erreur s'est produite, le numero et le libelle de l'erreur.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM03_Message_Erreur (va_nom_module)

/*
* ARGUMENTS EN ENTREE :
*   va_nom_module     : Le nom du module ou s'est produit l'erreur.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : Le message d'erreur construit.
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Construit et retourne une chaine de caracteres representant un message
*   d'erreur de format standard pour affichage ou tracage.
*   Ce message d'erreur est constitue du nom du module indique en argument et
*   du numero et du libelle de la derniere erreur survenue, obtenus a l'aide
*   des primitives Applix.
*
---------------------------------------------------------------------------- */

    VAR     vl_objet				' Objet concerne, eventuellement


vl_objet = ERROR_OBJECT@()
IF vl_objet <> NULL				' ... ie ni NULL, ni ""
    vl_objet = vl_objet ++ " : "

RETURN (FORMAT@ (CM_FORMAT_MSG_ERR_STANDARD,
		 va_nom_module, ERROR_NUMBER@(), vl_objet, ERROR_STRING@()))

ENDMACRO



/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Determine si l'operateur a les droits d'effectuer l'action indiquee en
*  argument.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM04_Operateur_A_Le_Droit_De (va_famille)

/*
* ARGUMENTS EN ENTREE :
*   va_fonction       : L'identifiant de la famille.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : Vrai si l'operateur a les droits, faux sinon.
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Consulte la liste des autorisations associee au profil de l'operateur
*   et retourne la valeur logique associee a la famille indiquee.
*
---------------------------------------------------------------------------- */

    VAR     vl_les_droits

vl_les_droits = SYSTEM_VAR@ (vg_familles)
RETURN (vl_les_droits[va_famille])

ENDMACRO



/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Execute la procedure SQL stockee de nom indique avec les parametres fournis
*  et retourne les resultats.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM05_SQL_Procedure (va_procedure,
				 FORMAT SQL_Procedure_Params@ va_parametres,
				 FORMAT SQL_Procedure_Result@ va_resultats,
				 va_module,
				 va_mode_proc,
				 va_canal,
				 va_nom_site)

/*
* ARGUMENTS EN ENTREE :
*   va_procedure      : Le nom de la procedure SQL stockee a executer ;
*   va_parametres     : Les parametres a fournir en entree a la procedure SQL ;
*   va_module         : Le nom du module appelant ;
*   va_mode_proc      : Le mode d'execution de la procedure
*                       (site local ou distant, CI pour PC simplifie ou serveur d'historique) ;
*   va_canal          : canal de connexion au SGBD a utiliser ;
*   va_nom_site       : nom du site sur lequel la requete est executee SAUF LOCAL.
*
* ARGUMENTS EN SORTIE :
*   va_resultats      : Les resultats retournes par la procedure.
*
*
* VALEUR RETOURNEE    : COM_OK si la procedure a ete executee sans erreur ;
*                       COM_ERR_APPLIX si une erreur Applix est interceptee ;
*                       le code retourne par le SGBD en cas d'erreur.
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Filtre les valeurs NULLes dans les parametres en entree de la procedure ;
*   Execute ensuite la procedure SQL de nom indique en lui fournissant les
*   parametres specifies en argument et retourne les resultats en sortie.
*   L'execution est effectuee en utilisant le canal de connexion SGBD
*   fourni s'il y en a un, le canal standard vers le serveur local sinon ;
*
*   Si l'execution se deroule correctement, en effectue une trace et retourne
*   le compte-rendu COM_OK.
*   Traite localement et trace toute erreur Applix, SGBD ou retournee par la
*   procedure SQL stockee elle-meme ; retourne un compte-rendu d'erreur non
*   nul dans ce cas (soit COM_ERR_APPLIX, soit le code d'erreur SGBD).
*
---------------------------------------------------------------------------- */

	VAR FORMAT SQL_Procedure_Params@ vl_param_non_nuls	' Param. entree traduits

	VAR	vl_canal_SGBD
	VAR	vl_nom_site, vl_libelle_site
	VAR	vl_cr
	VAR	i,vl_mois,vl_jour,vl_annee, vl_reste

ON ERROR {
	'ERROR_BOX@ ()

	SET_SYSTEM_VAR@ (vg_requete_en_cours, FALSE)
	RETURN (COM_ERR_APPLIX)
}


/* En mode formation, executer les procedures sur le serveur d'historique */
IF (SYSTEM_VAR@ (vg_formation) <> NULL) AND (va_mode_proc = CM_MODE_PROC_LOCAL)
{
	vl_cr = COM41_SQL_Procedure_Distante (XDC_HIS,
	                                         va_procedure,
	                                         va_parametres,
	                                         va_resultats,
	                                         va_module)

	RETURN (vl_cr)
}


CASE OF va_mode_proc
	CASE CM_MODE_PROC_LOCAL
		IF (SYSTEM_VAR@ (vg_surcharge) = TRUE) {
			vl_libelle_site = SYSTEM_VAR@ (vg_site_surcharge) ++ " (surcharge)"
		} ELSE {
			vl_libelle_site = "Local"
		}
	CASE CM_MODE_PROC_DISTANT
		vl_libelle_site = va_nom_site
	CASE CM_MODE_PROC_HISTO
		vl_libelle_site = XDC_NOM_SITE_HIS
	CASE CM_MODE_PROC_PCSIMPL
		vl_libelle_site = XDC_NOM_SITE_CI
ENDCASE


/*A
 * Attendre la fin d'une eventuelle requete en cours
 * puis marquer le debut de la requete SQL courante
 * -------------------------------------------------
 */

WHILE SYSTEM_VAR@ (vg_requete_en_cours)
	COM01_Trace (COM_SGBD, FORMAT@ (CM_FMT_MSG_RQT_SQL,
	                                   "Attente fin :", va_procedure, vl_libelle_site, va_module))
	DELAY@(0.5)
WEND

SET_SYSTEM_VAR@ (vg_requete_en_cours, TRUE)


/*A
 * Traduire les valeurs NULLes en entree
 * -------------------------------------
 */

vl_param_non_nuls = va_parametres

FOR i = 0  TO ARRAY_SIZE@ (vl_param_non_nuls) - 1
	IF (vl_param_non_nuls[i].data = NULL)			' TRAITE AUSSI "" ET 0 !
	{
		CASE OF vl_param_non_nuls[i].type
		CASE SYB#CHAR_
			vl_param_non_nuls[i].data = XDC_CHAINE_VIDE
		CASE SYB#DATETIME_
			vl_param_non_nuls[i].data = XDC_DATE_NULLE
		DEFAULT						' (bit ou) entier
			vl_param_non_nuls[i].data = 0
		ENDCASE
	}
	ELSE IF (vl_param_non_nuls[i].type = SYB#DATETIME_) AND (SUBSTRING@ (vl_param_non_nuls[i].data, 5,1) = "-")
	{
		vl_param_non_nuls[i].data = COM18_Date_SGBD_Formatee(vl_param_non_nuls[i].data)
	}
/*
ELSE IF (vl_param_non_nuls[i].type = SYB#DATETIME_) AND NOT
                (GET_ENV_VAR@("RTARCH")="hp700_hpux") AND
                ( vl_param_non_nuls[i].data <> XDC_DATE_NULLE) {

                vl_mois = SUBSTRING@ (vl_param_non_nuls[i].data, 4,2)
        vl_jour = SUBSTRING@ (vl_param_non_nuls[i].data, 1,2)
        vl_annee = SUBSTRING@ (vl_param_non_nuls[i].data, 7,4)
        vl_reste= SUBSTRING@(vl_param_non_nuls[i].data, 12)
        vl_param_non_nuls[i].data=vl_annee++"/"++vl_mois++"/"++
                vl_jour ++ " " ++ vl_reste
        } */

NEXT i


/*A
 * Determiner le canal de communication vers le serveur a utiliser
 * ---------------------------------------------------------------
 */

IF (va_mode_proc = CM_MODE_PROC_LOCAL) {
	IF (SYSTEM_VAR@ (vg_surcharge) = TRUE) {
		vl_canal_SGBD = SYSTEM_VAR@ (vg_canal_SGBD_surcharge)
	} ELSE {
		vl_canal_SGBD = SYSTEM_VAR@ (vg_canal_SGBD)
	}
} ELSE {
	vl_canal_SGBD = va_canal
}


/*A
 * Executer la requete une premiere fois
 * -------------------------------------
 */

vl_cr = COM05_SQL_Procedure__1 (va_procedure,
                                   vl_param_non_nuls,
                                   va_resultats,
                                   va_module,
                                   va_mode_proc,
                                   vl_canal_SGBD,
                                   vl_libelle_site)


/*A
 * Si la connexion est en cause ou perdue alors la cloturer
 * --------------------------------------------------------
 */

IF (GET_ENV_VAR@("RTARCH")="hp700_hpux") {
IF (vl_cr = COM_QUITTE) OR (vl_cr = COM_SUPPRIME) {
	SQL_DISCONNECT@ (vl_canal_SGBD)
	vl_canal_SGBD = NULL
	COM01_trace (COM_WARNING, "COM05_SQL_Procedure: Probleme serieux SGBD, cloture connexion")

	/*A
	 * et s'il s'agit d'une situation anormale SGBD, retenter avec une nouvelle connexion
	 * ----------------------------------------------------------------------------------
	 */

	IF (vl_cr = COM_QUITTE) AND (va_mode_proc <> CM_MODE_PROC_DISTANT) {
		COM01_trace (COM_WARNING, "\t\t\t=> reprise avec une nouvelle connexion")
		CASE OF va_mode_proc
		CASE CM_MODE_PROC_LOCAL
			IF (SYSTEM_VAR@ (vg_surcharge) = TRUE) {
				vl_nom_site = SYSTEM_VAR@ (vg_nom_site_surcharge)
			} ELSE {
				vl_nom_site = SYSTEM_VAR@ (vg_nom_site)
			}
		CASE CM_MODE_PROC_HISTO
			vl_nom_site = XDC_NOM_SITE_HIS
		CASE CM_MODE_PROC_PCSIMPL
			vl_nom_site = XDC_NOM_SITE_CI
		ENDCASE

		vl_canal_SGBD = COM43_SQL_CONNECT(vl_nom_site)

		IF (vl_canal_SGBD <> NULL) {
			SQL_CHANNEL_MASTER@ (vl_canal_SGBD, 0)
			vl_cr = COM05_SQL_Procedure__1 (va_procedure,
							   vl_param_non_nuls,
							   va_resultats,
							   va_module,
							   va_mode_proc,
							   vl_canal_SGBD,
							   vl_libelle_site)
			IF (vl_cr = COM_QUITTE) OR (vl_cr = COM_SUPPRIME) {
				SQL_DISCONNECT@ (vl_canal_SGBD)
				vl_canal_SGBD = NULL
			}
		}
	}


	/* Memoriser la valeur actuelle du canal de communication */
	CASE OF va_mode_proc
	CASE CM_MODE_PROC_LOCAL
		IF (SYSTEM_VAR@ (vg_surcharge) = TRUE) {
			SET_SYSTEM_VAR@ (vg_canal_SGBD_surcharge, vl_canal_SGBD)
		} ELSE {
			SET_SYSTEM_VAR@ (vg_canal_SGBD, vl_canal_SGBD)
		}

	CASE CM_MODE_PROC_DISTANT
		NOTHING

	CASE CM_MODE_PROC_HISTO
		SET_SYSTEM_VAR@ (vg_canal_SGBD_his, vl_canal_SGBD)

	CASE CM_MODE_PROC_PCSIMPL
		SET_SYSTEM_VAR@ (vg_canal_SGBD_pcs, vl_canal_SGBD)
	ENDCASE
}
}

/*A
 * Marquer la fin de la requete SQL
 * --------------------------------
 */

SET_SYSTEM_VAR@ (vg_requete_en_cours, FALSE)


CASE OF vl_cr
CASE COM_OK
	RETURN (COM_OK)
CASE COM_ERREUR_SGBD, COM_ERREUR_PROC_SQL
	RETURN (va_resultats.status)
DEFAULT
	RETURN (COM_ERR_APPLIX)
ENDCASE

ENDFUNCTION




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Fonction interne, a ne pas utiliser depuis les autres modules.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM05_SQL_Procedure__1 (va_procedure,
				     FORMAT SQL_Procedure_Params@ va_parametres,
				     FORMAT SQL_Procedure_Result@ va_resultats,
				     va_module,
				     va_mode_proc,
				     va_canal,
				     va_libelle_site)

	VAR	vl_simul_SQL
	VAR	vl_numero_erreur
	VAR	vl_status
	VAR	vl_indice, vl_index, i, j
	VAR	vl_str,tl_tab,tl_num
	VAR	vl_trouve
	VAR	vl_degrade
	VAR	vl_channel
	VAR	vl_debut,vl_fin	

/*A
 * Mettre en place le traitement en cas d'erreur :
 * -----------------------------------------------
 */

ON ERROR {

	/*A
	 * Tracer les valeurs des parametres
	 * ---------------------------------
	 */

	COM01_Trace (COM_SGBD, FORMAT@ (CM_FMT_MSG_RQT_SQL,
	                                   "Erreur", va_procedure, va_libelle_site, va_module))
	j = 0
	FOR i = 0  TO ARRAY_SIZE@ (va_parametres) - 1
		IF (va_parametres[i].output = TRUE) {
			COM01_Trace (COM_SGBD, FORMAT@ (CM_FMT_PRC_ARG_OUT,
			                                   va_parametres[i].type,
			                                   va_resultats.return_parameters[j]))
			j = j + 1
		} ELSE {
			COM01_Trace (COM_SGBD, FORMAT@ (CM_FMT_PRC_ARG_IN,
			                                   va_parametres[i].type,
			                                   va_parametres[i].data))
		}
	NEXT i

    vl_numero_erreur = ERROR_NUMBER@()
    IF vl_numero_erreur = COM_ERREUR_SGBD {
	ERROR_BOX@
	COM01_Trace (COM_SGBD,
	                FORMAT@ (CM_FORMAT_MSG_ERR_SGBD, va_procedure, va_module, va_resultats.status))
	vl_status = vl_numero_erreur
    } ELSE IF vl_numero_erreur = COM_ERREUR_PROC_SQL {
	ERROR_BOX@
	COM01_Trace (COM_SGBD,
	                FORMAT@ (CM_FORMAT_MSG_ERR_PROC_SQL, va_procedure, va_module, va_resultats.status))
	vl_status = vl_numero_erreur
    } ELSE {
	/*B
	 * Il s'agit d'une erreur Applix levee par SQL_PROCEDURE@,
	 * pouvant propager elle-meme une erreur levee par le SGBD
	 * -------------------------------------------------------
	 */

	COM01_Trace (COM_SGBD, COM03_Message_Erreur ("SGBD/" ++ va_module))

	/*decodage du message d'erreur*/
	vl_str=ERROR_STRING@()
	tl_tab=ARRAY_FROM_STRING@(vl_str,"=")
	vl_index=0
	vl_trouve=FALSE
	vl_degrade=FALSE
	vl_channel=FALSE

	IF (vl_str=TRIM@("Rupture de pipe")) {
		vl_trouve=TRUE
	} ELSE IF (TRIM@(SUBSTRING@(vl_str,1,12))="Too many SQL") {
		vl_trouve=TRUE
	} ELSE IF (STRING_INDEX@(vl_str, "DBPROCESS")<>0) {
		vl_trouve=FALSE
		vl_degrade=TRUE
	}
	ELSE {
	    /*si le message d'erreur contient un "=" */
	    IF (IS_ARRAY@(tl_tab)) {
		FOR vl_indice=0 TO (ARRAY_SIZE@(tl_tab)-1)
			vl_str=tl_tab[vl_indice]

			/*si la chaine apres le = est un nombre de 4 chiffres*/
			IF (IS_NUMERIC_STRING@(SUBSTRING@(vl_str,1,4)))
			{
				/*je le mets de cote*/
				tl_num[vl_index]=SUBSTRING@(vl_str,1,4)
				vl_index=vl_index+1
			}
		NEXT vl_indice

		/*si j'ai trouve des nombres de 4 chiffres*/
		IF (vl_index<>0) 
		{
			/*je cherche le code 1205 : dead lock Sybase*/
			IF (ARRAY_INDEX@(tl_num,"1205")<>-1) {
				vl_trouve=TRUE
			/*je cherche le code 7211 :Can't open a connection to site 'SQL_HIS' because 'set up channel' message was not acknowledged.  */
			} ELSE IF (ARRAY_INDEX@(tl_num,"7211")<>-1) {
				vl_channel=TRUE
			/*je cherche le code 7210 :Can't open a connection to site 'TASRV_DP' because 'set up channel' message could not be sent. */
			} ELSE IF (ARRAY_INDEX@(tl_num,"7210")<>-1) {
				vl_channel=TRUE
			/*je cherche le code 7205 : pb de connexion avec un site*/
			} ELSE IF (ARRAY_INDEX@(tl_num,"7205")<>-1) {
				vl_degrade=TRUE
				vl_trouve=FALSE
				tl_tab=ARRAY_FROM_STRING@(vl_str,"_")
				if (IS_ARRAY@(tl_tab)) {
					vl_str=SUBSTRING@(tl_tab[1],1,2)
				} else {
					vl_trouve=TRUE
				}
			} ELSE {
				vl_trouve=FALSE
			}
		}
	    }
	}

	IF (vl_trouve = TRUE) {
		/* Probleme grave Sybase */
		vl_status = COM_QUITTE
	} ELSE IF (vl_degrade = TRUE) {
		/* Perte de communication */
		/*INFO_MESSAGE@("Plus de communication avec le site "++ va_libelle_site)*/
		COM01_Trace (COM_INFO, "Plus de communication avec le site "++ va_libelle_site)
		vl_status = COM_SUPPRIME
	} ELSE IF (vl_channel = TRUE) {
		/* Perte de channel */
		COM01_Trace (COM_INFO, "Can t open a connection to site  SQL_HIS  because  set up channel message was not acknowledged.")
		vl_status = COM_SUPPRIME
	} ELSE {
		/* Autre probleme SGBD ou d'interface avec le SGBD (par ex. "Jeton incorrect" ...) */
		ERROR_BOX@
		vl_status = COM_ERR_APPLIX
	}
    }

    RETURN (vl_status)
}


/*A
 * Executer la procedure stockee
 * -----------------------------
 */

va_resultats = NULL
IF vl_simul_SQL {
	va_resultats = ITMA_Simulation_SQL (va_procedure, va_module)
} ELSE {
	COM01_Trace (COM_SGBD, FORMAT@ (CM_FMT_MSG_RQT_SQL,
	                                   "Requete", va_procedure, va_libelle_site, va_module))
	vl_debut = CURRENT_TIME@()
	va_resultats = SQL_PROCEDURE@(va_canal, va_procedure, va_parametres)
	vl_fin = CURRENT_TIME@()
	COM01_Trace (COM_DEBUG2, FORMAT@ ("Fin %s : DUREE=%d", va_procedure, vl_fin - vl_debut))
}


/*A
 * Sur erreur SGBD lever l'erreur Applix COM_ERREUR_SGBD,
 * et sur erreur procedure stockee lever COM_ERREUR_PROC_SQL
 * ---------------------------------------------------------
 */

IF va_resultats.status < 0 {
	ERROR@ (COM_ERREUR_SGBD, COM_LIBELLE_ERREUR_SGBD)
} ELSE IF va_resultats.status = XDC_ARG_INV {
	ERROR@ (COM_ERREUR_PROC_SQL, COM_LIB_ERR_PROC_SQL_ARG_INV)
} ELSE IF va_resultats.status = XDC_PRC_INC {
	ERROR@ (COM_ERREUR_PROC_SQL, COM_LIB_ERR_PROC_SQL_PRC_INC)
} ELSE IF va_resultats.status = XDC_NOK {
	ERROR@ (COM_ERREUR_PROC_SQL, COM_LIB_ERR_PROC_SQL_NOK)
}


/*A
 * Tracer les valeurs des parametres (en entree et en retour)
 * ----------------------------------------------------------
 */

IF (vl_simul_SQL)  OR  (va_resultats.status <> 0) {
	vl_str = "Status=" ++ va_resultats.status
	COM01_Trace (COM_INTERFACE, FORMAT@ (CM_FMT_MSG_RQT_SQL,
	                                        vl_str, va_procedure, va_libelle_site, va_module))
	j = 0
	FOR i = 0  TO ARRAY_SIZE@ (va_parametres) - 1
		IF (va_parametres[i].output = TRUE) {
			COM01_Trace (COM_INTERFACE, FORMAT@ (CM_FMT_PRC_ARG_OUT,
			                                        va_parametres[i].type,
			                                        va_resultats.return_parameters[j]))
			j = j + 1
		} ELSE {
			COM01_Trace (COM_INTERFACE, FORMAT@ (CM_FMT_PRC_ARG_IN,
			                                        va_parametres[i].type,
			                                        va_parametres[i].data))
		}
	NEXT i
}

RETURN (COM_OK)

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Construit et retourne une chaine de caracteres representant une horodate
*  dans un format valide pour affichage ou interface avec le SGBD.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM06_Date_Formatee (va_jour, va_mois, va_annee, va_heure, va_minute, va_secondes)

/*
* ARGUMENTS EN ENTREE :
*   va_jour           : jour,
*   va_mois           : mois,
*   va_annee          : annee,
*   va_heure          : heure,
*   va_minute         : minute et
*   va_secondes       : secondes constituant l'horodate (chaines de CHIFFRES).
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : La chaine construite, de la forme "jj/mm/aaaa hh:mm".
*
* CONDITION D'UTILISATION
*   Toute macro.
*   Les valeurs en entree sont supposees etre des NOMBRES NON NEGATIFS.
*
* FONCTION
*   Construit et retourne une chaine de caracteres representant une horodate
*   dans un format fixe, accepte par le SGBD, a partir des valeurs indiquees
*   en arguments.
*
*   * Les chaines d'heure et minute en entree peuvent etre vides, auquel cas
*     les valeurs sont prises egales a "00".
*   * Si la valeur des secondes n'est pas fournie elle n'est pas concatenee.
*
---------------------------------------------------------------------------- */

    VAR     tl_nb_jours					' Table nb jours / mois
    VAR     vl_annee
    VAR     FORMAT datetime_ vl_date

tl_nb_jours = CM_NB_JOURS

IF va_annee = NULL
    RETURN (NULL)

IF va_annee < 100 {
    ' Considerer que ce peut etre une date saisie abregee OU la date courante lue par Applix
    IF va_annee < 90 {
	' On suppose que c'est une date saisie abregee
	vl_annee = 2000 + va_annee
    } ELSE {
	' Cela peut etre la date courante lue par Applix; valable aussi pour une date saisie
	vl_annee = 1900 + va_annee
    }
} ELSE IF va_annee < 1000 {
    ' On suppose que c'est la date courante lue par Applix
    vl_annee = 1900 + va_annee
} ELSE {
    vl_annee = va_annee
}

IF (va_mois < 1)  OR  (va_mois > 12) {
    RETURN (NULL)
}

IF (va_jour < 1)  OR  (va_jour > tl_nb_jours[va_mois - 1])  OR
      (va_heure > 23)  OR  (va_minute > 59)
{
    RETURN (NULL)
}

IF (va_jour = 29)  AND  (va_mois + 0 = 2) {			' Controle du 29 Fevrier
    IF NOT COM13_Annee_Bissextile (vl_annee)
	RETURN (NULL)
}

vl_date.year	= vl_annee

vl_date.month	= va_mois
vl_date.day	= va_jour
vl_date.hour	= va_heure
vl_date.minute	= va_minute
vl_date.second	= va_secondes

IF NOT IS_NULL@ (va_secondes) {
	RETURN (DATETIME_TO_STRING@ (vl_date, "dd/mm/yyyy hh:mi:ss"))
} ELSE {
	RETURN (DATETIME_TO_STRING@ (vl_date, "dd/mm/yyyy hh:mi"))
}

ENDFUNCTION




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Traduit un texte au format affichable par l'IHM textuelle Applix en une
*  liste de chaines archivable par le SGBD.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM07_Texte_SGBD (va_texte)

/*
* ARGUMENTS EN ENTREE :
*   va_texte          : Le texte a traduire.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : La liste de chaines archivable par le SGBD.
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Concatene ou decoupe les lignes du texte de maniere a former des troncons
*   de taille fixe (COM_LG_TXT caracteres) ou les fins de ligne sont reperees
*   par le caractere COM_SEPAR_TXT.
*   Retourne la liste de chaines ainsi obtenue.
*
---------------------------------------------------------------------------- */

    VAR     i_texte				' Indice ligne texte a traduire
    VAR     vl_ligne				' Copie de la ligne courante
    VAR     vl_lg_ligne				' Longueur de la ligne courante

    VAR     vl_texte_sgbd			' Le texte format SGBD constitue
    VAR     i_sgbd				' Indice ligne dans ce texte
    VAR     vl_lg_sgbd				' Lgr. disponible sur une ligne


i_sgbd = 0
vl_lg_sgbd = COM_LG_TXT

/*A
 * Pour chaque ligne du texte en entree
 * ------------------------------------
 */

FOR i_texte = 0  TO ARRAY_SIZE@ (va_texte) - 1

    vl_ligne = va_texte[i_texte]

    /*A
     * si ce n'est pas la derniere,
     * y ajouter la marque de fin de ligne
     * -----------------------------------
     */

    IF i_texte < ARRAY_SIZE@ (va_texte) - 1
	vl_ligne = vl_ligne ++ COM_SEPAR_TXT

    vl_lg_ligne = LEN@(vl_ligne)

    /*A
     * puis l'ajouter au texte SGBD
     * ----------------------------
     */

    WHILE vl_lg_ligne > vl_lg_sgbd
	vl_texte_sgbd[i_sgbd] = vl_texte_sgbd[i_sgbd] ++
				   SUBSTRING@ (vl_ligne, 1, vl_lg_sgbd)
	i_sgbd = i_sgbd + 1
	vl_ligne = SUBSTRING@ (vl_ligne, vl_lg_sgbd + 1)
	vl_lg_ligne = vl_lg_ligne - vl_lg_sgbd
	vl_lg_sgbd = COM_LG_TXT
    WEND
    vl_texte_sgbd[i_sgbd] = vl_texte_sgbd[i_sgbd] ++ vl_ligne
    IF vl_lg_ligne = vl_lg_sgbd {
	i_sgbd = i_sgbd + 1
	vl_lg_sgbd = COM_LG_TXT
    } ELSE
	vl_lg_sgbd = vl_lg_sgbd - vl_lg_ligne
NEXT i_texte

RETURN (vl_texte_sgbd)

ENDFUNCTION




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Verifie que la chaine de caracteres fournie en argument represente
*  une date valide, et retourne la chaine de cette date formatee.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM08_Date_Validee (va_chaine_date)

/*
* ARGUMENTS EN ENTREE :
*   va_chaine_date    : Le texte de la date a verifier.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : Le texte date verifiee, de la forme "jj/mm/aaaa".
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Analyse la chaine de caracteres fournie en argument, verifiant qu'elle
*   est de la forme "j/m/a" avec des valeurs numeriques uniquement,
*   puis construit et retourne la date textuelle formatee avec ces valeurs.
*
*   Si la chaine ne represente pas une date correcte, retourne NULL.
*
---------------------------------------------------------------------------- */

	VAR	tl_champs				' les champs j / m / a
	VAR	vl_chaine, vl_car
	VAR	i

tl_champs = ARRAY_FROM_STRING@ (va_chaine_date, "/")

IF ARRAY_SIZE@ (tl_champs) <> 3
	RETURN (NULL)

vl_chaine = ARRAY_TO_STRING@ (tl_champs, "")

/* Verifier que le texte de date ne contient que des chiffres */
FOR i = LEN@ (vl_chaine) TO 1  STEP (-1)
	vl_car = SUBSTRING@ (vl_chaine, i, 1)
	IF (vl_car << "0")  OR  (vl_car >> "9")
		RETURN (NULL)
NEXT i

vl_chaine = COM06_Date_Formatee (tl_champs[0], tl_champs[1], tl_champs[2], 0,0,0)
RETURN (SUBSTRING@ (vl_chaine, 1, 10))

ENDFUNCTION




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Construit et retourne une chaine de caracteres representant l'horodate
*  courante dans un format valide pour interface avec le SGBD.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM09_Date_Courante (va_avec_secondes)

/*
* ARGUMENTS EN ENTREE :
*   va_avec_secondes  : Indicateur de demande de precision a la seconde.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : La chaine construite, de la forme "jj/mm/aaaa hh:mm[:ss]"
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Construit et retourne une chaine de caracteres representant l'horodate
*   courante dans un format fixe accepte par le SGBD.
*
*   * La valeur des secondes n'est donnee que si l'argument en entree l'exige.
*
---------------------------------------------------------------------------- */

    VAR     vl_maintenant                       ' Date et heure courantes
    'VAR     vl_date_formatee                    ' Horodate sous forme de chaine de caracteres

/*A
 * Lire la date courante et la formater
 * ------------------------------------
 */

vl_maintenant = CURRENT_TIME@ ()

/* Le formatage selon un motif n'est pas decrit dans le manuel mais ... */
IF va_avec_secondes {
	RETURN (DATE_FORMAT@ (vl_maintenant, "dd/mm/yyyy hh:mi:ss"))
} ELSE {
	RETURN (DATE_FORMAT@ (vl_maintenant, "dd/mm/yyyy hh:mi"))
}

'/* produire la date dans le format "jj.mm.aaaa HH:MM[:SS]" */
'IF va_avec_secondes {
'	vl_date_formatee = DATE_FORMAT@ (vl_maintenant, 613)
'} ELSE {
'	vl_date_formatee = DATE_FORMAT@ (vl_maintenant, 313)
'}
'
'/* Substituer les deux points en slashs */
'RETURN (SET_SUBSTRING@ (SET_SUBSTRING@ (vl_date_formatee, 3, 1, "/"), 6, 1, "/"))

ENDFUNCTION






/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Construit et retourne une chaine de caracteres representant un intitule de
*  localisation a partir des informations numeriques.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM10_Localisation (FORMAT COM_Localisation va_localisation)

/*
* ARGUMENTS EN ENTREE :
*   va_localisation   : Les informations de localisation numeriques.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : La chaine construite.
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Construit et retourne une chaine de caracteres constituee des informations
*   indiquees en arguments en traduisant les identifiants numeriques en textes
*   affichables ;
*   consulte pour cela les tables de libelles figurant dans l'environnement.
*
---------------------------------------------------------------------------- */

    VAR FORMAT TDO_Autoroute        vl_les_autoroutes	' Liste des autoroutes

    VAR     vl_auto, vl_sens, vl_PR, vl_metres_PR


/*A
 * Si l'autoroute est inconnue alors retourner un libelle vide
 * -----------------------------------------------------------
 */

IF va_localisation.NumAuto = NULL
    RETURN (NULL)

vl_les_autoroutes = SYSTEM_VAR@ (vg_toutes_les_autoroutes)
vl_auto = ARRAY_INDEX@ (ARRAY_COLUMN@ (vl_les_autoroutes, TDO_NUMERO_AUTOROUTE),
			   va_localisation.NumAuto)
IF vl_auto >= 0
    vl_auto = vl_les_autoroutes[vl_auto].nom
ELSE vl_auto = "???"


/*A
 * Le sens de circulation est pris tel quel, sauf inconnu
 * ------------------------------------------------------
 */

IF va_localisation.sens_circulation = XDC_SENS_INCONNU
    vl_sens = XDC_LIB_SENS_INCONNU
ELSE vl_sens = va_localisation.sens_circulation


IF va_localisation.PR = XDC_PR_INCONNU
    vl_PR = "Inconnu"
ELSE {
    vl_metres_PR = "00" ++ va_localisation.PR MOD 1000
    vl_metres_PR = SUBSTRING@ (vl_metres_PR, LEN@(vl_metres_PR) - 2)
    vl_PR = va_localisation.PR \ 1000 ++ "." ++ vl_metres_PR
}


RETURN (FORMAT@ (CM_FORMAT_LOCALISATION, vl_auto, vl_sens, vl_PR))

ENDFUNCTION



/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Construit et retourne une chaine de caracteres representant un intitule de
*  fiche main courante a partir des informations FMC numeriques.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM11_Libelle_FMC (FORMAT COM_Intitule_FMC va_info_FMC)

/*
* ARGUMENTS EN ENTREE :
*   va_info_FMC       : Les informations Fiche Main Courante numeriques.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : La chaine construite.
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Construit et retourne une chaine de caracteres constituee des informations
*   indiquees en arguments en traduisant les identifiants numeriques en textes
*   affichables ;
*   consulte pour cela les tables de libelles figurant dans l'environnement.
*
---------------------------------------------------------------------------- */

    VAR FORMAT TDO_Type_FMC	vl_les_types_FMC	' Liste des types FMC
    VAR FORMAT TDO_District	vl_les_districts	' Liste des districts

    VAR     vl_type
    VAR     vl_enrichisseur
	VAR vl_numero

vl_les_types_FMC = SYSTEM_VAR@ (vg_les_types_FMC)
vl_type = ARRAY_INDEX@ (ARRAY_COLUMN@ (vl_les_types_FMC, TDO_NUMERO_FMC),
			   va_info_FMC.Numtype)
IF vl_type >= 0
    vl_type = vl_les_types_FMC[vl_type].abbrev
ELSE vl_type = ""

vl_numero = "0000" ++ va_info_FMC.IdFMC.numero
vl_numero = SUBSTRING@ (vl_numero, LEN@ (vl_numero) - 3)

vl_numero=va_info_FMC.IdFMC.numero++""
RETURN (FORMAT@ (CM_FORMAT_INTITULE_FMC,
		    vl_numero,
		    va_info_FMC.IdFMC.cle,
		    vl_type,
		    COM10_Localisation (va_info_FMC.localisation),
		    va_info_FMC.date))

ENDMACRO



/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Construit et retourne une chaine de caracteres representant un intitule de
*  zone geographique de competence a partir des informations numeriques.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM12_Libelle_Zone_Competence (va_autoroute, va_PR1, va_PR2, va_sens)

/*
* ARGUMENTS EN ENTREE :
*   va_autoroute      : Numero d'autoroute de la zone de competence ;
*   va_PR1            : PR de debut de zone ;
*   va_PR2            : PR de fin de zone ;
*   va_sens           : sens de la zone.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : La chaine construite.
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Construit et retourne une chaine de caracteres constituee des informations
*   indiquees en arguments en traduisant les identifiants numeriques en textes
*   affichables ;
*   consulte pour cela les tables de libelles figurant dans l'environnement.
*
---------------------------------------------------------------------------- */

    VAR FORMAT TDO_Autoroute	vl_l_auto		' Liste des autoroutes

    VAR     vl_autoroute
    VAR     vl_metres_PR1, vl_metres_PR2


IF va_autoroute = NULL
    RETURN (NULL)

vl_l_auto = SYSTEM_VAR@ (vg_toutes_les_autoroutes)
vl_autoroute = ARRAY_INDEX@ (ARRAY_COLUMN@ (vl_l_auto, TDO_NUMERO_AUTOROUTE),
				va_autoroute)
IF vl_autoroute >= 0
    vl_autoroute = vl_l_auto[vl_autoroute].nom
ELSE vl_autoroute = ""


vl_metres_PR1 = va_PR1 MOD 1000
IF vl_metres_PR1 < 10
    vl_metres_PR1 = "00" ++ vl_metres_PR1
ELSE IF vl_metres_PR1 < 100
    vl_metres_PR1 = "0" ++ vl_metres_PR1


vl_metres_PR2 = va_PR2 MOD 1000
IF vl_metres_PR2 < 10
    vl_metres_PR2 = "00" ++ vl_metres_PR2
ELSE IF vl_metres_PR2 < 100
    vl_metres_PR2 = "0" ++ vl_metres_PR2


RETURN (FORMAT@ (CM_FORMAT_COMPETENCE,
		    vl_autoroute,
		    va_sens,
		    va_PR1 \ 1000, vl_metres_PR1,
		    va_PR2 \ 1000, vl_metres_PR2))
ENDMACRO



/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Determine si une annee est bissextile.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM13_Annee_Bissextile (va_annee)

/*
* ARGUMENTS EN ENTREE :
*   va_annee          : L'annee dont on demande la nature bissextile.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : Vrai ou faux selon que l'annee est bissextile ou non.
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Retourne vrai si l'annee est un multiple de 400 ou un multiple de 4
*   sans l'etre de 100.
*
---------------------------------------------------------------------------- */

IF va_annee MOD 4 <> 0
    RETURN (FALSE)
ELSE RETURN (va_annee MOD 100 <> 0  OR  va_annee MOD 400 = 0)

ENDFUNCTION



/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Decompose une horodate au format affiche et fourni aux procedures stockees
*  en valeurs de jour, mois, annee, heure, minute et seconde.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO COM14_Valeurs_Horodate (va_horodate,
				va_jour, va_mois, va_annee, va_heure, va_minute, va_seconde)

/*
* ARGUMENTS EN ENTREE :
*   va_horodate       : Horodate dans le format affiche.
*
*
* ARGUMENTS EN SORTIE :
*   va_jour, va_mois, va_annee, va_heure, va_minute, va_seconde : Valeurs extraites.
*
*
* VALEUR RETOURNEE    : Aucune
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Extrait de l'argument en entree (chaine de caracteres au format de dates
*   affichees) les valeurs numeriques de jour, mois, annee, heure et minute.
*
---------------------------------------------------------------------------- */

IF va_horodate = NULL {
    va_jour = NULL
    va_mois = NULL
    va_annee = NULL
    va_heure = NULL
    va_minute = NULL
    va_seconde = NULL
} ELSE {
    va_jour = SUBSTRING@ (va_horodate, 1, 2)
    va_mois = SUBSTRING@ (va_horodate, 4, 2)
    va_annee = SUBSTRING@ (va_horodate, 7, 4)
    va_heure = SUBSTRING@ (va_horodate, 12, 2)
    va_minute = SUBSTRING@ (va_horodate, 15, 2)
	IF (va_seconde) {
		IF (LEN@(va_horodate)>17)
    			va_seconde = SUBSTRING@ (va_horodate, 18, 2)
		ELSE va_seconde = NULL
	}
}

ENDMACRO



/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Formate la table des parametres d'une requete SQL avant de la
*  transmettre au SGBD pour execution.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO COM15_Parametres_Requete (FORMAT COM_Parametres_Requete ta_params)

/*
* ARGUMENTS EN ENTREE :
*   ta_params         : Table de description des parametres d'une requete.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : Table des parametres formatee pour envoi au SGBD.
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Retourne la table des parametres d'une requete SQL au format attendu
*   par le SGBD.
*   Permet de ne specifier en entree que les valeurs reelement utiles,
*   en omettant par exemple la valeur ou meme la totalite des informations
*   concernant les parametres de sortie.
*
---------------------------------------------------------------------------- */

	VAR	FORMAT SQL_Procedure_Params@	tl_parametres
	VAR	i

	FOR i = 0  TO ARRAY_SIZE@ (ta_params) - 1
		tl_parametres[i].type = ta_params[i].type
		tl_parametres[i].data = ta_params[i].valeur
		tl_parametres[i].output = ta_params[i].sortie
	NEXT i

	RETURN (tl_parametres)

ENDMACRO



/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Effectue un cryptage d'une chaine.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM16_Chaine_Cryptee (va_chaine)

/*
* ARGUMENTS EN ENTREE :
*   va_chaine         : La chaine a crypter.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : La chaine cryptee.
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Construit et retourne une chaine de caracteres representant la valeur
*   cryptee de la chaine fournie en argument.
*
---------------------------------------------------------------------------- */

    VAR     vl_liste
    VAR     vl_chaine, vl_car
    VAR     i


vl_liste = CM_CHAINE

FOR i = LEN@ (va_chaine)  TO 1  STEP -1
    vl_car = (STRING_TO_NUM@ (SUBSTRING@(va_chaine, i, 1)) XOR vl_liste[i - 1])
		AND (666 - 539)
    IF vl_car < 32
	vl_car = vl_car + 32
    vl_chaine = vl_chaine ++ NUM_TO_STRING@ (vl_car)
NEXT i

RETURN (vl_chaine)

ENDMACRO



/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Calcule la difference d1 - d2 entre deux horodates d1 et d2, en secondes.
*
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM17_Ecart_Dates (va_date1, va_date2)

/*
* VALEUR RETOURNEE    : La valeur algebrique date1 - date2, en secondes.
*
* CONDITION D'UTILISATION
*   Les valeurs en entree sont supposees representer des DATES VALIDES.
*
* FONCTION
*   Calcule la difference en jours entre les deux dates a partir de leur rang
*   respectif dans l'annee et du nombre d'années multiples de 4, de 100
*   et de 400 PRECEDANT ces deux dates.
*
---------------------------------------------------------------------------- */

    VAR     tl_cumul_jours				' Table nb jours cumules
    VAR     vl_j1, vl_m1, vl_a1				' Valeurs premiere date
    VAR     vl_j2, vl_m2, vl_a2				' Valeurs deuxieme date
    VAR     vl_h1, vl_mn1, vl_s1, vl_h2, vl_mn2, vl_s2
    VAR     vl_diff_jours

tl_cumul_jours = CM_JOURS_CUMULES

/* les secondes sont demandees : */
vl_s1 = TRUE
vl_s2 = TRUE

COM14_Valeurs_Horodate (va_date1, vl_j1, vl_m1, vl_a1, vl_h1, vl_mn1, vl_s1)
COM14_Valeurs_Horodate (va_date2, vl_j2, vl_m2, vl_a2, vl_h2, vl_mn2, vl_s2)

vl_j1 = tl_cumul_jours[vl_m1 - 1] + vl_j1		' Rang jour dans l'annee
IF vl_m1 > 2  AND  COM13_Annee_Bissextile (vl_a1)
	vl_j1 = vl_j1 + 1

vl_j2 = tl_cumul_jours[vl_m2 - 1] + vl_j2
IF vl_m2 > 2  AND  COM13_Annee_Bissextile (vl_a2)
	vl_j2 = vl_j2 + 1

vl_a1 = vl_a1 - 1					' Raisonner sur les
vl_a2 = vl_a2 - 1					' annees PRECEDENTES

vl_diff_jours = (365 * (vl_a1 - vl_a2)  +  (vl_j1 - vl_j2)
		    + (vl_a1 \ 4    - vl_a2 \ 4)
		    - (vl_a1 \ 100  - vl_a2 \ 100)
		    + (vl_a1 \ 400 - vl_a2 \ 400))

RETURN ( ( (vl_diff_jours * 1440)  +  (vl_h1 - vl_h2) * 60  +  (vl_mn1 - vl_mn2) )  * 60 +
           (vl_s1 - vl_s2) )

ENDFUNCTION



/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Calcule la difference d1 - d2 (en MINUTES) entre deux horodates d1 et d2.
*  Les secondes sont rendues en tant que PARTIE FRACTIONNAIRE de la difference.
*
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM17_Difference_Dates (va_date1, va_date2)

/*
* VALEUR RETOURNEE    : La valeur algebrique date1 - date2, en minutes.
*
* CONDITION D'UTILISATION
*   Les valeurs en entree sont supposees representer des DATES VALIDES.
*
* FONCTION
*   La valeur est le soixantieme de la difference en secondes.
*   Pour compatibilite essentiellement.
*
---------------------------------------------------------------------------- */

RETURN (COM17_Ecart_Dates (va_date1, va_date2) / 60)

ENDFUNCTION




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Formate une valeur d'horodate provenant du SGBD.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM18_Date_SGBD_Formatee (va_date_SGBD)

/*
* ARGUMENTS EN ENTREE :
*   va_date_SGBD      : L'horodate au format retourne par le SGBD.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : La chaine construite, de la forme "jj/mm/aaaa hh:mm".
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Construit et retourne une chaine de caracteres representant l'horodate
*   fournie en argument, dans le format d'affichage standard (accepte en
*   entree par le SGBD).
*
*   * La valeur des secondes n'est pas indiquee.
*
---------------------------------------------------------------------------- */

    VAR     vl_l_noms_mois			' Table des noms de mois
    VAR     vl_mois				' Numero du mois
    VAR     vl_reste				' Reste (jour, annee, heure)
    VAR     vl_jour
    VAR     vl_heure
    VAR     vl_minute
    VAR     vl_seconde
    VAR     vl_annee


/*A
 * Traiter le cas particulier d'une date NULLe
 * -------------------------------------------
 */
IF va_date_SGBD = NULL or va_date_SGBD = "1900-01-01 00:00:00"
    RETURN (NULL)

/*si la date est deja formattee*/
IF (SUBSTRING@(va_date_SGBD,3,1)="/") AND (SUBSTRING@(va_date_SGBD,6,1)="/") AND
	(SUBSTRING@(va_date_SGBD,14,1)=":")
  return (va_date_SGBD)

IF SUBSTRING@ (va_date_SGBD, 5, 1) <> "-" {
	/*A
	 * Determiner le mois et isoler le reste de l'horodate
	 * ---------------------------------------------------
	 */

	if (GET_ENV_VAR@("RTARCH")="hp700_hpux")
		vl_l_noms_mois = CM_NOMS_MOIS
	else
		vl_l_noms_mois = CM_NOMS_MOIS_LX

	IF SUBSTRING@ (va_date_SGBD, 1, 4) = "juil" {
   		vl_mois = 7
   		vl_reste = SUBSTRING@ (va_date_SGBD, 6)
	} ELSE {
    		vl_mois = SUBSTRING@ (va_date_SGBD, 1, 3)
    		vl_reste = SUBSTRING@ (va_date_SGBD, 5)

    		IF SUBSTRING@ (vl_mois, 1, 2) = "ao"
			vl_mois = 8
    		ELSE vl_mois = ARRAY_INDEX@(vl_l_noms_mois,
			SUBSTRING@ (vl_mois, 1, 1) ++ SUBSTRING@ (vl_mois, 3, 1)) + 1
	}



	/*A
 	 * Traduire l'heure en mode 24 heures
	 * ----------------------------------
	 */
	vl_heure = SUBSTRING@ (vl_reste, 9, 2) + 0

	IF SUBSTRING@ (vl_reste, 21, 1) = "P" {				' Heure PM
    		IF vl_heure < 12
			vl_heure = vl_heure + 12
	} ELSE IF vl_heure = 12
    		vl_heure = 0

	IF LEN@(vl_reste) >= 16
		RETURN (COM06_Date_Formatee (SUBSTRING@ (vl_reste, 1, 2),
				vl_mois,
				SUBSTRING@ (vl_reste, 4, 4),
				vl_heure,
				SUBSTRING@ (vl_reste, 12, 2),
				SUBSTRING@ (vl_reste, 15, 2)))
	ELSE	RETURN (COM06_Date_Formatee (SUBSTRING@ (vl_reste, 1, 2),
				vl_mois,
				SUBSTRING@ (vl_reste, 4, 4),
				vl_heure,
				SUBSTRING@ (vl_reste, 12, 2)))
}
ELSE {
	vl_mois = SUBSTRING@ (va_date_SGBD, 6,2)
	vl_jour = SUBSTRING@ (va_date_SGBD, 9,2)
	vl_annee = SUBSTRING@ (va_date_SGBD, 1,4)
	vl_heure = SUBSTRING@ (va_date_SGBD, 12,2)
	vl_minute = SUBSTRING@ (va_date_SGBD, 15,2)
	vl_seconde = SUBSTRING@ (va_date_SGBD, 18,2)
	RETURN (COM06_Date_Formatee (vl_jour,vl_mois,vl_annee,vl_heure,vl_minute,vl_seconde))
}

ENDMACRO



/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Formate une valeur d'horodate provenant du SGBD.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM19_Date_SGBD_Eclatee (va_date_SGBD)

/*
* ARGUMENTS EN ENTREE :
*   va_date_SGBD      : L'horodate au format retourne par le SGBD.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : tableau contenant jj,mm,aaaa,hh,mm
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Construit et retourne une chaine de caracteres representant l'horodate
*   fournie en argument, dans le format d'affichage des horodates avec les 
* differents champs separes
*
*
---------------------------------------------------------------------------- */

    VAR     vl_l_noms_mois			' Table des noms de mois
    VAR     vl_mois					' Numero du mois
    VAR     vl_reste				' Reste (jour, annee, heure)
    VAR     vl_heure
	VAR tl_retour					'arguments en retour

/*A
 * Traiter le cas particulier d'une date NULLe
 * -------------------------------------------
 */

IF va_date_SGBD = NULL or va_date_SGBD = "1900-01-01 00:00:00"
    RETURN (NULL)


/*A
 * Determiner le mois et isoler le reste de l'horodate
 * ---------------------------------------------------
 */
vl_l_noms_mois = CM_NOMS_MOIS

IF SUBSTRING@ (va_date_SGBD, 5, 1) <> "-" {
	IF SUBSTRING@ (va_date_SGBD, 1, 4) = "juil" {
 	   vl_mois = 7
	    vl_reste = SUBSTRING@ (va_date_SGBD, 6)
	} ELSE {
  	  vl_mois = SUBSTRING@ (va_date_SGBD, 1, 3)
	    vl_reste = SUBSTRING@ (va_date_SGBD, 5)
	    IF SUBSTRING@ (vl_mois, 1, 2) = "ao"
		vl_mois = 8
	    ELSE vl_mois = ARRAY_INDEX@(vl_l_noms_mois,
		   SUBSTRING@ (vl_mois, 1, 1) ++ SUBSTRING@ (vl_mois, 3, 1)) + 1
	}

	/*A
	 * Traduire l'heure en mode 24 heures
	 * ----------------------------------
	 */
	vl_heure = SUBSTRING@ (vl_reste, 9, 2) + 0

	IF SUBSTRING@ (vl_reste, 21, 1) = "P" {				' Heure PM
	    IF vl_heure < 12
		vl_heure = vl_heure + 12
	} ELSE IF vl_heure = 12
 	   vl_heure = 0

	tl_retour[0]=SUBSTRING@ (vl_reste, 1, 2)
	tl_retour[1]=vl_mois
	tl_retour[2]=SUBSTRING@ (vl_reste, 4, 4)
	tl_retour[3]=vl_heure
	tl_retour[4]=SUBSTRING@ (vl_reste, 12, 2)
}
ELSE {
	tl_retour[1] = SUBSTRING@ (va_date_SGBD, 6,2)
	tl_retour[0] = SUBSTRING@ (va_date_SGBD, 9,2)
	tl_retour[2] = SUBSTRING@ (va_date_SGBD, 1,4)
	tl_retour[3] = SUBSTRING@ (va_date_SGBD, 12,2)
	tl_retour[4] = SUBSTRING@ (va_date_SGBD, 15,2)
}

RETURN (tl_retour)

ENDMACRO



/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Extrait les caracteres numeriques d'une chaine.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM20_Extraire_Chiffres (va_chaine)

/*
* ARGUMENTS EN ENTREE :
*   va_chaine         : La chaine d'ou extraire les chiffres.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : La chaine des chiffres extraits de la chaine d'entree.
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Construit et retourne une chaine composee des caracteres numeriques
*   de celle fournie en argument.
*
---------------------------------------------------------------------------- */

    VAR     vl_chiffres				' La chaine resultat
    VAR     vl_car
    VAR     i


vl_chiffres = ""

FOR i = 1  TO LEN@ (va_chaine)
    vl_car = SUBSTRING@ (va_chaine, i, 1)
    IF vl_car >>= "0"  AND  vl_car <<= "9"
	vl_chiffres = vl_chiffres ++ vl_car
NEXT i

RETURN (vl_chiffres)

ENDFUNCTION



/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Determine l'identifiant de la tache correspondant a une macro.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM21_Tache_De_La_Macro (va_nom_macro)

/*
* ARGUMENTS EN ENTREE :
*   va_nom_macro      : Le nom de la macro Applix dont on demande la tache.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : L'identifiant de la tache si la macro est active,
*                       NULL sinon.
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Consulte la liste des taches actives et determine celle correspondant
*   a la macro Applix de nom indique.
*
---------------------------------------------------------------------------- */

    VAR     vl_les_taches, vl_rang_macro

vl_les_taches = TASK_LIST@ ()
vl_rang_macro = ARRAY_INDEX@ (ARRAY_COLUMN@ (vl_les_taches, 1), va_nom_macro)
IF vl_rang_macro >= 0
    RETURN (vl_les_taches[vl_rang_macro, 0])
ELSE RETURN (NULL)

ENDFUNCTION



/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Determine l'identifiant de la fenetre correspondant a une tache.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM22_Fenetre_De_La_Tache (va_id_tache)

/*
* ARGUMENTS EN ENTREE :
*   va_id_tache       : L'identifiant de la tache dont on demande la fenetre.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : L'identifiant de la fenetre si elle existe,
*                       NULL sinon.
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Consulte la liste des fenetres ouvertes et determine celle correspondant
*   a la tache Applix d'identifiant indique.
*
---------------------------------------------------------------------------- */

    VAR     FORMAT window_format@ vl_les_fenetres
    VAR     vl_rang_tache

vl_les_fenetres = LIST_OF_WINDOWS@()
vl_rang_tache = ARRAY_INDEX@ (ARRAY_COLUMN@ (vl_les_fenetres, 3), va_id_tache)
IF vl_rang_tache >= 0
    RETURN (vl_les_fenetres[vl_rang_tache].id)
ELSE RETURN (NULL)

ENDFUNCTION



/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Construit et retourne une chaine de caracteres representant une horodate
*  a partir des valeurs lues dans leur boite de saisie.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM23_Horodate (va_fenetre, va_BS_jour, va_BS_mois, va_BS_annee,
			    va_BS_heure, va_BS_minute, va_BS_seconde)

/*
* ARGUMENTS EN ENTREE :
*   va_fenetre        : Id. de la fenetre contenant les boites de saisie ;
*   va_BS_jour        : Nom des objets graphiques boites de saisie jour,
*   va_BS_mois        :   mois,
*   va_BS_annee       :   annee,
*   va_BS_heure       :   heure,
*   va_BS_minute      :   minute et
*   va_BS_seconde     :   seconde constituant l'horodate.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : La chaine construite, de la forme "jj/mm/aaaa hh:mm".
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Lit dans la fenetre indiquee en argument les valeurs d'horodate saisies
*   dans les boites de saisie dont les noms sont indiques (ou prend une valeur
*   par defaut si le nom de l'objet graphique est NULL).
*   Construit et retourne une chaine de caracteres representant l'horodate
*   dans un format fixe, accepte par le SGBD, a partir des valeurs saisies.
*
*   Produit une exception COM_ERR_DATE_INVAL en cas d'invalidite de la date.
*
*   * Si les valeurs saisies sont toutes NULLes retourne NULL (date NULLe).
*   * Si les valeurs de date sont NULLes retourne "01/01/1900" pour date.
*   * Si les valeurs d'heure et minute sont NULLes, retourne "00:00" pour heure.
*   * La valeur des secondes est traitee uniquement si c'est demandé.
*
---------------------------------------------------------------------------- */

    VAR     vl_l_nb_jours				' Table nb jours / mois
    VAR     vl_jour, vl_mois, vl_annee, vl_heure, vl_minute, vl_seconde
    VAR     FORMAT datetime_ vl_date

/*A
 * Si des noms d'objets graphiques sont fournis, lire leur valeur
 * --------------------------------------------------------------
 */

IF va_BS_jour <> NULL
    vl_jour = DB_CTRL_GET_VALUE@ (va_fenetre, va_BS_jour)

IF va_BS_mois <> NULL
    vl_mois = DB_CTRL_GET_VALUE@ (va_fenetre, va_BS_mois)

IF va_BS_annee <> NULL
    vl_annee = DB_CTRL_GET_VALUE@ (va_fenetre, va_BS_annee)

IF va_BS_heure <> NULL
    vl_heure = DB_CTRL_GET_VALUE@ (va_fenetre, va_BS_heure)

IF va_BS_minute <> NULL
    vl_minute = DB_CTRL_GET_VALUE@ (va_fenetre, va_BS_minute)

IF va_BS_seconde <> NULL {
    vl_seconde = DB_CTRL_GET_VALUE@ (va_fenetre, va_BS_seconde)
} ELSE {
    vl_seconde = 0
}

/*A
 * puis effectuer les controles de validite et formater l'horodate
 * ---------------------------------------------------------------
 */

IF vl_jour = NULL  AND  vl_mois = NULL  AND  vl_annee = NULL  AND
   vl_heure = NULL  AND  vl_minute = NULL
    RETURN (NULL)

IF vl_heure > 23 {
    DB_CURSOR_IN_ENTRY@ (va_fenetre, va_BS_heure, TRUE)
    ERROR@ (COM_ERR_DATE_INVAL, COM_LIB_DATE_INVAL)
}

IF vl_minute > 59 {
    DB_CURSOR_IN_ENTRY@ (va_fenetre, va_BS_minute, TRUE)
    ERROR@ (COM_ERR_DATE_INVAL, COM_LIB_DATE_INVAL)
}

IF vl_seconde > 59 {
    DB_CURSOR_IN_ENTRY@ (va_fenetre, va_BS_seconde, TRUE)
    ERROR@ (COM_ERR_DATE_INVAL, COM_LIB_DATE_INVAL)
}

IF vl_jour = NULL  AND  vl_mois = NULL  AND  vl_annee = NULL {
    vl_jour = 1
    vl_mois = 1
    vl_annee = 1900
} ELSE {
    IF vl_annee = NULL {
	DB_CURSOR_IN_ENTRY@ (va_fenetre, va_BS_annee, TRUE)
	ERROR@ (COM_ERR_DATE_INVAL, COM_LIB_DATE_INVAL)
    }

    IF vl_mois = NULL  OR  vl_mois < 1  OR  vl_mois > 12 {
	DB_CURSOR_IN_ENTRY@ (va_fenetre, va_BS_mois, TRUE)
	ERROR@ (COM_ERR_DATE_INVAL, COM_LIB_DATE_INVAL)
    }

    vl_l_nb_jours = CM_NB_JOURS
    IF vl_jour < 1  OR  vl_jour > vl_l_nb_jours[vl_mois - 1] {
	DB_CURSOR_IN_ENTRY@ (va_fenetre, va_BS_jour, TRUE)
	ERROR@ (COM_ERR_DATE_INVAL, COM_LIB_DATE_INVAL)
    }

    IF vl_annee < 100 {						' Annee abregee
	IF vl_annee < 90 {
	    vl_annee = 2000 + vl_annee
	} ELSE {
	    vl_annee = 1900 + vl_annee
	}
    }

    IF (vl_jour = 29)  AND  (vl_mois + 0 = 2) {			'Test 29 Fevrier
	IF NOT COM13_Annee_Bissextile (vl_annee) {
	    DB_CURSOR_IN_ENTRY@ (va_fenetre, va_BS_jour, TRUE)
	    ERROR@ (COM_ERR_DATE_INVAL, COM_LIB_DATE_INVAL)
	}
    }
}

vl_date.year	= vl_annee
vl_date.month	= vl_mois
vl_date.day	= vl_jour
vl_date.hour	= vl_heure
vl_date.minute	= vl_minute
vl_date.second	= vl_seconde

IF (va_BS_seconde = NULL) {
	RETURN (DATETIME_TO_STRING@ (vl_date, "dd/mm/yyyy hh:mi"))
} ELSE {
	RETURN (DATETIME_TO_STRING@ (vl_date, "dd/mm/yyyy hh:mi:ss"))
}

ENDFUNCTION




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Retourne l'horodate saisie dans des champs specifies d'une fenetre.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO COM23_Champs_Date (FORMAT datetime_ va_date, va_fenetre,
                            va_BS_jour, va_BS_mois, va_BS_annee,
                            va_BS_heure, va_BS_minute, va_BS_seconde)

/*
* ARGUMENTS EN ENTREE :
*   va_date           : Horodate saisie dans la fenetre ;
*   va_fenetre        : Id. de la fenetre contenant les objets a valuer ;
*   va_BS_jour        : 
*   va_BS_mois        : 
*   va_BS_annee       : 
*   va_BS_heure       : 
*   va_BS_minute      : 
*   va_BS_seconde     : Noms des objets graphiques de la fenetre.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : Aucune
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Lit et retourne les valeurs de l'horodate saisie
*   dans les champs de saisie indiques de la fenetre indiquee.
*   Si un champ de saisie est NULL, la valeur correspondante est NULLe.
*
---------------------------------------------------------------------------- */

va_date.year	= NULL
va_date.month	= NULL
va_date.day	= NULL
va_date.hour	= NULL
va_date.minute	= NULL
va_date.second	= NULL


/*A
** Si des noms d'objets graphiques sont fournis, lire leur valeur saisie
** ---------------------------------------------------------------------
*/

IF va_BS_jour <> NULL
	va_date.day = DB_CTRL_GET_VALUE@ (va_fenetre, va_BS_jour)

IF va_BS_mois <> NULL
	va_date.month = DB_CTRL_GET_VALUE@ (va_fenetre, va_BS_mois)

IF va_BS_annee <> NULL
	va_date.year = DB_CTRL_GET_VALUE@ (va_fenetre, va_BS_annee)

IF va_BS_heure <> NULL
	va_date.hour = DB_CTRL_GET_VALUE@ (va_fenetre, va_BS_heure)

IF va_BS_minute <> NULL
	va_date.minute = DB_CTRL_GET_VALUE@ (va_fenetre, va_BS_minute)

IF va_BS_seconde <> NULL
	va_date.second = DB_CTRL_GET_VALUE@ (va_fenetre, va_BS_seconde)

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Affiche les valeurs d'une horodate dans des champs specifies d'une fenetre.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO COM24_Afficher_Champs_Date (FORMAT datetime_ va_date, va_fenetre,
                                     va_BS_jour, va_BS_mois, va_BS_annee,
                                     va_BS_heure, va_BS_minute, va_BS_seconde)

/*
* ARGUMENTS EN ENTREE :
*   va_date           : Horodate a afficher ;
*   va_fenetre        : Id. de la fenetre contenant les objets a valuer ;
*   va_BS_jour        : 
*   va_BS_mois        : 
*   va_BS_annee       : 
*   va_BS_heure       : 
*   va_BS_minute      : 
*   va_BS_seconde     : Noms des objets graphiques de la fenetre.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : Aucune
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Affiche les valeurs de l'horodate fournie en argument
*   dans les champs de saisie indiques de la fenetre indiquee.
*   Si un champ de saisie est NULL, la valeur correspondante n'est pas affichee.
*
---------------------------------------------------------------------------- */

/*A
** Si des noms d'objets graphiques sont fournis, afficher leur valeur
** ------------------------------------------------------------------
*/

IF va_BS_jour <> NULL
	DB_CTRL_VALUE@ (va_fenetre, va_BS_jour, va_date.day)

IF va_BS_mois <> NULL
	DB_CTRL_VALUE@ (va_fenetre, va_BS_mois, va_date.month)

IF va_BS_annee <> NULL
	DB_CTRL_VALUE@ (va_fenetre, va_BS_annee, va_date.year)

IF va_BS_heure <> NULL
	DB_CTRL_VALUE@ (va_fenetre, va_BS_heure, va_date.hour)

IF va_BS_minute <> NULL
	DB_CTRL_VALUE@ (va_fenetre, va_BS_minute, va_date.minute)

IF va_BS_seconde <> NULL
	DB_CTRL_VALUE@ (va_fenetre, va_BS_seconde, va_date.second)

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Extrait les valeurs d'une horodate formatee et les affiche.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO COM24_Afficher_Horodate (va_date, va_fenetre, va_BS_jour, va_BS_mois,
				  va_BS_annee, va_BS_heure, va_BS_minute, va_BS_seconde)

/*
* ARGUMENTS EN ENTREE :
*   va_date           : Horodate a afficher ;
*   va_fenetre        : Id. de la fenetre contenant les objets a valuer ;
*   va_BS_jour        : Nom des objets graphiques boites de saisie jour,
*   va_BS_mois        :   mois,
*   va_BS_annee       :   annee,
*   va_BS_heure       :   heure et
*   va_BS_minute      :   minute a valuer.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : Aucune
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Extrait les valeurs de l'horodate fournie en argument puis les affiche
*   dans les champs de saisie indiques de la fenetre indiquee.
*   Si un champ de saisie est NULL, la valeur correspondante n'est pas affichee.
*
---------------------------------------------------------------------------- */

    VAR     vl_jour, vl_mois, vl_annee, vl_heure, vl_minute, vl_seconde

IF va_date <> NULL {
    vl_seconde = TRUE
    COM14_Valeurs_Horodate (va_date,vl_jour,vl_mois,vl_annee,vl_heure,vl_minute,vl_seconde)
}


/*A
 * Si des noms d'objets graphiques sont fournis, afficher leur valeur
 * ------------------------------------------------------------------
 */

IF va_BS_jour <> NULL
    DB_CTRL_VALUE@ (va_fenetre, va_BS_jour, vl_jour)

IF va_BS_mois <> NULL
    DB_CTRL_VALUE@ (va_fenetre, va_BS_mois, vl_mois)

IF va_BS_annee <> NULL
    DB_CTRL_VALUE@ (va_fenetre, va_BS_annee, vl_annee)

IF va_BS_heure <> NULL
    DB_CTRL_VALUE@ (va_fenetre, va_BS_heure, vl_heure)

IF va_BS_minute <> NULL
    DB_CTRL_VALUE@ (va_fenetre, va_BS_minute, vl_minute)

IF va_BS_seconde <> NULL
    DB_CTRL_VALUE@ (va_fenetre, va_BS_seconde, vl_seconde)

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Lit une valeur de PR saisie et la formate.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM26_Valeur_PR (va_fenetre, va_BS_PR)

/*
* ARGUMENTS EN ENTREE :
*   va_fenetre        : Id. de la fenetre contenant la boite de saisie ;
*   va_BS_PR          : Nom de l'objet graphique boite de saisie du PR.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : La valeur du PR formatee (entiere).
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Lit dans la fenetre indiquee en argument la valeur de PR saisie dans la
*   zone de saisie dont le nom est indique (entiere ou decimale).
*   Construit et retourne la valeur "formatee" (entiere) destinee au SGBD.
*
*   Produit une exception COM_ERR_VAL_INVAL en cas d'invalidite du PR.
*
*   * Si la valeur saisie est NULLe retourne XDC_DP_INCONNU.
*
---------------------------------------------------------------------------- */

    VAR vl_PR

vl_PR = DB_CTRL_GET_VALUE@ (va_fenetre, va_BS_PR)

IF vl_PR = ""
    RETURN (XDC_PR_INCONNU)
ELSE IF vl_PR < 1000
    RETURN ((vl_PR * 1000) \ 1)
ELSE IF vl_PR > 999999 {
    DB_CURSOR_IN_ENTRY@ (va_fenetre, va_BS_PR, FALSE)
    ERROR@ (COM_ERR_VAL_INVAL, COM_LIB_VAL_INVAL, "PR ")
} ELSE IF (vl_PR \ 1) = vl_PR
    RETURN (vl_PR \ 1)
ELSE {
    DB_CURSOR_IN_ENTRY@ (va_fenetre, va_BS_PR, FALSE)
    ERROR@ (COM_ERR_VAL_INVAL, COM_LIB_VAL_INVAL, "PR ")
}

ENDFUNCTION



/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Agrandit une fenetre a la taille indiquee.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO COM27_Agrandir_Fenetre (va_fenetre, va_largeur, va_hauteur)

/*
* ARGUMENTS EN ENTREE :
*   va_fenetre        : Identifiant de la fenetre a agrandir ;
*   va_largeur        : Nouvelle largeur de la fenetre ;
*   va_hauteur        : Nouvelle hauteur.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : Aucune
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Donne a la fenetre indiquee en argument les dimensions indiquees ;
*   Repositionne les objets contenus dans la fenetre de maniere a les centrer.
*
---------------------------------------------------------------------------- */

    VAR     vl_decalage_H, vl_decalage_V
    VAR     vl_liste, i


/*A
 * Calculer le deplacement a effectuer sur les objets
 * --------------------------------------------------
 */

vl_decalage_H = (va_largeur - DB_GET_WIDTH@ (va_fenetre)) \ 2
vl_decalage_V = (va_hauteur - DB_GET_HEIGHT@ (va_fenetre)) \ 2


/*A
 * Redimensionner la fenetre puis deplacer ses objets
 * --------------------------------------------------
 */

DB_WIDTH@ (va_fenetre, va_largeur)
DB_HEIGHT@ (va_fenetre, va_hauteur)

vl_liste = DB_GET_CTRL_NAMES@ (va_fenetre)

FOR i = 0  TO ARRAY_SIZE@ (vl_liste) - 1
    DB_CTRL_XPOS@ (va_fenetre, vl_liste[i],
		   DB_CTRL_GET_XPOS@ (va_fenetre, vl_liste[i]) + vl_decalage_H)
    DB_CTRL_YPOS@ (va_fenetre, vl_liste[i],
		   DB_CTRL_GET_YPOS@ (va_fenetre, vl_liste[i]) + vl_decalage_V)
NEXT i

ENDMACRO



/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Demande au synoptique l'execution d'une fonction.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO COM28_Exec_Synoptique (va_fonction, va_arguments)

/*
* ARGUMENTS EN ENTREE :
*   va_fonction       : Fonction a executer par le synoptique ;
*   va_arguments      : Arguments de la fonction.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : COM_OK en cas d'execution correcte, COM_NOK sinon.
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Effectue une connexion a la tache TISYN par communication RPC ;
*   Envoie ensuite une demande d'execution de la fonction indiquee avec les
*   arguments indiques, puis clot la connexion.
*
---------------------------------------------------------------------------- */

    VAR     vl_retour_fonction
    VAR     vl_statut


ITMA_TPC_init_connection ("", CM_Socket_RPC)

vl_statut = ITMA_TPC_appel_fct (va_fonction, va_arguments, vl_retour_fonction)

ITMA_TPC_fin_connection ()

IF vl_statut = XDC_OK
    RETURN (COM_OK)
ELSE RETURN (COM_NOK)

ENDMACRO



/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Execute une fonction pour chacun des objets d'une liste.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO COM30_Appliquer (va_fonction, va_objets, va_args, va_args_prec)

/*
* ARGUMENTS EN ENTREE :
*   va_fonction       : Fonction a appliquer a chacun des objets ;
*   va_objets         : Objet(s) au(x)quel(s) appliquer la fonction ;
*   va_args           : Arguments de la fonction ;
*   va_args_prec      : Autres arguments, devant PRECEDER l'objet.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : Celle retournee par la derniere instruction executee.
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Construit la liste des arguments a fournir a la fonction en fusionnant
*   les deux listes indiquees ;
*   Execute ensuite la fonction pour chacun des objets indiques.
*
---------------------------------------------------------------------------- */

    VAR     vl_objets				' Liste des objets
    VAR     vl_args				' Liste complete d'arguments
    VAR     vl_index_objet			' Rang de l'objet dans la liste
    VAR     vl_statut
    VAR     i


/*A
 * Construire la sous-liste d'arguments jusqu'a l'objet
 * ----------------------------------------------------
 */

IF IS_NULL@ (va_args_prec) {
    vl_args[0] = NULL
    vl_index_objet = 0
} ELSE IF IS_ARRAY@ (va_args_prec) {
    vl_args = va_args_prec
    vl_index_objet = ARRAY_SIZE@ (vl_args)
    vl_args[vl_index_objet] = NULL
} ELSE {
    vl_args = va_args_prec, NULL
    vl_index_objet = 1
}


/*A
 * Ajouter le reste des arguments
 * ------------------------------
 */

IF IS_ARRAY@ (va_args)
    vl_args = ARRAY_APPEND@ (vl_args, va_args)
ELSE IF NOT IS_NULL@ (va_args)
    vl_args[vl_index_objet + 1] = va_args


/*A
 * Executer enfin la fonction pour chacun des objets
 * -------------------------------------------------
 */

IF IS_ARRAY@ (va_objets)
    vl_objets = va_objets
ELSE vl_objets[0] = va_objets

FOR i = 0  TO ARRAY_SIZE@ (vl_objets) - 1
    vl_args[vl_index_objet] = vl_objets[i]
    vl_statut = !va_fonction (vl_args[0], vl_args[1], vl_args[2], vl_args[3],
				vl_args[4], vl_args[5], vl_args[6], vl_args[7])
NEXT i


RETURN (vl_statut)

ENDMACRO



/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Retourne une chaine representant la valeur en km d'un PR en metres.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM31_Libelle_PR (va_PR)

/*
* ARGUMENTS EN ENTREE :
*   va_PR             : La valeur entiere a formater.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : La chaine construite.
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Construit et retourne une chaine de caracteres representant la valeur
*   decimale en km du PR indique en argument en metres.
*
---------------------------------------------------------------------------- */

    VAR     vl_metres_PR


IF va_PR = XDC_PR_INCONNU
    RETURN (NULL)
ELSE {
    vl_metres_PR = "00" ++ va_PR MOD 1000
    vl_metres_PR = SUBSTRING@ (vl_metres_PR, LEN@(vl_metres_PR) - 2)

    RETURN (FORMAT@ (CM_FORMAT_PR, va_PR \ 1000, vl_metres_PR))
}

ENDFUNCTION



/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Formate la region selectionnee dans le document Applix Words en edition.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM32_Format_Caracteres (va_police, va_taille, va_position, va_couleur,
				   va_gras, va_italique, va_souligne, va_cesure)

/*
* ARGUMENTS EN ENTREE :
*   va_police         : Le nom de la police des caracteres ;
*   va_taille         : la taille,
*   va_position       : la position,
*   va_couleur        : la couleur des caracteres ;
*   va_gras           : vrai si les caracteres sont a mettre en gras ;
*   va_italique       : vrai si les caracteres sont a mettre en italique ;
*   va_souligne       : vrai si les caracteres sont a souligner ;
*   va_cesure         : vrai si la cesure est permise dans la region.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : Aucune.
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Formate comme indique les caracteres de la region selectionnee du document.
*
---------------------------------------------------------------------------- */

    VAR FORMAT WP_TEXT_ATTRS@ vl_attributs

vl_attributs.BOLD = va_gras
vl_attributs.ITALIC = va_italique
vl_attributs.STRIKETHRU = NULL
vl_attributs.HIDDEN = NULL
vl_attributs.CAPITALS = NULL
vl_attributs.UNDERLINE = va_souligne
vl_attributs.POSITION = va_position
vl_attributs.HYPHENATE = va_cesure
vl_attributs.COLOR = va_couleur
vl_attributs.FACE = va_police
vl_attributs.SIZE = va_taille

WP_SET_TEXT_ATTRS@ (vl_attributs)

ENDFUNCTION




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Affiche le texte d'aide associe a une boite de dialogue.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO COM33_Aide (va_fenetre)

/*
* ARGUMENTS EN ENTREE :
*   va_fenetre        : L'identifiant de la fenetre contenant le bouton d'aide.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : Aucune.
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Cette macro est destinee a etre installee dans les boites de dialogue
*   comme "fonction evenement" (callback) attachee aux boutons d'aide.
*
*   Determine le nom du module actif donc du texte d'aide a afficher
*   en fonction du nom de la boite de dialogue chargee.
*
---------------------------------------------------------------------------- */

    VAR     vl_fichier_db, vl_module

/*A
 * Determiner le nom du module
 * ---------------------------
 */

vl_fichier_db = va_fenetre[30]					' !!!!!

IF (SUBSTRING@ (vl_fichier_db, 1, 15) = "ITMA_TTU_tunnel")  OR
    (SUBSTRING@ (vl_fichier_db, 1, 18) = "ITMA_TEC_echangeur")
{
	vl_module = SUBSTRING@ (vl_fichier_db, 1, 8)
} ELSE {
	vl_module = vl_fichier_db
}

COM33_Aide_Renov (vl_module)

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Affiche le texte d'aide associe a une boite de dialogue.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO COM33_Aide_Renov (va_appelant)

/*
* ARGUMENTS EN ENTREE :
*   va_appelant        : L'identifiant de la fenetre contenant le bouton d'aide.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : Aucune.
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Determine le nom du module actif donc du texte d'aide a afficher.
*
---------------------------------------------------------------------------- */

    VAR     vl_fichier_db, vl_module, vl_nom_aide
    VAR     vl_texte_aide, vl_menu

/*A
 * Determiner le nom de la boite de dialogue et extraire le nom du module
 * ----------------------------------------------------------------------
 */

vl_fichier_db = va_appelant
vl_module = "M" ++ SUBSTRING@ (vl_fichier_db, 6)

vl_nom_aide = vl_module


/*A
 * Ouvrir une fenetre ApplixWord et charger le document
 * ----------------------------------------------------
 */

vl_texte_aide = SYSTEM_VAR@ (vg_repertoire_migrazur) ++ COM_SOUS_REP_AIDE ++
			vl_nom_aide ++ "." ++ DC#SFX
IF NOT FILE_EXISTS@ (vl_texte_aide) {
    INFO_MESSAGE@ ("L'aide n'est pas disponible pour cette fiche")
    RETURN
}

vl_menu = ITMA_TBR_Menu_Appli_Applix (TBR_MENU_WP_AID)
IF (vl_menu > 0) {
	WP_APPLICATION_DLG@ (vl_menu, FALSE)
	WP_SET_VIEW_ONLY@ (TRUE)
	WP_LOAD_FILE@ (vl_texte_aide)
}

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Demande au synoptique de configuration des plan de secours l'execution d'une fonction.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO COM34_Exec_Synoptique_cfg (va_fonction, va_arguments)

/*
* ARGUMENTS EN ENTREE :
*   va_fonction       : Fonction a executer par le synoptique ;
*   va_arguments      : Arguments de la fonction.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : COM_OK en cas d'execution correcte, COM_NOK sinon.
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Effectue une connexion a la tache TICFG par communication RPC ;
*   Envoie ensuite une demande d'execution de la fonction indiquee avec les
*   arguments indiques, puis clot la connexion.
*
---------------------------------------------------------------------------- */

    VAR     vl_retour_fonction
    VAR     vl_statut


ITMA_TPC_init_connection ("", CM_Socket_RPC_cfg)

vl_statut = ITMA_TPC_appel_fct (va_fonction, va_arguments, vl_retour_fonction)

ITMA_TPC_fin_connection ()

IF vl_statut = XDC_OK
    RETURN (COM_OK)
ELSE RETURN (COM_NOK)

ENDMACRO


/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Conversion d'une date SGBD en secondes (format applix)
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM35_DateAffichee_En_Secondes(va_Horodate)

/*
* ARGUMENTS EN ENTREE :
*   va_Horodate       : date au format affiche
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : retourne le nombre de secondes depuis 1/1/1970 (date applix).
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Recherche le nombre de jours depuis 1/1/1970  ;
*   conversion en secondes
*
---------------------------------------------------------------------------- */

VAR i
VAR vl_jour,vl_mois, vl_annee, vl_heure, vl_minute
VAR vl_nb_jours
VAR vl_secondes
VAR vl_jours_cumules

	IF IS_NULL@(va_Horodate)
		RETURN (NULL)

	COM14_Valeurs_Horodate(va_Horodate, vl_jour,vl_mois, vl_annee, 
					vl_heure, vl_minute)

	vl_jours_cumules = CM_JOURS_CUMULES

	/*A rechercher le nombre de jours depuis 1900 */
	vl_nb_jours = (vl_annee - 1970 ) * 365 + 
				vl_jours_cumules[vl_mois - 1] + vl_jour - 1

	/*A ajout un jour par annee bissextile */
	FOR i=1970 TO vl_annee - 1
		if COM13_Annee_Bissextile(i) 
			vl_nb_jours = vl_nb_jours + 1
	NEXT i
	IF vl_mois>2
	{
		if COM13_Annee_Bissextile(vl_annee) 
			vl_nb_jours = vl_nb_jours + 1		
	}

	/*A conversion en nombre de secondes */
	vl_secondes = ((vl_nb_jours * 24) + vl_heure) * 3600 + (vl_minute * 60)

	RETURN (vl_secondes)

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
* Demande d'impression d'un fichier au noyau de supervision
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM36_Imprimer_Texte(va_fichier)

/*
* ARGUMENTS EN ENTREE :
*   va_fichier  : nom du fichier à imprimer
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : Aucun
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*
* Demande d'impression d'un fichier au noyau de supervision
*
---------------------------------------------------------------------------- */
VAR vl_type_imprimante                  /* type d'imprimante */
VAR tl_args                             /* arguments de la demande d'impression */
VAR tl_cmd                              /* commande envoyee au noyau de supervision pour impression */

	/*A récupérer le type d'imprimante */
	vl_type_imprimante = SYSTEM_VAR@(vg_type_imprimante)

	/*B Demander a la tache relais l'impression du fichier*/
	IF vl_type_imprimante = XZSAC_TYPE_IMP_CL
	{
		/* Si imprimante couleur */

		/* Formater le fichier texte en PS */
		WP_PRINT@(NULL, FALSE, 1, FALSE, TRUE, 0, 0, FALSE, NULL,
			"/tmp/" ++ va_fichier ++ ".pcl",
			NULL, NULL, NULL, NULL, NULL, FALSE, COM_FORMAT_PCL)
		WP_EXIT@()

		/*A Demander l'impression du fichier */
		tl_args = va_fichier ++ ".pcl", "/tmp", XDC_IMP_PCL
		tl_cmd = MTAR_MSG_EXEC, 1, MTAR_FCT_PRINT,
			ARRAY_TO_STRING@ (tl_args, MTAR_CAR_SEPAR)
		DB_SEND_POKE@ (COM_CANAL_TAR01, tl_cmd)
/*		INFO_MESSAGE@ ("Impression en cours sur l'imprimante couleur") */
	}

	ELSE
	{

		/* Si imprimante noir et blanc */

		IF vl_type_imprimante = XZSAC_TYPE_IMP_NB
		{
			/* Formater le fichier texte en PCL */
			WP_PRINT@(NULL, FALSE, 1, FALSE, TRUE, 0, 0, FALSE, NULL,
				"/tmp/" ++ va_fichier ++ ".pcl",
				NULL, NULL, NULL, NULL, NULL, FALSE, COM_FORMAT_PCL)
			WP_EXIT@()

			/*A Demander l'impression du fichier */
        		tl_args = va_fichier ++ ".pcl", "/tmp", XDC_IMP_PCL
			tl_cmd = MTAR_MSG_EXEC, 1, MTAR_FCT_PRINT,
				ARRAY_TO_STRING@ (tl_args, MTAR_CAR_SEPAR)
			DB_SEND_POKE@ (COM_CANAL_TAR01, tl_cmd)
/*			INFO_MESSAGE@ ("Impression en cours sur l'imprimante noir et blanc") 
*/
		}
		ELSE
		{
			INFO_MESSAGE@ (CM_LIBELLE_IMPRESSION)
			COM01_Trace (COM_DEBUG2, "type d'imprimante inconnu")
		}

	}
ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
* Lit les libelles predefinis
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM37_Lit_Libelles_Predefinis(va_num_lib, ta_tout_lib, ta_lib_valide)

/*
* ARGUMENTS EN ENTREE :
*   va_num_lib : numero du type de libelles a lire
*
* ARGUMENTS EN SORTIE : 
*	ta_tout_lib	: tableau contenant tous les libelles predefinis
*	ta_lib_valide	: tableau contenant tous les libelles predefinis valides
*
* VALEUR RETOURNEE    : Aucun
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*
* lit les libelles predefinis
*
---------------------------------------------------------------------------- */
VAR FORMAT SQL_Procedure_Params@ vl_parametres
VAR FORMAT SQL_Procedure_Result@ vl_resultats
VAR tl_titres, tl_data, i, j, tl_val, tl_lib

vl_parametres[0].type = SYB#INT4_
vl_parametres[0].data = va_num_lib
vl_parametres[0].output = FALSE

IF COM05_SQL_Procedure (XZAE92_Lect_Lib_Pre,
			   vl_parametres, vl_resultats, "") <> COM_OK
    RETURN (COM_NOK)

ta_tout_lib = vl_resultats.select_results[0]
j=0
for i=0 to ARRAY_SIZE@(ta_tout_lib)-1
	IF ta_tout_lib[i][5]=1
	{
		ta_lib_valide[j]=ta_tout_lib[i]
		j=j+1
	}
next i

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
* Lit les parametres
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM38_Lecture_Param(va_nom_param)

/*
* ARGUMENTS EN ENTREE :
*   va_nom_param : nom du parametre a lire
*
* ARGUMENTS EN SORTIE : 
*	va_valeur	: valeur du parametre
*
* VALEUR RETOURNEE    : Aucun
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*
* lit les parametres
*
---------------------------------------------------------------------------- */
VAR tl_param, vl_index, tl_chaine,i

IF FILE_EXISTS@(SYSTEM_VAR@(vg_repertoire_migrazur)++"fichiers/syn/Param.txt")
	{
		tl_chaine = READ_ASCII_FILE@(SYSTEM_VAR@(vg_repertoire_migrazur)++
											"fichiers/syn/Param.txt")
	}
ELSE
	{
		return(null)
	}

FOR i=0 to ARRAY_SIZE@(tl_chaine)-1
	tl_param[i] = ARRAY_FROM_STRING@(tl_chaine[i], ";") 
NEXT i

vl_index = ARRAY_INDEX@(ARRAY_COLUMN@(tl_param,0), va_nom_param)
IF vl_index<0
	return(null)
ELSE
	return(tl_param[vl_index][1]+0)

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
* connexion au CI et appel a COM05_SQL_Procedure
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM39_SQL_Procedure_PCS (va_procedure,
				 FORMAT SQL_Procedure_Params@ va_parametres,
				 FORMAT SQL_Procedure_Result@ va_resultats,
				 va_module)

/*
 * ARGUMENTS EN ENTREE :
 *   va_procedure      : Le nom de la procedure SQL stockee a executer ;
 *   va_parametres     : Les parametres a fournir en entree a la procedure SQL ;
 *   va_module         : Le nom du module appelant.
 *
 *
 * ARGUMENTS EN SORTIE :
 *   va_resultats      : Les resultats retournes par la procedure.
 *
 *
 * VALEUR RETOURNEE    : COM_OK si la procedure a ete executee sans erreur ;
 *                       COM_ERR_APPLIX si une erreur Applix est interceptee ;
 *                       le code retourne par le SGBD en cas d'erreur.
---------------------------------------------------------------------------- */
VAR vl_canal
VAR vl_ret

ON ERROR {
ERROR_BOX@()
      return (COM_NOK)
    }

    if (SYSTEM_VAR@(vg_comm_CI)<>XDC_OK) AND (SYSTEM_VAR@(vg_site) <> XDC_CI) {
      INFO_MESSAGE@(C_LIB_PERTE_CI)
      return (COM_NOK)
    }

    /*on se connecte a la base du CI */
  if (SYSTEM_VAR@(vg_canal_SGBD_pcs)=null) {
      vl_canal = COM43_SQL_CONNECT(XDC_NOM_SITE_CI)
	if NOT IS_NULL@ (vl_canal)
	{
    		SQL_CHANNEL_MASTER@ (vl_canal, 0)
		SET_SYSTEM_VAR@(vg_canal_SGBD_pcs,vl_canal)
    	}
    }

    vl_canal=SYSTEM_VAR@(vg_canal_SGBD_pcs)
   if NOT IS_NULL@ (vl_canal)
    	vl_ret=COM05_SQL_Procedure(va_procedure,
		va_parametres,
		va_resultats,
		va_module,
		CM_MODE_PROC_PCSIMPL,
		vl_canal,
		XDC_NOM_SITE_CI)
   else vl_ret=COM_NOK

    return (vl_ret)
ENDFUNCTION




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
* teste la connexion avec un site donne via sql_server
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM40_Teste_Connexion_Site (va_site)

/*
 * ARGUMENTS EN ENTREE :
 *
 * ARGUMENTS EN SORTIE :
 *
 * VALEUR RETOURNEE    : COM_OK si la connexion est bonne ;
 *                       COM_NOK sinon ;
--------------------------------------------------------------------------- */
VAR FORMAT SQL_Procedure_Params@ vl_parametres
VAR FORMAT SQL_Procedure_Result@ vl_resultats
VAR vl_site

CASE OF va_site
	CASE XDC_CI
		vl_site = XDC_NOM_SITE_CI

	CASE XDC_DN
		vl_site = XDC_NOM_SITE_DN

	CASE XDC_VC
		vl_site = XDC_NOM_SITE_VC

	CASE XDC_VE
		vl_site = XDC_NOM_SITE_VE

	CASE XDC_DP
		vl_site = XDC_NOM_SITE_DP

	CASE XDC_DA
		vl_site = XDC_NOM_SITE_DA

	CASE XDC_VD
		vl_site = XDC_NOM_SITE_VD

	CASE XDC_HIS
		vl_site = XDC_NOM_SITE_HIS
ENDCASE

	RETURN (SYSTEM_VAR@(vg_comm_++vl_site))


	/*teste la connexion avec le site*/
	vl_parametres[0].data = va_site
	vl_parametres[0].type = SYB#INT4_
	vl_parametres[0].output = FALSE

	vl_parametres[1].type = SYB#CHAR_                               ' Site local
	vl_parametres[1].data = SYSTEM_VAR@(vg_nom_site)
	vl_parametres[1].output = FALSE

	return (COM05_SQL_Procedure (XZAE108_Teste_Connexion_Site,
						   vl_parametres, vl_resultats, "ITMA_COM"))
ENDFUNCTION




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
* execute un procedure SQL sur un site distant
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM41_SQL_Procedure_Distante_New (va_site,
				va_procedure,
				 FORMAT SQL_Procedure_Params@ va_parametres,
				 FORMAT SQL_Procedure_Result@ va_resultats,
				 va_module)

/*
 * ARGUMENTS EN ENTREE :
 *   va_site	       : le numero du site ou executer la proc
 *   va_procedure      : Le nom de la procedure SQL stockee a executer ;
 *   va_parametres     : Les parametres a fournir en entree a la procedure SQL ;
 *   va_module         : Le nom du module appelant.
 *
 *
 * ARGUMENTS EN SORTIE :
 *   va_resultats      : Les resultats retournes par la procedure.
 *
 *
 * VALEUR RETOURNEE    : COM_OK si la procedure a ete executee sans erreur ;
 *                       COM_ERR_APPLIX si une erreur Applix est interceptee ;
 *                       le code retourne par le SGBD en cas d'erreur.
---------------------------------------------------------------------------- */

VAR vl_ret

ON ERROR {
	ERROR_BOX@()
	return (COM_NOK)
}

    /*si je dois executer sur mon site*/
    if (va_site=SYSTEM_VAR@(vg_site)) {
	vl_ret=COM05_SQL_Procedure(va_procedure,
			va_parametres,
			va_resultats,
			va_module)
	return (vl_ret)
    }

    vl_ret=COM41_SQL_Procedure_Distante(va_site,
		va_procedure,
		va_parametres,
		va_resultats,
		va_module)

    return (vl_ret)
ENDFUNCTION



/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Execute une procedure SQL sur un site distant.
*  Un nouveau canal de communication est utilise a chaque appel.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM41_SQL_Procedure_Distante (va_site,
				va_procedure,
				 FORMAT SQL_Procedure_Params@ va_parametres,
				 FORMAT SQL_Procedure_Result@ va_resultats,
				 va_module)

/*
 * ARGUMENTS EN ENTREE :
 *   va_site	       : le numero du site ou executer la proc
 *   va_procedure      : Le nom de la procedure SQL stockee a executer ;
 *   va_parametres     : Les parametres a fournir en entree a la procedure SQL ;
 *   va_module         : Le nom du module appelant.
 *
 *
 * ARGUMENTS EN SORTIE :
 *   va_resultats      : Les resultats retournes par la procedure.
 *
 *
 * VALEUR RETOURNEE    : COM_OK si la procedure a ete executee sans erreur ;
 *                       COM_ERR_APPLIX si une erreur Applix est interceptee ;
 *                       le code retourne par le SGBD en cas d'erreur.
---------------------------------------------------------------------------- */
VAR vl_canal
VAR vl_ret
VAR vl_nom_site

ON ERROR {
	ERROR_BOX@()
	return (COM_NOK)
}

    /*si je dois executer sur mon site*/
    if (va_site=SYSTEM_VAR@(vg_site)) {
	vl_ret=COM05_SQL_Procedure(va_procedure,
			va_parametres,
			va_resultats,
			va_module)
	return (vl_ret)
    }

    CASE OF va_site
      	CASE XDC_CI
		vl_nom_site=XDC_NOM_SITE_CI

	CASE XDC_DN
		vl_nom_site=XDC_NOM_SITE_DN

	CASE XDC_VC
		vl_nom_site=XDC_NOM_SITE_VC

	CASE XDC_VE
		vl_nom_site=XDC_NOM_SITE_VE

	CASE XDC_DP
		vl_nom_site=XDC_NOM_SITE_DP
		
	CASE XDC_DA
		vl_nom_site=XDC_NOM_SITE_DA
		
	CASE XDC_VD
		vl_nom_site=XDC_NOM_SITE_VD
		
	CASE XDC_HIS
		vl_nom_site=XDC_NOM_SITE_HIS
    ENDCASE

    /*on se connecte a la base du site*/
      /*on verifie qu'on n'est pas en mode degrade*/
      if (COM40_Teste_Connexion_Site(va_site)<>COM_OK)
	return (COM_NOK)

      vl_canal = COM43_SQL_CONNECT(vl_nom_site)
      SQL_CHANNEL_MASTER@ (vl_canal, 0)
      

    vl_ret=COM05_SQL_Procedure(va_procedure,
		va_parametres,
		va_resultats,
		va_module,
		CM_MODE_PROC_DISTANT,
		vl_canal,
		vl_nom_site)

    SQL_DISCONNECT@(vl_canal)

    return (vl_ret)
ENDFUNCTION



/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Execute une procedure SQL sur le serveur d'historique (site "HIS")
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM41_SQL_Procedure_HIS (va_procedure,
				     FORMAT SQL_Procedure_Params@ va_parametres,
				     FORMAT SQL_Procedure_Result@ va_resultats,
				     va_module)

/*
 * ARGUMENTS EN ENTREE :
 *   va_procedure      : Le nom de la procedure SQL stockee a executer ;
 *   va_parametres     : Les parametres a fournir en entree a la procedure SQL ;
 *   va_module         : Le nom du module appelant.
 *
 *
 * ARGUMENTS EN SORTIE :
 *   va_resultats      : Les resultats retournes par la procedure.
 *
 *
 * VALEUR RETOURNEE    : COM_OK si la procedure a ete executee sans erreur ;
 *                       COM_ERR_APPLIX si une erreur Applix est interceptee ;
 *                       le code retourne par le SGBD en cas d'erreur.
---------------------------------------------------------------------------- */
VAR vl_canal
VAR vl_ret

ON ERROR {
ERROR_BOX@()
return (COM_NOK)
}

    /*on se connecte a la base du site*/
    if (SYSTEM_VAR@(vg_canal_SGBD_his)=null) {
      /*on verifie qu'on n'est pas en mode degrade*/
      if (COM40_Teste_Connexion_Site(XDC_HIS)<>COM_OK)
	return (COM_NOK)

      vl_canal = COM43_SQL_CONNECT(XDC_NOM_SITE_HIS)
      SQL_CHANNEL_MASTER@ (vl_canal, 0)
      SET_SYSTEM_VAR@(vg_canal_SGBD_his,vl_canal)
    }

    vl_canal=SYSTEM_VAR@(vg_canal_SGBD_his)
    vl_ret=COM05_SQL_Procedure(va_procedure,
		va_parametres,
		va_resultats,
		va_module,
		CM_MODE_PROC_HISTO,
		vl_canal,
		XDC_NOM_SITE_HIS)

    return (vl_ret)
ENDFUNCTION




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Formater un PR en Km
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM42_ConvertirPREnKm (va_PR)

/*
* ARGUMENTS EN ENTREE :
*   va_PR   : PR en metres
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : La chaine construite.
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*
---------------------------------------------------------------------------- */

    VAR     vl_PR, vl_metres_PR


IF va_PR = NULL
    RETURN (NULL)

    vl_metres_PR = "00" ++ va_PR MOD 1000
    vl_metres_PR = SUBSTRING@ (vl_metres_PR, LEN@(vl_metres_PR) - 2)
    vl_PR = va_PR \ 1000 ++ "." ++ vl_metres_PR


RETURN (vl_PR)

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Se connecter sur un serveur
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM43_SQL_CONNECT (va_Nom_Site)

/*
* ARGUMENTS EN ENTREE :
*   va_Nom_Site   : nom du site
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : le canal .
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*
---------------------------------------------------------------------------- */

VAR vl_canal

ON ERROR {
	INFO_MESSAGE@ ("Connexion impossible ! Perte de communication avec le site "++va_Nom_Site)
	RETURN  (NULL)
}

if (GET_ENV_VAR@("RTARCH")="hp700_hpux")
	vl_canal = SQL_CONNECT@ (COM_NOM_SGBD, COM_USER, COM_MOT_PASSE,
				 COM_BASE, COM_HOTE, COM_SERVEUR ++ va_Nom_Site)
else {
        if (va_Nom_Site <> XDC_NOM_SITE_HIS)
                vl_canal = SQL_CONNECT@ (COM_NOM_SGBD, COM_USER, COM_MOT_PASSE,
                                           COM_BASE, 
			"SD"++va_nom_site++"1", COM_SERVEUR_LX)
		'	COM_HOTE_LX ++va_Nom_Site ++"1", COM_SERVEUR_LX)
        else
               vl_canal = SQL_CONNECT@ (COM_NOM_SGBD, COM_USER, COM_MOT_PASSE,
                                              COM_BASE, 
			"SD"++va_nom_site, "SQL_HIS")
					     ' COM_HOTE_HIS_LX, COM_SERVEUR_LX)
}



RETURN (vl_canal)
ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Extrait la sous-table d'une table quelconque contenant (ou ne contenant pas)
*  l'une des valeurs d'une liste donnée dans une colonne d'indice donné.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM44_ValeursEnColonne (ta_table, va_idx_colonne, ta_valeurs, va_a_garder)

/*
* ARGUMENTS EN ENTREE :
*   ta_table          : La table dont on extrait la sous-table ;
*   va_idx_colonne    : Index de la colonne contenant les valeurs a trier ;
*   ta_valeurs        : Liste des valeurs à extraire ou à supprimer de la table ;
*   va_a_garder       : vrai/faux selon que les valeurs sont à garder ou supprimer.
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : La sous-table extraite.
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Parcourt la table d'entrée et extrait les lignes contenant ou non
*   en colonne indiquée l'une des valeurs selon l'indicateur.
*
---------------------------------------------------------------------------- */

VAR	tl_resultat
VAR	vl_rang
VAR	i, j

tl_resultat = NULL
j = 0

/*! Pour chaque ligne de la table d'entrée */
FOR i = 0 TO ARRAY_SIZE@ (ta_table) - 1
	vl_rang = ARRAY_INDEX@ (ta_valeurs, ta_table[i][va_idx_colonne])

	/*! si la valeur en colonne indiquée est dans celles à garder */
	/*! ou n'est pas dans celles à supprimer alors extraire la ligne */
	IF (va_a_garder AND vl_rang >= 0)  OR  (NOT va_a_garder AND vl_rang < 0) {
		tl_resultat[j] = ta_table[i]
		j = j + 1
	}
NEXT i

RETURN (tl_resultat)

ENDFUNCTION




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Retourne l'index de la premiere ligne d'une table quelconque contenant
*  une valeur précise dans une colonne donnée.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM45_IndexEnColonne (ta_table, va_idx_colonne, va_valeur)

/*
* ARGUMENTS EN ENTREE :
*   ta_table          : La table dans laquelle la valeur est recherchée ;
*   va_idx_colonne    : Index de la colonne où elle est recherchée ;
*   va_valeur         : Valeur recherchée.
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : L'indice de la première ligne où la valeur
*                        est trouvée, -1 si elle ne l'est pas.
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*
---------------------------------------------------------------------------- */

VAR	i

/*! Examiner chaque ligne de la table d'entrée */
FOR i = 0 TO ARRAY_SIZE@ (ta_table) - 1
	/*! pour y chercher soit la valeur NULLe  */
	IF IS_NULL@ (va_valeur) {
		IF IS_NULL@ (ta_table[i][va_idx_colonne])
			RETURN (i)
	} ELSE {
		/*! soit la valeur recherchée NON NULLe  */
		IF NOT IS_NULL@ (ta_table[i][va_idx_colonne]) AND
		     (ta_table[i][va_idx_colonne] = va_valeur)
			RETURN (i)
	}
NEXT i

RETURN (-1)

ENDFUNCTION




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Lit un fichier donné et retourne le texte qu'il contient, constitué
*  de la liste des lignes qui ne débutent pas par une marque de commentaire.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO COM46_LireTexte (va_fichier, ta_commentaires)

/*
* ARGUMENTS EN ENTREE :
*   va_fichier        : Le chemin d'accès au fichier dont le texte est à lire ;
*   ta_commentaires   : Liste de chaines marquant un commentaire.
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : La liste des lignes de texte du fichier,
*                        ou NULL si le fichier n'est pas trouvé.
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*
---------------------------------------------------------------------------- */

VAR	vl_texteBrut		' le texte lu en fichier
VAR	vl_texte		' le texte retourne
VAR	vl_ligne
VAR	i, j

/*A Si le fichier est introuvable alors */
IF NOT FILE_EXISTS@ (va_fichier) {
	/*A retourner un texte NULL */
	vl_texte = NULL
} ELSE {
	/*A sinon lire son contenu et filtrer les lignes commentées */
	vl_texteBrut = READ_ASCII_FILE@ (va_fichier)
	vl_texte = { }
	FOR i = 0 TO ARRAY_SIZE@ (vl_texteBrut) - 1
		vl_ligne = TRIM@ (TABS_TO_SPACES@ (vl_texteBrut[i]))
		FOR j = 0 TO ARRAY_SIZE@ (ta_commentaires) - 1
			IF SUBSTRING@ (vl_ligne, 1, LEN@ (ta_commentaires[j])) = ta_commentaires[j] {
				vl_ligne = NULL
				BREAK j
			}
		NEXT j
		IF NOT IS_NULL@ (vl_ligne) {
			vl_texte[ARRAY_SIZE@ (vl_texte)] = vl_texteBrut[i]
		}
	NEXT i
}

RETURN (vl_texte)

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Lit un fichier donné et retourne la table de chaînes qu'il contient,
*  constituée de la liste des champs séparés par une chaîne donnée
*  de toutes les lignes qui ne débutent pas par une marque de commentaire.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO COM47_LireTable (va_fichier, ta_commentaires, va_separateur)

/*
* ARGUMENTS EN ENTREE :
*   va_fichier        : Le chemin d'accès au fichier dont le texte est à lire ;
*   ta_commentaires   : Liste de chaines marquant un commentaire ;
*   va_separateur     : chaine de caracteres separant les champs d'une ligne.
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : La table des champs de texte du fichier,
*                        ou NULL si le fichier n'est pas trouvé.
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*
---------------------------------------------------------------------------- */

VAR	vl_texte		' le texte contenu dans le fichier
VAR	vl_table		' la table retournee
VAR	vl_ligne
VAR	i

/*A Lire le texte du fichier et s'il n'est pas trouve alors */
vl_texte = COM46_LireTexte (va_fichier, ta_commentaires)
IF IS_NULL@ (vl_texte) {
	/*A retourner une table NULLe */
	vl_table = NULL
} ELSE {
	/*A sinon découper chaque ligne en champs délimitées par le séparateur indiqué */
	vl_table = { }
	FOR i = 0 TO ARRAY_SIZE@ (vl_texte) - 1
		/*! si le separateur n'est pas la tabulation alors */
		IF va_separateur = "\t" {
			vl_ligne = vl_texte[i]
		} ELSE {
			/*! ignorer les tabulations */
			vl_ligne = TABS_TO_SPACES@ (vl_texte[i])
		}
		vl_table[ARRAY_SIZE@ (vl_table)] = ARRAY_FROM_STRING@ (vl_ligne, va_separateur)
	NEXT i
}

RETURN (vl_table)

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Fonctions d'aide a la saisie d'horodates :
*  verifient les champs d'horodate et proposent une valeur par defaut.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM48_Annee (va_annee)

	VAR	vl_annee

vl_annee = va_annee + 0

IF vl_annee = NULL
	RETURN (NULL)

IF vl_annee < 100 {
	' Considerer que ce peut etre une date saisie abregee OU la date courante lue par Applix
	IF vl_annee < 90 {
		' On suppose que c'est une date saisie abregee
		vl_annee = 2000 + vl_annee
	} ELSE {
		' Cela peut etre la date courante lue par Applix; valable aussi pour une date saisie
		vl_annee = 1900 + vl_annee
	}
/*
' La fonction etant quasiment dediee a la saisie, considerer une annee a trois chiffres comme erronee
} ELSE IF vl_annee < 1000 {
	' On suppose que c'est la date courante lue par Applix
	vl_annee = 1900 + vl_annee
*/
} ELSE {
	vl_annee = vl_annee
}

RETURN (vl_annee)

ENDFUNCTION



MACRO COM48_Jours (va_mois, va_annee)

	VAR     vl_mois, vl_annee

/* Verifier et determiner la valeur exacte de l'annee */
vl_annee = COM48_Annee (va_annee)
IF vl_annee = NULL
	RETURN (NULL)

vl_mois = va_mois + 0
IF (vl_mois = NULL)  OR  (vl_mois < 1)  OR  (vl_mois > 12)
	RETURN (NULL)

IF (vl_mois = 2) {
	IF COM13_Annee_Bissextile (vl_annee)
		RETURN (29)
	ELSE
		RETURN (28)
}

IF (vl_mois = 4)  OR  (vl_mois = 6)  OR  (vl_mois = 9)  OR  (vl_mois = 11)
	RETURN (30)

RETURN (31)

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Teste si l'horodate appartient È l'historique par rapport È la date courante
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM50_DateHistorique(va_Horodate)

/*
* ARGUMENTS EN ENTREE :
*   va_Horodate       : date au format affiche
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : TRUE : si la date est anterieure È un mois 
			FALSE : sinon.
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Recherche le nombre de jours depuis 1/1/1970  ;
*   conversion en secondes
*   difference avec la date courante
*
---------------------------------------------------------------------------- */

VAR i
VAR vl_jour,vl_mois, vl_annee, vl_heure, vl_minute
VAR vl_nb_jours
VAR vl_secondes
VAR vl_jours_cumules
VAR vl_secondes_du_jour
VAR vl_delta

	IF IS_NULL@(va_Horodate)
		RETURN (NULL)

	COM14_Valeurs_Horodate(va_Horodate, vl_jour,vl_mois, vl_annee, 
					vl_heure, vl_minute)

	vl_jours_cumules = CM_JOURS_CUMULES

	/*A rechercher le nombre de jours depuis 1900 */
	vl_nb_jours = (vl_annee - 1970 ) * 365 + 
				vl_jours_cumules[vl_mois - 1] + vl_jour - 1

	/*A ajout un jour par annee bissextile */
	FOR i=1970 TO vl_annee - 1
		if COM13_Annee_Bissextile(i) 
			vl_nb_jours = vl_nb_jours + 1
	NEXT i
	IF vl_mois>2
	{
		if COM13_Annee_Bissextile(vl_annee) 
			vl_nb_jours = vl_nb_jours + 1		
	}

	/*A conversion en nombre de secondes */
	vl_secondes = ((vl_nb_jours * 24) + vl_heure) * 3600 + (vl_minute * 60)

	vl_secondes_du_jour= CURRENT_TIME@()
	vl_delta = vl_secondes_du_jour-vl_secondes
	
	IF (vl_delta > XDC_OFFSET_EN_JOURS_PURGE_BASE * 24 * 3600) {
		RETURN (TRUE)
	} ELSE {
		RETURN (FALSE)
	}

ENDMACRO

/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Verifie que les 2 dates saisies sont inferieures a 1 an.               
*  si poste operateur et 1 des 2 dates superieures a 1 an => NOK. Dans tous les autres cas, OK 
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM50_Verifie_Recul_Dates (va_date1,va_date2)

/*
* ARGUMENTS EN ENTREE :
*   va_date1, va_date2 : les 2 dates a controller
*
*
* ARGUMENTS EN SORTIE : Neant 
*
*
* VALEUR RETOURNEE    : OK sinon NOK pour les dates > 1 an pour les postes operateur
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Verifie que si on est sur un poste sensible, les 2 dates passees en parametre sont inferieures a 1 an
*
---------------------------------------------------------------------------- */

    VAR     vl_maintenant                       ' Date et heure courantes
    VAR     vl_poste                   

/*A
 * Lire la date courante et la formater
 * ------------------------------------
 */
vl_maintenant = COM09_Date_Courante (CURRENT_TIME@())
vl_poste = SYSTEM_VAR@("vg_poste")

 /*info_message@("AUJOURD'HUI " ++ vl_maintenant ++ "POSTE " ++ vl_poste ++ "DATE1 " ++ va_date1 ++ "DATE2 " ++ va_date2 ) */

/* si on est sur un des postes sensibles au sens cnil du terme */
IF (
     vl_poste = "POCI1" or
     vl_poste = "POCI2" or
     vl_poste = "POCI3" or
     vl_poste = "POCI4" or
     vl_poste = "POCA1" or
     vl_poste = "POCA2" or
     vl_poste = "POCA3" or
     vl_poste = "POCA4" or
     vl_poste = "POVE1" or
     vl_poste = "POVE2" or
     vl_poste = "POVD1" or
     vl_poste = "POVD2" or
     vl_poste = "POPR1" or
     vl_poste = "POPR2" or
     vl_poste = "PODFA2"
   )
{
  /*info_message@("POSTE SENSIBLE"++vl_poste)*/
  IF COM17_Difference_Dates (vl_maintenant, va_date1) > 525600    
  {
    /*info_message@("DATE1 SUPERIEURE A 1 AN")*/
    RETURN (COM_NOK)
  }
  ELSE
  {
    IF COM17_Difference_Dates (vl_maintenant, va_date2) > 525600    
    {
      /*info_message@("DATE2 SUPERIEURE A 1 AN")*/
      RETURN (COM_NOK)
    }
    ELSE
    { 
      /*info_message@("POSTE SENSIBLE MAIS DATES OK")*/
      RETURN (COM_OK)
    }
  }
}
ELSE
{
  /*info_message@("POSTE NON SENSIBLE")*/
  RETURN (COM_OK)
}
ENDFUNCTION




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
* retourne le nom du district correspondant au numero
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM51_NomSite(va_numero_site)
VAR vl_district,vl_numero

IF (IS_NUMBER@(va_numero_site) OR IS_NUMERIC_STRING@(va_numero_site))
{
	vl_numero=va_numero_site+0

	/*on recupere le nom du district*/
	case of vl_numero
	case XDC_CI
		vl_district = XDC_NOM_SITE_CI
	case XDC_VC
		vl_district = XDC_NOM_SITE_VC
	case XDC_DN
		vl_district = XDC_NOM_SITE_DN
	case XDC_DA
		vl_district = XDC_NOM_SITE_DA
	case XDC_VE
		vl_district = XDC_NOM_SITE_VE
	case XDC_DP
		vl_district = XDC_NOM_SITE_DP
	case XDC_VD
		vl_district = XDC_NOM_SITE_VD
	default
		vl_district = SYSTEM_VAR@(vg_nom_site)
	endcase
}
else
{
	vl_district = SYSTEM_VAR@(vg_nom_site)
}

return (vl_district)

ENDFUNCTION




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Execute une macro donnee apres attente d'un delai donne
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO COM52_Exec_Differee (va_Delai, va_Macro, va_Parametres)

/*
* ARGUMENTS EN ENTREE :
*   va_Delai          : delai d'attente avant lancement de la macro ;
*   va_Macro          : macro a executer ;
*   va_Parametres     : arguments a fournir a la macro.
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : Aucune
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Lance une nouvelle tache qui attend durant le delai indique,
*   puis qui execute la macro avec les va_parametres indiques.
*
---------------------------------------------------------------------------- */

	NEW_TASK@ ("COM52_Exec_Differee_1", va_Delai, va_Macro, va_Parametres)
ENDMACRO


MACRO COM52_Exec_Differee_1 (va_Delai, va_Macro, va_Args)
	IF (va_Delai > 0) {
		DELAY@ (va_Delai)
	}

	NEW_TASK@ (va_Macro,
			va_Args[0], va_Args[1], va_Args[2], va_Args[3], va_Args[4],
			va_Args[5], va_Args[6], va_Args[7], va_Args[8], va_Args[9])
ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Lance une tache dont la macro est indiquee si elle ne l'est pas deja.
*  Dans le cas ou la tache est deja lancee, donne le focus a sa fenetre.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO COM53_Lancer_Tache (va_nom_macro,
                             va_arg0, va_arg1, va_arg2, va_arg3, va_arg4,
                             va_arg5, va_arg6, va_arg7, va_arg8, va_arg9)

/*
* ARGUMENTS EN ENTREE :
*   va_nom_macro      : Le nom de la macro point d'entree de la tache ;
*   va_argN           : Neme parametre.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : L'identifiant de la tache si la macro est active,
*                       NULL sinon.
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Consulte la liste des taches actives et recherche celle correspondant
*   a la macro Applix de nom indique.
*   Si elle est trouvee, recherche la fenetre associee et lui donne le focus,
*   sinon lance une nouvelle tache executant la macro.
*
---------------------------------------------------------------------------- */

	VAR	vl_id_tache, vl_id_fenetre

vl_id_tache = COM21_Tache_De_La_Macro (va_nom_macro)

IF IS_NULL@ (vl_id_tache)
{
	/* Si la tache n'est pas lancee alors la lancer */
	NEW_TASK@ (va_nom_macro,
			va_arg0, va_arg1, va_arg2, va_arg3, va_arg4,
			va_arg5, va_arg6, va_arg7, va_arg8, va_arg9)
}
ELSE
{
	/* sinon si une fenetre lui est associee, l'activer en avant-plan */
	vl_id_fenetre = COM22_Fenetre_De_La_Tache (vl_id_tache)
	IF NOT IS_NULL@ (vl_id_fenetre)
	{
		SELECT_WINDOW@ (vl_id_fenetre, TRUE)
	}
}

ENDMACRO


/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Demande au synoptique Flash l'execution d'une fonction de masque ou de vue.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO COM54_ExecSynoptiqueFlash (va_fonction, va_arg)

/*  
* ARGUMENTS EN ENTREE :
*   va_fonction      : La fonction CM_MASK ou CM_AFFICHE_VUE
*   va_arg           : l'equipement ou la vue concernee
*   
*   
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : COM_OK en cas d'execution correcte, COM_NOK sinon.
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*
---------------------------------------------------------------------------- */

VAR     tl_cmd

       case of va_fonction
        case CM_MASK
                COM01_Trace (COM_DEBUG1, "COM54_ExecSynoptiqueFlash : MASK")
                tl_cmd = MTAR_MSG_EXEC, 1, MTAR_FCT_MSQ, va_arg
        case CM_AFFICH_VUE
                COM01_Trace (COM_DEBUG1, "COM54_ExecSynoptiqueFlash : VUE")
                tl_cmd = MTAR_MSG_EXEC, 1, MTAR_FCT_VUE, va_arg
        case CM_CARACT_TDP
                COM01_Trace (COM_DEBUG1, "COM54_ExecSynoptiqueFlash : TDP")
                tl_cmd = MTAR_MSG_EXEC, 1, MTAR_FCT_TDP_MZ, va_arg
       case CM_CARACT_FT
                COM01_Trace (COM_DEBUG1, "COM54_ExecSynoptiqueFlash : F2T")
                tl_cmd = MTAR_MSG_EXEC, 1, MTAR_FCT_F2T, va_arg
        case CM_CARACT_FT_REF
                COM01_Trace (COM_DEBUG1, "COM54_ExecSynoptiqueFlash : F2T_REF")
                tl_cmd = MTAR_MSG_EXEC, 1, MTAR_FCT_F2T_REF, va_arg
        case CM_CARACT_INRETS
                COM01_Trace (COM_DEBUG1, "COM54_ExecSynoptiqueFlash : INRETS")
                tl_cmd = MTAR_MSG_EXEC, 1, MTAR_FCT_INRETS, va_arg

        case CM_AFFPLAN
                COM01_Trace (COM_DEBUG1, "COM54_ExecSynoptiqueFlash : PLAN DE SECOURS")
                tl_cmd = MTAR_MSG_EXEC, 1, MTAR_FCT_PLANSECOURS, va_arg
        default
                tl_cmd = NULL
        endcase

        IF NOT IS_NULL@ (tl_cmd)
        {
                DB_SEND_POKE@ (COM_CANAL_TAR01, tl_cmd)
        }
        ELSE
        {
                COM01_Trace (COM_DEBUG2, "fonction Inconnue")
        }


ENDMACRO


/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Recherche si un fichier donne (source ou compile) est present et s'il l'est,
*  le lit (le recharge a chaque fois) et le compile s'il s'agit de code source.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO COM54_Lire_Fichier (va_nom_fichier)

/*
* ARGUMENTS EN ENTREE :
*   va_nom_fichier    : Le nom du fichier a charger.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : COM_OK si le fichier est trouve, COM_NOK sinon.
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Recherche le fichier indique dans le repertoire de l'application MIGRAZUR.
*   S'il est trouve, (re)charge son contenu et le compile si c'est du source.
*
---------------------------------------------------------------------------- */

	VAR	vl_chemin_fichier

IF (SUBSTRING@ (va_nom_fichier, 1, 1) = "/")
	vl_chemin_fichier = va_nom_fichier
ELSE
	vl_chemin_fichier = SYSTEM_VAR@ (vg_repertoire_migrazur) ++ "exec/" ++ va_nom_fichier

IF FILE_EXISTS@ (vl_chemin_fichier) {
	/* Si le fichier est trouve alors le charger */
	INSTALL_FILE@ (vl_chemin_fichier)
	RETURN (COM_OK)
} ELSE IF FILE_EXISTS@ (vl_chemin_fichier ++ ".am") {
	INSTALL_FILE@ (vl_chemin_fichier ++ ".am")
	RETURN (COM_OK)
} ELSE IF FILE_EXISTS@ (vl_chemin_fichier ++ ".elo") {
	INSTALL_FILE@ (vl_chemin_fichier ++ ".elo")
	RETURN (COM_OK)
} ELSE {
	RETURN (COM_NOK)
}

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Recherche si le fichier source ou compile d'une macro est present et
*  s'il l'est, le lit (le recharge a chaque fois) puis execute la macro.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO COM55_Lire_Et_Faire (va_nom_macro,
                             va_arg0, va_arg1, va_arg2, va_arg3, va_arg4,
                             va_arg5, va_arg6, va_arg7, va_arg8, va_arg9)

/*
* ARGUMENTS EN ENTREE :
*   va_nom_macro      : Le nom de la macro a charger et executer ;
*   va_argN           : Neme parametre.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : COM_OK si le fichier est trouve, COM_NOK sinon.
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Recherche un fichier source ou compile de la macro dans le repertoire
*   de l'application MIGRAZUR. Puis le charge et execute la macro.
*
---------------------------------------------------------------------------- */

	VAR	vl_chemin_fichier

IF (SUBSTRING@ (va_nom_macro, 1, 1) = "/")
	vl_chemin_fichier = va_nom_macro
ELSE
	vl_chemin_fichier = SYSTEM_VAR@ (vg_repertoire_migrazur) ++ "exec/" ++ va_nom_macro

IF FILE_EXISTS@ (vl_chemin_fichier ++ ".am") {
	INSTALL_FILE@ (vl_chemin_fichier ++ ".am")
	!va_nom_macro ( va_arg0, va_arg1, va_arg2, va_arg3, va_arg4,
			va_arg5, va_arg6, va_arg7, va_arg8, va_arg9)
	RETURN (COM_OK)
} ELSE IF FILE_EXISTS@ (vl_chemin_fichier ++ ".elo") {
	INSTALL_FILE@ (vl_chemin_fichier ++ ".elo")
	!va_nom_macro ( va_arg0, va_arg1, va_arg2, va_arg3, va_arg4,
			va_arg5, va_arg6, va_arg7, va_arg8, va_arg9)
	RETURN (COM_OK)
} ELSE {
	RETURN (COM_NOK)
}

ENDMACRO




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Retourne la valeur numerique d'une chaine de caracteres.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

FUNCTION COM56_Valeur (va_texte)

/*
* ARGUMENTS EN ENTREE :
*   va_texte          : Chaine de caracteres a evaluer.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : La valeur du texte, NULL si non numerique.
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* FONCTION
*   Evalue simplement la valeur du texte supposee etre numerique ;
*   Sur erreur retourne la valeur NULLe.
*
---------------------------------------------------------------------------- */

ON ERROR
{
	RETURN (NULL)
}

RETURN (va_texte + 0)

ENDFUNCTION




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Predicat determinant si une chaine de caracteres represente
*  un nombre non signe.
-------------------------------------------------------------------------------
* SEQUENCES D'APPEL :
*/

FUNCTION COM_Is_Digit_String (va_texte)

/*
* ARGUMENTS EN ENTREE :
*   va_texte          : Chaine de caracteres a evaluer.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : TRUE ssi. le texte est un entier non signe, FALSE sinon.
*
*
* CONDITION D'UTILISATION
*   Toute macro.
*
* REMARQUES : les espaces dans le texte ne sont pas autorises.
*
*
* FONCTION
*   Verifie que tous les caracteres sont des chiffres.
*
---------------------------------------------------------------------------- */

VAR	vl_lgr, vl_car

IF NOT IS_STRING@ (va_texte) {
	RETURN (FALSE)
}

vl_lgr = LEN@ (va_texte)
IF (vl_lgr = 0) { RETURN (FALSE) }

WHILE (vl_lgr > 0)
	vl_car = SUBSTRING@ (va_texte, vl_lgr, 1)
	IF NOT ( (vl_car >>= "0")  AND  (vl_car <<= "9") ) {
		RETURN (FALSE)
	}
	vl_lgr = vl_lgr - 1
WEND

RETURN (TRUE)

ENDFUNCTION




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*
*  Predicat determinant si une chaine de caracteres represente un nombre entier.
-------------------------------------------------------------------------------
* SEQUENCES D'APPEL :
*/

FUNCTION COM_Is_Int_String (va_texte)
	RETURN (COM_Is_Integer_String (va_texte))
ENDFUNCTION


FUNCTION COM_Is_Integer_String (va_texte)

/*
* ARGUMENTS EN ENTREE :
*   va_texte          : Chaine de caracteres a evaluer.
*
*
* ARGUMENTS EN SORTIE : Aucun
*
*
* VALEUR RETOURNEE    : TRUE si le texte represente un entier, FALSE sinon.
*
*
* CONDITION D'UTILISATION
*
*   A la place de IS_NUMERIC_STRING@ qui admet des ',' et '.' en nombre quelconque.
*   Celle-ci, combinee avec COM56_Valeur, reconnait cependant des nombres decimaux
*    (et des representation hexadecimales ...).
*
*
* REMARQUES : - UN signe '+' ou '-' en premiere position est reconnu.
*             - les espaces en debut et fin du texte sont autorises.
*
*
* FONCTION
*   Obtient la valeur du texte et verifie qu'elle est entiere.
*
---------------------------------------------------------------------------- */

VAR	vl_1er_car

IF NOT IS_STRING@ (va_texte)				' Verifier que le parametre est textuel
	RETURN (FALSE)

vl_1er_car = SUBSTRING@ (va_texte, 1, 1)

IF (vl_1er_car = "+")  OR  (vl_1er_car = "-") {
	RETURN (COM_Is_Digit_String (SUBSTRING@ (va_texte, 2)))
} ELSE {
	RETURN (COM_Is_Digit_String (va_texte))
}

ENDFUNCTION




/*X*/
/* ----------------------------------------------------------------------------
* SERVICE RENDU :
*  Retourne l'index de la position d'une valeur dans une liste supposée triée.
*  Si la valeur n'est pas dans la liste, c'est la position où elle doit figurer.
-------------------------------------------------------------------------------
* SEQUENCE D'APPEL :
*/

MACRO COM_Index_En_Liste_Triee (la_liste, va_valeur, va_index)

/*
* ARGUMENTS EN ENTREE :
*   la_liste          : La liste dans laquelle la valeur est recherchée ;
*   va_valeur         : La valeur recherchée.
*
* ARGUMENTS EN SORTIE :
*   va_index          : Index, position de la valeur dans la liste.
*
*
* VALEUR RETOURNEE    : XDC_VRAI si la valeur est trouvée, XDC_FAUX sinon.
*
* CONDITION D'UTILISATION
*   Les valeurs doivent être numériques dans cette version.
*
* FONCTION
*
*  Effectue une recherche dichotomique dans la liste.
*
---------------------------------------------------------------------------- */

VAR	vl_i_min, vl_i_max
VAR	vl_curseur

vl_i_min = 0
vl_i_max = ARRAY_SIZE@ (la_liste)

/* Tant que l'intervalle de recherche n'est pas réduit à un seul point */
WHILE (vl_i_min < vl_i_max)
	vl_curseur = (vl_i_min + vl_i_max) \ 2

	/* si la position médiane contient la valeur alors */
	IF (la_liste[vl_curseur] = va_valeur) {
		/* l'intervalle de recherche est réduit à ce lieu */
		vl_i_min = vl_curseur
		vl_i_max = vl_curseur
	} ELSE IF (la_liste[vl_curseur] < va_valeur) {
		/* sinon si sa valeur est inférieure à celle recherchée alors */
		/* l'intervalle de recherche commence après ce point */
		vl_i_min = vl_curseur + 1
	} ELSE {
		/* sinon (sa valeur est supérieure à celle recherchée) */
		/* l'intervalle de recherche finit avant ce point */
		vl_i_max = vl_curseur
	}
WEND

va_index = vl_i_min

IF (vl_i_min < ARRAY_SIZE@ (la_liste)) {
	IF (la_liste[vl_curseur] = va_valeur) {
		RETURN (XDC_VRAI)
	}
}
RETURN (XDC_FAUX)

ENDMACRO
